<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>美团面经汇总</title>
      <link href="/2023/12/21/%E9%9D%A2%E8%AF%95%E7%9C%9F%E9%A2%98/2%E7%BE%8E%E5%9B%A2%E9%9D%A2%E7%BB%8F%E6%B1%87%E6%80%BB/"/>
      <url>/2023/12/21/%E9%9D%A2%E8%AF%95%E7%9C%9F%E9%A2%98/2%E7%BE%8E%E5%9B%A2%E9%9D%A2%E7%BB%8F%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1><span id="公司名">公司名</span></h1><h2><span id="具体面试部门">具体面试部门</span></h2>]]></content>
      
      
      <categories>
          
          <category> 面试真题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SQL练习</title>
      <link href="/2023/12/06/%E9%9D%A2%E8%AF%95%E7%9C%9F%E9%A2%98/2SQL%E7%BB%83%E4%B9%A0/"/>
      <url>/2023/12/06/%E9%9D%A2%E8%AF%95%E7%9C%9F%E9%A2%98/2SQL%E7%BB%83%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc --><ul><li><a href="#%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0">基础练习</a><ul><li><a href="#%E5%9F%BA%E7%A1%80%E6%9F%A5%E8%AF%A2">基础查询</a><ul><li><a href="#sql1-%E6%9F%A5%E8%AF%A2%E6%89%80%E6%9C%89%E5%88%97">SQL1 查询所有列</a></li><li><a href="#sql2-%E6%9F%A5%E8%AF%A2%E5%A4%9A%E5%88%97">SQL2 查询多列</a></li></ul></li><li><a href="#%E7%AE%80%E5%8D%95%E5%A4%84%E7%90%86%E6%9F%A5%E8%AF%A2%E7%BB%93%E6%9E%9C">简单处理查询结果</a><ul><li><a href="#sql3-%E6%9F%A5%E8%AF%A2%E7%BB%93%E6%9E%9C%E5%8E%BB%E9%87%8D">SQL3 查询结果去重</a></li><li><a href="#sql4-%E6%9F%A5%E8%AF%A2%E7%BB%93%E6%9E%9C%E9%99%90%E5%88%B6%E8%BF%94%E5%9B%9E%E8%A1%8C%E6%95%B0">SQL4 查询结果限制返回行数</a></li><li><a href="#sql5-%E5%B0%86%E6%9F%A5%E8%AF%A2%E5%90%8E%E7%9A%84%E5%88%97%E9%87%8D%E6%96%B0%E5%91%BD%E5%90%8D">SQL5 将查询后的列重新命名</a></li></ul></li><li><a href="#%E6%9D%A1%E4%BB%B6%E6%9F%A5%E8%AF%A2">条件查询</a><ul><li><a href="#%E5%9F%BA%E7%A1%80%E6%8E%92%E5%BA%8F">基础排序</a><ul><li><a href="#sql36-%E6%9F%A5%E6%89%BE%E5%90%8E%E6%8E%92%E5%BA%8F">SQL36 查找后排序</a></li><li><a href="#sql37-%E6%9F%A5%E6%89%BE%E5%90%8E%E5%A4%9A%E5%88%97%E6%8E%92%E5%BA%8F">SQL37 查找后多列排序</a></li><li><a href="#sql38-%E6%9F%A5%E6%89%BE%E5%90%8E%E9%99%8D%E5%BA%8F%E6%8E%92%E5%88%97">SQL38 查找后降序排列</a></li></ul></li><li><a href="#%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C%E7%AC%A6">基础操作符</a><ul><li><a href="#sql6-%E6%9F%A5%E6%89%BE%E5%AD%A6%E6%A0%A1%E6%98%AF%E5%8C%97%E5%A4%A7%E7%9A%84%E5%AD%A6%E7%94%9F%E4%BF%A1%E6%81%AF">SQL6 查找学校是北大的学生信息</a></li><li><a href="#sql7-%E6%9F%A5%E6%89%BE%E5%B9%B4%E9%BE%84%E5%A4%A7%E4%BA%8E24%E5%B2%81%E7%9A%84%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF">SQL7 查找年龄大于24岁的用户信息</a></li><li><a href="#sql8-%E6%9F%A5%E6%89%BE%E6%9F%90%E4%B8%AA%E5%B9%B4%E9%BE%84%E6%AE%B5%E7%9A%84%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF">SQL8 查找某个年龄段的用户信息</a></li><li><a href="#sql9-%E6%9F%A5%E6%89%BE%E9%99%A4%E5%A4%8D%E6%97%A6%E5%A4%A7%E5%AD%A6%E7%9A%84%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF">SQL9 查找除复旦大学的用户信息</a></li><li><a href="#sql10-%E7%94%A8where%E8%BF%87%E6%BB%A4%E7%A9%BA%E5%80%BC%E7%BB%83%E4%B9%A0">SQL10 用where过滤空值练习</a></li></ul></li><li><a href="#%E9%AB%98%E7%BA%A7%E6%93%8D%E4%BD%9C%E7%AC%A6">高级操作符</a><ul><li><a href="#sql11-%E9%AB%98%E7%BA%A7%E6%93%8D%E4%BD%9C%E7%AC%A6%E7%BB%83%E4%B9%A01">SQL11 高级操作符练习(1)</a></li><li><a href="#sql12-%E9%AB%98%E7%BA%A7%E6%93%8D%E4%BD%9C%E7%AC%A6%E7%BB%83%E4%B9%A02">SQL12 高级操作符练习(2）</a></li><li><a href="#sql13-where-in-%E5%92%8Cnot-in">SQL13 Where in 和Not in</a></li><li><a href="#sql14-%E6%93%8D%E4%BD%9C%E7%AC%A6%E6%B7%B7%E5%90%88%E8%BF%90%E7%94%A8">SQL14 操作符混合运用</a></li><li><a href="#sql15-%E6%9F%A5%E7%9C%8B%E5%AD%A6%E6%A0%A1%E5%90%8D%E7%A7%B0%E4%B8%AD%E5%90%AB%E5%8C%97%E4%BA%AC%E7%9A%84%E7%94%A8%E6%88%B7">SQL15 查看学校名称中含北京的用户</a></li></ul></li></ul></li><li><a href="#%E9%AB%98%E7%BA%A7%E6%9F%A5%E8%AF%A2">高级查询</a><ul><li><a href="#%E8%AE%A1%E7%AE%97%E5%87%BD%E6%95%B0">计算函数</a><ul><li><a href="#sql16-%E6%9F%A5%E6%89%BEgpa%E6%9C%80%E9%AB%98%E5%80%BC">SQL16 查找GPA最高值</a></li><li><a href="#sql17-%E8%AE%A1%E7%AE%97%E7%94%B7%E7%94%9F%E4%BA%BA%E6%95%B0%E4%BB%A5%E5%8F%8A%E5%B9%B3%E5%9D%87gpa">SQL17 计算男生人数以及平均GPA</a></li></ul></li><li><a href="#%E5%88%86%E7%BB%84%E6%9F%A5%E8%AF%A2">分组查询</a><ul><li><a href="#sql18-%E5%88%86%E7%BB%84%E8%AE%A1%E7%AE%97%E7%BB%83%E4%B9%A0%E9%A2%98">SQL18 分组计算练习题</a></li><li><a href="#sql19-%E5%88%86%E7%BB%84%E8%BF%87%E6%BB%A4%E7%BB%83%E4%B9%A0%E9%A2%98">SQL19 分组过滤练习题</a></li><li><a href="#sql20-%E5%88%86%E7%BB%84%E6%8E%92%E5%BA%8F%E7%BB%83%E4%B9%A0%E9%A2%98">SQL20 分组排序练习题</a></li></ul></li></ul></li></ul></li></ul><!-- tocstop --><h1><span id="基础练习">基础练习</span></h1><p>牛客练习链接:<br><a href="https://www.nowcoder.com/exam/oj?page=1&amp;tab=SQL%E7%AF%87&amp;topicId=199">https://www.nowcoder.com/exam/oj?page=1&amp;tab=SQL%E7%AF%87&amp;topicId=199</a></p><h2><span id="基础查询">基础查询</span></h2><h3><span id="sql1-查询所有列">SQL1 查询所有列</span></h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> user_profile;</span><br></pre></td></tr></table></figure><h3><span id="sql2-查询多列">SQL2 查询多列</span></h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> device_id,gender,age,university <span class="keyword">from</span> user_profile;</span><br></pre></td></tr></table></figure><h2><span id="简单处理查询结果">简单处理查询结果</span></h2><h3><span id="sql3-查询结果去重">SQL3 查询结果去重</span></h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span>  university <span class="keyword">from</span> user_profile;</span><br></pre></td></tr></table></figure><h3><span id="sql4-查询结果限制返回行数">SQL4 查询结果限制返回行数</span></h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> device_id <span class="keyword">from</span> user_profile limit <span class="number">2</span>;</span><br></pre></td></tr></table></figure><h3><span id="sql5-将查询后的列重新命名">SQL5 将查询后的列重新命名</span></h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> device_id <span class="keyword">as</span> user_infos_example  <span class="keyword">from</span> user_profile limit <span class="number">2</span>;</span><br></pre></td></tr></table></figure><h2><span id="条件查询">条件查询</span></h2><h3><span id="基础排序">基础排序</span></h3><h4><span id="sql36-查找后排序">SQL36 查找后排序</span></h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> device_id,age <span class="keyword">from</span> user_profile <span class="keyword">order</span> <span class="keyword">by</span> age;</span><br></pre></td></tr></table></figure><h4><span id="sql37-查找后多列排序">SQL37 查找后多列排序</span></h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> device_id,gpa,age <span class="keyword">from</span> user_profile <span class="keyword">order</span> <span class="keyword">by</span> gpa,age;</span><br></pre></td></tr></table></figure><h4><span id="sql38-查找后降序排列">SQL38 查找后降序排列</span></h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> device_id,gpa,age <span class="keyword">from</span> user_profile <span class="keyword">order</span> <span class="keyword">by</span> gpa <span class="keyword">desc</span>, age <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure><h3><span id="基础操作符">基础操作符</span></h3><h4><span id="sql6-查找学校是北大的学生信息">SQL6 查找学校是北大的学生信息</span></h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> device_id,university <span class="keyword">from</span> user_profile <span class="keyword">where</span> university <span class="operator">=</span> <span class="string">&#x27;北京大学&#x27;</span>;</span><br></pre></td></tr></table></figure><h4><span id="sql7-查找年龄大于24岁的用户信息">SQL7 查找年龄大于24岁的用户信息</span></h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> device_id,gender,age,university <span class="keyword">from</span>  user_profile <span class="keyword">where</span> age <span class="operator">&gt;</span> <span class="number">24</span>;</span><br></pre></td></tr></table></figure><h4><span id="sql8-查找某个年龄段的用户信息">SQL8 查找某个年龄段的用户信息</span></h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span>  device_id,gender,age <span class="keyword">from</span> user_profile <span class="keyword">where</span> age <span class="operator">&gt;=</span> <span class="number">20</span> <span class="keyword">and</span> age <span class="operator">&lt;=</span> <span class="number">23</span>;</span><br></pre></td></tr></table></figure><h4><span id="sql9-查找除复旦大学的用户信息">SQL9 查找除复旦大学的用户信息</span></h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> device_id,gender,age,university <span class="keyword">from</span> user_profile <span class="keyword">where</span> <span class="keyword">not</span> (university <span class="operator">=</span> <span class="string">&#x27;复旦大学&#x27;</span>);</span><br></pre></td></tr></table></figure><h4><span id="sql10-用where过滤空值练习">SQL10 用where过滤空值练习</span></h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> device_id,gender,age,university <span class="keyword">from</span> user_profile  <span class="keyword">where</span> age <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><h3><span id="高级操作符">高级操作符</span></h3><h4><span id="sql11-高级操作符练习1">SQL11 高级操作符练习(1)</span></h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> device_id,gender,age,university,gpa <span class="keyword">from</span> user_profile <span class="keyword">where</span> gpa <span class="operator">&gt;</span> <span class="number">3.5</span> <span class="keyword">and</span> gender <span class="operator">=</span> <span class="string">&#x27;male&#x27;</span>;</span><br></pre></td></tr></table></figure><h4><span id="sql12-高级操作符练习2">SQL12 高级操作符练习(2）</span></h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> device_id,gender,age,university,gpa <span class="keyword">from</span> user_profile <span class="keyword">where</span> university <span class="operator">=</span> <span class="string">&#x27;北京大学&#x27;</span> <span class="keyword">or</span> gpa <span class="operator">&gt;</span> <span class="string">&#x27;3.7&#x27;</span></span><br></pre></td></tr></table></figure><h4><span id="sql13-where-in-和not-in">SQL13 Where in 和Not in</span></h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> device_id,gender,age,university,gpa <span class="keyword">from</span> user_profile <span class="keyword">where</span> university <span class="operator">=</span> <span class="string">&#x27;北京大学&#x27;</span> <span class="keyword">or</span> university <span class="operator">=</span> <span class="string">&#x27;复旦大学&#x27;</span> <span class="keyword">or</span> university <span class="operator">=</span> <span class="string">&#x27;山东大学&#x27;</span></span><br></pre></td></tr></table></figure><h4><span id="sql14-操作符混合运用">SQL14 操作符混合运用</span></h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span>  device_id,gender,age,university,gpa <span class="keyword">from</span> user_profile <span class="keyword">where</span> (gpa <span class="operator">&gt;</span> <span class="number">3.5</span> <span class="keyword">and</span> university <span class="operator">=</span> <span class="string">&#x27;山东大学&#x27;</span>) <span class="keyword">or</span> (gpa <span class="operator">&gt;</span> <span class="number">3.8</span> <span class="keyword">and</span> university <span class="operator">=</span> <span class="string">&#x27;复旦大学&#x27;</span>)</span><br></pre></td></tr></table></figure><h4><span id="sql15-查看学校名称中含北京的用户">SQL15 查看学校名称中含北京的用户</span></h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> device_id,age,university <span class="keyword">from</span> user_profile <span class="keyword">where</span> university <span class="keyword">like</span> <span class="string">&#x27;北京%&#x27;</span></span><br></pre></td></tr></table></figure><h2><span id="高级查询">高级查询</span></h2><h3><span id="计算函数">计算函数</span></h3><h4><span id="sql16-查找gpa最高值">SQL16 查找GPA最高值</span></h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> format(gpa,<span class="number">1</span>) <span class="keyword">from</span> user_profile <span class="keyword">where</span> university <span class="operator">=</span> <span class="string">&#x27;复旦大学&#x27;</span> <span class="keyword">order</span> <span class="keyword">by</span> gpa <span class="keyword">desc</span> limit <span class="number">1</span></span><br></pre></td></tr></table></figure><h4><span id="sql17-计算男生人数以及平均gpa">SQL17 计算男生人数以及平均GPA</span></h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> </span><br><span class="line"><span class="built_in">count</span>(gender),round(<span class="built_in">avg</span>(gpa),<span class="number">1</span>)</span><br><span class="line"><span class="keyword">from</span> user_profile</span><br><span class="line"><span class="keyword">where</span> gender <span class="operator">=</span> <span class="string">&#x27;male&#x27;</span></span><br></pre></td></tr></table></figure><h3><span id="分组查询">分组查询</span></h3><h4><span id="sql18-分组计算练习题">SQL18 分组计算练习题</span></h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> </span><br><span class="line">gender,university,</span><br><span class="line"><span class="built_in">count</span>(id) <span class="keyword">as</span> user_num,</span><br><span class="line">round(<span class="built_in">avg</span>(active_days_within_30),<span class="number">1</span>)  <span class="keyword">as</span> avg_active_day,</span><br><span class="line">round(<span class="built_in">avg</span>(question_cnt),<span class="number">1</span>) <span class="keyword">as</span> avg_question_cnt </span><br><span class="line"><span class="keyword">from</span> user_profile</span><br><span class="line"> <span class="keyword">group</span> <span class="keyword">by</span> gender,university</span><br></pre></td></tr></table></figure><h4><span id="sql19-分组过滤练习题">SQL19 分组过滤练习题</span></h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># <span class="keyword">HAVING</span>子句 可以用于筛选聚合函数的结果，它作用于已经分组的数据。</span><br><span class="line"># <span class="keyword">WHERE</span>子句不能直接使用聚合函数</span><br><span class="line"><span class="keyword">select</span> </span><br><span class="line">university,</span><br><span class="line">round(<span class="built_in">avg</span>(question_cnt),<span class="number">3</span>) <span class="keyword">as</span>  avg_question_cnt,</span><br><span class="line">round(<span class="built_in">avg</span>(answer_cnt),<span class="number">3</span>) <span class="keyword">as</span> avg_answer_cnt</span><br><span class="line"><span class="keyword">from</span> user_profile</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> university</span><br><span class="line"><span class="keyword">having</span></span><br><span class="line">avg_question_cnt <span class="operator">&lt;</span> <span class="number">5</span> <span class="keyword">or</span> avg_answer_cnt <span class="operator">&lt;</span> <span class="number">20</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4><span id="sql20-分组排序练习题">SQL20 分组排序练习题</span></h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line"> university,</span><br><span class="line"> round(<span class="built_in">avg</span>(question_cnt),<span class="number">4</span>) <span class="keyword">as</span> avg_question_cnt</span><br><span class="line"> <span class="keyword">from</span></span><br><span class="line"> user_profile </span><br><span class="line"> <span class="keyword">group</span> <span class="keyword">by</span> university</span><br><span class="line"> <span class="keyword">order</span> <span class="keyword">by</span> avg_question_cnt</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>leetcode198到达首都的最少油耗</title>
      <link href="/2023/12/05/leetcode/leetcode2477%E5%88%B0%E8%BE%BE%E9%A6%96%E9%83%BD%E7%9A%84%E6%9C%80%E5%B0%91%E6%B2%B9%E8%80%97/"/>
      <url>/2023/12/05/leetcode/leetcode2477%E5%88%B0%E8%BE%BE%E9%A6%96%E9%83%BD%E7%9A%84%E6%9C%80%E5%B0%91%E6%B2%B9%E8%80%97/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>原题链接:<br><a href="https://leetcode.cn/problems/minimum-fuel-cost-to-report-to-the-capital/description/">https://leetcode.cn/problems/minimum-fuel-cost-to-report-to-the-capital/description/</a></p><h2><span id="解法1">解法1:</span></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> (<span class="type">int</span>)(<span class="number">2e5</span> + <span class="number">10</span>);</span><br><span class="line">    <span class="type">int</span> [] e = <span class="keyword">new</span>  <span class="title class_">int</span> [N];</span><br><span class="line">    <span class="type">int</span> [] h = <span class="keyword">new</span>  <span class="title class_">int</span> [N];</span><br><span class="line">    <span class="type">int</span> [] ne = <span class="keyword">new</span>  <span class="title class_">int</span> [N];</span><br><span class="line">    <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> seats;</span><br><span class="line">    <span class="comment">// 将b插入到a</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;</span><br><span class="line">        e[idx] = b;</span><br><span class="line">        ne[idx] = h[a];</span><br><span class="line">        h[a] = idx++; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">minimumFuelCost</span><span class="params">(<span class="type">int</span>[][] roads, <span class="type">int</span> seats)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.seats = seats;</span><br><span class="line">        <span class="comment">// 初始化邻接表</span></span><br><span class="line">        Arrays.fill(h,-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; roads.length ; i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> roads[i][<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> roads[i][<span class="number">1</span>];</span><br><span class="line">            <span class="comment">// 双向边  </span></span><br><span class="line">            add(a,b);</span><br><span class="line">            add(b,a);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dfs(<span class="number">0</span>,-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> ans;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> h[x] ; i != -<span class="number">1</span> ;i = ne[i])&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> e[i];</span><br><span class="line">            <span class="keyword">if</span>(j != fa)&#123;</span><br><span class="line">                size += dfs(j,x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(x &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            ans += (size - <span class="number">1</span>)  / seats + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贡献法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode面试常考150</title>
      <link href="/2023/12/04/%E9%9D%A2%E8%AF%95%E7%9C%9F%E9%A2%98/1leetcode%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%80%83150/"/>
      <url>/2023/12/04/%E9%9D%A2%E8%AF%95%E7%9C%9F%E9%A2%98/1leetcode%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%80%83150/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1><span id="二叉树">二叉树</span></h1><h2><span id="二叉树的最大深度">二叉树的最大深度</span></h2><p>原题链接:<br><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/description/?envType=study-plan-v2&amp;envId=top-interview-150">https://leetcode.cn/problems/maximum-depth-of-binary-tree/description/?envType=study-plan-v2&amp;envId=top-interview-150</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(maxDepth(root.left),maxDepth(root.right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2><span id="相同的树">相同的树</span></h2><p>原题链接:<br><a href="https://leetcode.cn/problems/same-tree/description/?envType=study-plan-v2&amp;envId=top-interview-150">https://leetcode.cn/problems/same-tree/description/?envType=study-plan-v2&amp;envId=top-interview-150</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSameTree</span><span class="params">(TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(p == <span class="literal">null</span> &amp;&amp;  q == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(p == <span class="literal">null</span> || q == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(p.val != q.val)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> isSameTree(p.left,q.left) &amp;&amp; isSameTree(p.right,q.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2><span id="翻转二叉树">翻转二叉树</span></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自上而下</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">invertTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dfs(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TreeNode <span class="title function_">dfs</span><span class="params">(TreeNode node)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;     </span><br><span class="line"></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> dfs(node.left);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> dfs(node.right);</span><br><span class="line"></span><br><span class="line">        node.left = right;</span><br><span class="line">        node.right = left;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2><span id="对称二叉树">对称二叉树</span></h2><p>原题链接:<br><a href="https://leetcode.cn/problems/symmetric-tree/?envType=study-plan-v2&amp;envId=top-interview-150">https://leetcode.cn/problems/symmetric-tree/?envType=study-plan-v2&amp;envId=top-interview-150</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 左 要与 右对应</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">dfs</span><span class="params">(TreeNode left,TreeNode right)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left == <span class="literal">null</span> &amp;&amp; right == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(left == <span class="literal">null</span> ||  right == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(left.val != right.val)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dfs(left.left,right.right) &amp;&amp; dfs(left.right,right.left);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dfs(root.left,root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2><span id="从前序与中序遍历序列构造二叉树">从前序与中序遍历序列构造二叉树</span></h2><p>原题链接:<br><a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description/?envType=study-plan-v2&amp;envId=top-interview-150">https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description/?envType=study-plan-v2&amp;envId=top-interview-150</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span>[] inorder)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(preorder.length == <span class="number">0</span> || inorder.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(preorder[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> <span class="number">0</span> ; mid&lt; inorder.length ; mid++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root.val == inorder[mid])&#123;</span><br><span class="line">                <span class="type">int</span> [] pre_left = Arrays.copyOfRange(preorder,<span class="number">1</span>,mid + <span class="number">1</span>);</span><br><span class="line">                <span class="type">int</span> [] pre_right = Arrays.copyOfRange(preorder,mid + <span class="number">1</span>, preorder.length);</span><br><span class="line">                <span class="type">int</span> [] in_left = Arrays.copyOfRange(inorder,<span class="number">0</span>,mid);</span><br><span class="line">                <span class="type">int</span> [] in_right = Arrays.copyOfRange(inorder,mid + <span class="number">1</span>,inorder.length);</span><br><span class="line">                </span><br><span class="line">                root.left = buildTree(pre_left,in_left);</span><br><span class="line">                root.right = buildTree(pre_right,in_right);</span><br><span class="line">                <span class="comment">// 加速 </span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写法2:<br>用hash存储 中序树中的节点关系 这样会更好一些 也会更快一些</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 建立inorder中 值与位置的映射关系 便于后续的加速搜索</span></span><br><span class="line">    HashMap&lt;Integer,Integer&gt; hash = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> [] preorder;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span>[] inorder)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.preorder = preorder;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; inorder.length ; i++)&#123;</span><br><span class="line">            hash.put(inorder[i],i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="number">0</span>,<span class="number">0</span>,preorder.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TreeNode <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> root,<span class="type">int</span> left,<span class="type">int</span> right)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left &gt; right)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> preorder[root];</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(val);</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> hash.get(val);</span><br><span class="line">        node.left = dfs(root + <span class="number">1</span>,left,mid - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 根节点索引长度 + 左子树长度(mid - left) 的下一位 为右子树的根节点即为索引的起点</span></span><br><span class="line">        node.right = dfs(root + mid - left + <span class="number">1</span>,mid + <span class="number">1</span>,right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2><span id="从中序与后序遍历序列构造二叉树">从中序与后序遍历序列构造二叉树</span></h2><p>原题链接:<br><a href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/description/?envType=study-plan-v2&amp;envId=top-interview-150">https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/description/?envType=study-plan-v2&amp;envId=top-interview-150</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> [] postorder;</span><br><span class="line">    HashMap&lt;Integer,Integer&gt; hash = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] inorder, <span class="type">int</span>[] postorder)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.postorder = postorder;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; inorder.length ; i++)&#123;</span><br><span class="line">            hash.put(inorder[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dfs(inorder.length - <span class="number">1</span>,<span class="number">0</span>,inorder.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TreeNode <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> root,<span class="type">int</span> left,<span class="type">int</span> right)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left &gt; right)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> postorder[root];</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(val);</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> hash.get(val);</span><br><span class="line">        node.right = dfs(root - <span class="number">1</span>,mid + <span class="number">1</span>,right);</span><br><span class="line">        node.left = dfs(root - (right - mid) - <span class="number">1</span>,left,mid - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2><span id="填充每个节点的下一个右侧节点指针-ii">填充每个节点的下一个右侧节点指针 II</span></h2><p>原题链接:<br><a href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/description/?envType=study-plan-v2&amp;envId=top-interview-150">https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/description/?envType=study-plan-v2&amp;envId=top-interview-150</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">    public int val;</span></span><br><span class="line"><span class="comment">    public Node left;</span></span><br><span class="line"><span class="comment">    public Node right;</span></span><br><span class="line"><span class="comment">    public Node next;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node() &#123;&#125;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    public Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node(int _val, Node _left, Node _right, Node _next) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        left = _left;</span></span><br><span class="line"><span class="comment">        right = _right;</span></span><br><span class="line"><span class="comment">        next = _next;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    Queue&lt;Node&gt;q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">connect</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        q.offer(root);    </span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!q.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> q.size();</span><br><span class="line">            ArrayList&lt;Node&gt; tmp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(q);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; cur ; i++)&#123;</span><br><span class="line">               <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> q.poll();</span><br><span class="line"></span><br><span class="line">               <span class="keyword">if</span>(t.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                q.offer(t.left);</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">if</span>(t.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                   q.offer(t.right);</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(i == cur - <span class="number">1</span>)&#123;</span><br><span class="line">                    t.next = <span class="literal">null</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">               t.next = tmp.get(i + <span class="number">1</span>);               </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2><span id="二叉树展开为链表">二叉树展开为链表</span></h2><p>原题链接:<br><a href="https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/description/?envType=study-plan-v2&amp;envId=top-interview-150">https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/description/?envType=study-plan-v2&amp;envId=top-interview-150</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">flatten</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(root != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 左子树为空 那么直接不需要找了 跳到下一个节点即可</span></span><br><span class="line">            <span class="keyword">if</span>(root.left == <span class="literal">null</span>)&#123;</span><br><span class="line">                root = root.right;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 找到左子树 最右边节点的位置</span></span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">insert</span> <span class="operator">=</span> root.left;</span><br><span class="line">                <span class="keyword">while</span>(insert.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                    insert = insert.right;</span><br><span class="line">                &#125;</span><br><span class="line">                insert.right = root.right;</span><br><span class="line">                root.right = root.left;</span><br><span class="line">                root.left = <span class="literal">null</span>;</span><br><span class="line">                root = root.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2><span id="路径总和">路径总和</span></h2><p>原题链接:<br><a href="https://leetcode.cn/problems/path-sum/description/?envType=study-plan-v2&amp;envId=top-interview-150">https://leetcode.cn/problems/path-sum/description/?envType=study-plan-v2&amp;envId=top-interview-150</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasPathSum</span><span class="params">(TreeNode root, <span class="type">int</span> targetSum)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 已经是叶子节点 判断才成立</span></span><br><span class="line">        <span class="keyword">if</span>(root.val == targetSum &amp;&amp; root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> hasPathSum(root.left,targetSum - root.val) || hasPathSum(root.right,targetSum - root.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2><span id="求根节点到叶节点数字之和">求根节点到叶节点数字之和</span></h2><p>原题链接:<br><a href="https://leetcode.cn/problems/sum-root-to-leaf-numbers/description/?envType=study-plan-v2&amp;envId=top-interview-150">https://leetcode.cn/problems/sum-root-to-leaf-numbers/description/?envType=study-plan-v2&amp;envId=top-interview-150</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumNumbers</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上一个节点的值 </span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode node,<span class="type">int</span> pre)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> pre * <span class="number">10</span> + node.val;</span><br><span class="line">        <span class="comment">// 如果当前为叶子节点 则进行操作</span></span><br><span class="line">        <span class="keyword">if</span>(node.left == <span class="literal">null</span> &amp;&amp; node.right == <span class="literal">null</span>)&#123;</span><br><span class="line">            ans += cur;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dfs(node.left,cur);</span><br><span class="line">        dfs(node.right,cur);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2><span id="二叉树中的最大路径和">二叉树中的最大路径和</span></h2><p>原题链接:<br><a href="https://leetcode.cn/problems/binary-tree-maximum-path-sum/description/?envType=study-plan-v2&amp;envId=top-interview-150">https://leetcode.cn/problems/binary-tree-maximum-path-sum/description/?envType=study-plan-v2&amp;envId=top-interview-150</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="comment">// 左(最大) + 右(最大) + 当前节点 为整条路径 当前也可以选择中间路径</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxPathSum</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> dfs(root.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> dfs(root.right);</span><br><span class="line">        <span class="type">int</span> <span class="variable">lr</span> <span class="operator">=</span> root.val + Math.max(<span class="number">0</span>,left) + Math.max(<span class="number">0</span>,right);</span><br><span class="line">        <span class="comment">// 根到该节点的最大值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">plr</span> <span class="operator">=</span>  root.val + Math.max(<span class="number">0</span>,Math.max(left,right));</span><br><span class="line">        ans = Math.max(ans,Math.max(plr,lr));</span><br><span class="line">        <span class="keyword">return</span> plr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2><span id="二叉搜索树迭代器">二叉搜索树迭代器</span></h2><p>原题链接:<br><a href="https://leetcode.cn/problems/binary-search-tree-iterator/?envType=study-plan-v2&amp;envId=top-interview-150">https://leetcode.cn/problems/binary-search-tree-iterator/?envType=study-plan-v2&amp;envId=top-interview-150</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BSTIterator</span> &#123;</span><br><span class="line">    List&lt;TreeNode&gt; stk = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BSTIterator</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">// 找到中序遍历第一个节点的位置</span></span><br><span class="line">        dfsLeft(root);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> stk.remove(stk.size() - <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> node.val; </span><br><span class="line">        node = node.right;</span><br><span class="line"></span><br><span class="line">        dfsLeft(node);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> !stk.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfsLeft</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(root != <span class="literal">null</span>)&#123;</span><br><span class="line">            stk.add(root);</span><br><span class="line">            root = root.left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your BSTIterator object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * BSTIterator obj = new BSTIterator(root);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.next();</span></span><br><span class="line"><span class="comment"> * boolean param_2 = obj.hasNext();</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2><span id="完全二叉树的节点个数">完全二叉树的节点个数</span></h2><p>原题链接:<br><a href="https://leetcode.cn/problems/count-complete-tree-nodes/description/?envType=study-plan-v2&amp;envId=top-interview-150">https://leetcode.cn/problems/count-complete-tree-nodes/description/?envType=study-plan-v2&amp;envId=top-interview-150</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 找最后一层右子树 少了几个节点即可 </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countNodes</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> countLevel(root.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> countLevel(root.right);</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(left == right)&#123;</span><br><span class="line">            <span class="comment">// 左右子树高度相同-&gt;证明左子树是满二叉树 直接计算得到 结果</span></span><br><span class="line">            <span class="comment">// 然后再递归去判断右子树的情况</span></span><br><span class="line">            <span class="keyword">return</span> countNodes(root.right) + (<span class="number">1</span> &lt;&lt; left);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 左右子树高度不同-&gt; 肯定是左子树 &gt; 右子树  -&gt; 右子树比左子树少一层(完整的一层)  </span></span><br><span class="line">            <span class="comment">//  -&gt;  统计右子树 -&gt; 递归去计算左子树的情况</span></span><br><span class="line">            <span class="keyword">return</span> countNodes(root.left) + (<span class="number">1</span> &lt;&lt; right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">countLevel</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(root != <span class="literal">null</span>)&#123;</span><br><span class="line">            root = root.left;</span><br><span class="line">            h++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="二叉树的最近公共祖先">二叉树的最近公共祖先</span></h2><p>原题链接:<br><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/description/?envType=study-plan-v2&amp;envId=top-interview-150">https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/description/?envType=study-plan-v2&amp;envId=top-interview-150</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="comment">// 当前节点为空 或者已经找到了节点 直接返回</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span> || root == p || root == q)&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> lowestCommonAncestor(root.left,p,q);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> lowestCommonAncestor(root.right,p,q);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 左右子树都不存在 </span></span><br><span class="line">        <span class="keyword">if</span>(left == <span class="literal">null</span> &amp;&amp; right == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 只能在右子树中 同侧的情况</span></span><br><span class="line">        <span class="keyword">if</span>(left == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> right;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(right == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1><span id="回溯">回溯</span></h1><h2><span id="电话号码的字母组合">电话号码的字母组合</span></h2><p>原题链接:<br><a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/description/?envType=study-plan-v2&amp;envId=top-interview-150">https://leetcode.cn/problems/letter-combinations-of-a-phone-number/description/?envType=study-plan-v2&amp;envId=top-interview-150</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">char</span> [][] h = <span class="keyword">new</span> <span class="title class_">char</span>[][] &#123;</span><br><span class="line">            &#123;&#125;,&#123;&#125;,</span><br><span class="line">            <span class="string">&quot;abc&quot;</span>.toCharArray(),</span><br><span class="line">            <span class="string">&quot;def&quot;</span>.toCharArray(),</span><br><span class="line">            <span class="string">&quot;ghi&quot;</span>.toCharArray(),</span><br><span class="line">            <span class="string">&quot;jkl&quot;</span>.toCharArray(),</span><br><span class="line">            <span class="string">&quot;mno&quot;</span>.toCharArray(),</span><br><span class="line">            <span class="string">&quot;pqrs&quot;</span>.toCharArray(),</span><br><span class="line">            <span class="string">&quot;tuv&quot;</span>.toCharArray(),</span><br><span class="line">            <span class="string">&quot;wxyz&quot;</span>.toCharArray()</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> [] dc;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    List&lt;String&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">letterCombinations</span><span class="params">(String digits)</span> &#123;</span><br><span class="line">        dc = digits.toCharArray();</span><br><span class="line">        n = dc.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dfs(<span class="number">0</span>,<span class="keyword">new</span> <span class="title class_">StringBuffer</span>());</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i,StringBuffer sb)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i == n)&#123;</span><br><span class="line">            ans.add(sb.toString());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">char</span> [] letter = h[dc[i] - <span class="string">&#x27;0&#x27;</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; letter.length; k++)&#123;</span><br><span class="line">            sb.append(letter[k]);</span><br><span class="line">            dfs(i + <span class="number">1</span>,sb);</span><br><span class="line">            sb.deleteCharAt(sb.length() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="组合">组合</span></h2><p>原题链接:<br><a href="https://leetcode.cn/problems/combinations/description/?envType=study-plan-v2&amp;envId=top-interview-150">https://leetcode.cn/problems/combinations/description/?envType=study-plan-v2&amp;envId=top-interview-150</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> n,k;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combine</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.n = n;</span><br><span class="line">        <span class="built_in">this</span>.k = k;</span><br><span class="line">        dfs(<span class="number">1</span>,<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;());</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> cur,List&lt;Integer&gt; arr)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr.size() == k)&#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(arr));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> cur ; i &lt;= n ; i++)&#123;</span><br><span class="line">            arr.add(i); </span><br><span class="line">            dfs(i + <span class="number">1</span>,arr);</span><br><span class="line">            arr.remove(arr.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="全排列">全排列</span></h2><p>原题链接:<br><a href="https://leetcode.cn/problems/permutations/?envType=study-plan-v2&amp;envId=top-interview-150">https://leetcode.cn/problems/permutations/?envType=study-plan-v2&amp;envId=top-interview-150</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> [] q;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permute</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        q = nums;</span><br><span class="line">        n = q.length;</span><br><span class="line"></span><br><span class="line">        dfs(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;());</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(List&lt;Integer&gt; arr)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr.size() == n)&#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(arr));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; n ; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr.contains(q[i]))&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            arr.add(q[i]);</span><br><span class="line">            dfs(arr);</span><br><span class="line">            arr.remove(arr.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2><span id="组合总和">组合总和</span></h2><p>原题链接:<br><a href="https://leetcode.cn/problems/combination-sum/description/?envType=study-plan-v2&amp;envId=top-interview-150">https://leetcode.cn/problems/combination-sum/description/?envType=study-plan-v2&amp;envId=top-interview-150</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> [] cand;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        cand = candidates;</span><br><span class="line">        dfs(<span class="number">0</span>,target,<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> cur,<span class="type">int</span> tar,List&lt;Integer&gt; arr)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(tar == <span class="number">0</span>)&#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;(arr));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> cur ; i &lt; cand.length ; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(tar - cand[i] &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            arr.add(cand[i]);</span><br><span class="line">            tar -= cand[i];</span><br><span class="line">            dfs(i,tar,arr);</span><br><span class="line">            tar += cand[i];</span><br><span class="line">            arr.remove(arr.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试真题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>字节面经汇总</title>
      <link href="/2023/11/30/%E9%9D%A2%E8%AF%95%E7%9C%9F%E9%A2%98/2%E5%AD%97%E8%8A%82%E9%9D%A2%E7%BB%8F%E6%B1%87%E6%80%BB/"/>
      <url>/2023/11/30/%E9%9D%A2%E8%AF%95%E7%9C%9F%E9%A2%98/2%E5%AD%97%E8%8A%82%E9%9D%A2%E7%BB%8F%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc --><ul><li><a href="#%E5%AE%9E%E4%B9%A0">实习</a><ul><li><a href="#%E6%97%A5%E5%B8%B8%E5%AE%9E%E4%B9%A0-%E7%94%9F%E6%B4%BB%E6%9C%8D%E5%8A%A1%E9%83%A8%E9%97%A8">日常实习 — 生活服务部门</a><ul><li><a href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F">操作系统</a><ul><li><a href="#%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B">线程和进程</a></li><li><a href="#%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E4%B8%8E%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1">进程间通信与线程间通信</a></li><li><a href="#%E8%AF%BB%E5%86%99%E9%94%81%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0">读写锁怎么实现</a></li><li><a href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98">虚拟内存</a></li><li><a href="#%E5%A0%86%E5%92%8C%E6%A0%88%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%BA%E4%BB%80%E4%B9%88%E6%97%A2%E8%A6%81%E6%9C%89%E5%A0%86%E5%8F%88%E8%A6%81%E6%9C%89%E6%A0%88">堆和栈的区别，为什么既要有堆又要有栈</a></li></ul></li><li><a href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C">计算机网络</a><ul><li><a href="#osi%E4%B8%83%E5%B1%82%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E6%AF%8F%E4%B8%80%E5%B1%82%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8D%8F%E8%AE%AE">OSI七层网络模型，每一层有哪些协议</a></li><li><a href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87%E6%9C%89%E5%93%AA%E4%BA%9B%E5%88%86%E5%88%AB%E5%B1%9E%E4%BA%8E%E5%93%AA%E4%B8%80%E5%B1%82">常见的网络设备有哪些？分别属于哪一层</a></li><li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%B1%80%E5%9F%9F%E7%BD%91-ip-%E9%80%9A%E5%B8%B8%E4%BB%A5-192168-%E5%BC%80%E5%A4%B4">为什么局域网 IP 通常以 192.168 开头</a></li><li><a href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5%E7%BD%91%E5%9D%80%E7%9A%84%E8%BF%87%E7%A8%8B">浏览器输入网址的过程</a></li><li><a href="#tcp%E5%92%8Cudptcp%E6%98%AF%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E5%8F%AF%E9%9D%A0%E6%80%A7%E7%9A%84">TCP和UDP，TCP是怎么保证可靠性的？</a></li><li><a href="#tcp-3%E6%AC%A1%E6%8F%A1%E6%89%8B-4%E6%AC%A1%E6%8C%A5%E6%89%8B">TCP 3次握手 4次挥手</a></li></ul></li><li><a href="#mysql">MySQL</a><ul><li><a href="#%E4%BA%8B%E5%8A%A1%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84">事务是怎么实现的</a></li><li><a href="#%E7%B4%A2%E5%BC%95%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84">索引是怎么实现的</a></li><li><a href="#%E4%BB%8B%E7%BB%8Db%E6%A0%911000w%E6%95%B0%E6%8D%AE%E9%9C%80%E8%A6%81%E5%87%A0%E5%B1%82b%E6%A0%91">介绍B+树，1000w数据需要几层B+树</a></li></ul></li></ul></li></ul></li></ul><!-- tocstop --><h1><span id="实习">实习</span></h1><h2><span id="日常实习-生活服务部门">日常实习 — 生活服务部门</span></h2><p>原链接:<br><a href="https://www.nowcoder.com/discuss/556123658565992448?sourceSSR=dynamic">https://www.nowcoder.com/discuss/556123658565992448?sourceSSR=dynamic</a></p><h3><span id="操作系统">操作系统</span></h3><h4><span id="线程和进程">线程和进程</span></h4><p>进程: 是系统运行程序的基本单元 进程是动态的 进程包含了线程<br>线程: 线程是比进程更小的执行单元 线程共享进程的堆和方法区的资源 但每个线程有自己程序计数器 虚拟机栈和本地方法栈<br>线程是进程的划分成更小的运行单元 线程和进程最⼤的不同在于基本上各进程是<strong>独⽴</strong>的，⽽各线程则不⼀定，因为同⼀进程中的线程极有可能会相互影响。线程执⾏开销⼩，但不利于资源的管<br>理和保护；⽽进程正相反</p><h4><span id="进程间通信与线程间通信">进程间通信与线程间通信</span></h4><p>进程间通信(IPC)是在不同的进程之间进行数据交换，而线程间通信(ITC)是在同一个进程的不同线程之间进行数据交换。<br>由于线程共享同一进程的内存空间，因此在线程间通信时，可以<strong>直接访问共享的内存</strong>，而不需要使用像管道、消息队列或套接字这些IPC机制。</p><ol><li>进程间通信 IPC:<br>管道 (Pipe)：管道是一种半双工的通信机制，用于在具有亲缘关系的进程之间传递数据。它可以是匿名管道 (Anonymous Pipe) 或命名管道 (Named Pipe)。<br>共享内存 (Shared Memory)：共享内存是一种将内存区域映射到多个进程的机制，使它们可以直接访问共享的内存块，从而实现进程间的数据共享。<br>消息队列 (Message Queue)：消息队列是一种在进程之间传递消息的通信机制，它允许一个进程向队列中发送消息，另一个进程从队列中接收消息。<br>信号量 (Semaphore)：信号量是一种用于进程间同步和互斥的机制，它可以用来保护共享资源，避免资源的竞争和冲突。<br>套接字 (Socket)：套接字是一种用于在网络上进行进程间通信的机制，它可以在不同计算机之间传递数据。</li><li>线程间通信 (ITC)：<br>共享内存 (Shared Memory)：与进程间通信相同，线程也可以通过共享内存来实现数据的共享和交换。<br>互斥锁 (Mutex)：互斥锁是一种用于线程间同步的机制，它可以保护<strong>共享资源</strong>，确保同一时间只有一个线程可以访问该资源。<br>条件变量 (Condition Variable)：条件变量是一种用于线程间等待和通知的机制，它可以使一个线程等待某个特定条件满足后再继续执行。<br>信号量 (Semaphore)：与进程间通信相同，线程也可以使用信号量来实现线程间的同步和互斥。</li></ol><h4><span id="读写锁怎么实现">读写锁怎么实现</span></h4><p>读写锁本质上是一种自旋锁 是给一段临界区代码加锁<br>读写锁（Read-Write Lock）是一种<strong>并发控制</strong>机制，用于在多线程环境下保护共享资源的访问。读写锁允许多个线程同时读取共享资源，但只允许一个线程进行写操作。</p><p>读写锁的实现通常包括以下几个关键组件：</p><ol><li>读计数器（Read Count）：记录当前有多少个线程正在读取共享资源。</li><li>写计数器（Write Count）：记录当前有多少个线程正在进行写操作。</li><li>互斥锁（Mutex Lock）：用于<strong>保护读写锁</strong>本身的访问，即读写锁的获取和释放。</li></ol><p>读操作的实现流程如下：</p><ol><li>当一个线程请求读取共享资源时，首先需要获取读写锁的互斥锁。</li><li>在获取互斥锁后，读计数器会自增，表示有一个线程正在读取共享资源。</li><li>如果有其他线程正在进行写操作（写计数器大于0）或者有写操作请求正在等待，则当前线程需要等待。</li><li>如果没有写操作正在进行，当前线程可以直接访问共享资源。</li><li>当一个线程完成读取操作后，读计数器自减。</li></ol><p>写操作的实现流程如下：</p><ol><li>当一个线程请求写操作时，首先需要获取读写锁的互斥锁。</li><li>在获取互斥锁后，如果读计数器不为0或者写计数器不为0，则当前线程需要等待。</li><li>如果没有其他线程正在读取或写入，当前线程可以执行写操作。</li><li>写操作完成后，写计数器归零，并释放互斥锁。</li></ol><h4><span id="虚拟内存">虚拟内存</span></h4><p>在操作系统中，虚拟内存是一种技术，它将计算机的物理内存（RAM）扩展到硬盘上的<strong>虚拟地址空间</strong>。虚拟内存允许每个进程在其自己的地址空间中执行，而不需要实际占用全部物理内存。<br>硬件提供了地址转换机制，将虚拟地址转换为物理地址。操作系统负责管理虚拟内存的分配、回收、页面置换等。</p><p>虚拟内存的主要目的是提供更大的可用内存空间，以满足多进程同时运行的需求。它还提供了以下几个重要的功能：</p><ol><li>内存管理：虚拟内存将物理内存划分为固定大小的页面（通常为4KB或者8KB），并将进程的虚拟地址空间划分为相应的页面。这样，操作系统可以将页面<strong>映射</strong>到物理内存中的任意位置，而不需要连续的物理内存空间。</li><li>内存保护：通过使用虚拟内存，操作系统可以为每个进程分配<strong>独立的地址空间</strong>，并对其进行保护。每个进程只能访问自己的地址空间，无法直接访问其他进程的地址空间。这提供了更好的安全性和隔离性。</li><li>内存共享：虚拟内存使得多个进程可以共享同一段内存，从而实现数据共享和进程间通信。多个进程可以将同一文件映射到各自的虚拟地址空间中，从而实现共享数据的访问。</li><li>虚拟内存交换：当物理内存不足时，操作系统可以将暂时<strong>不活跃</strong>的页面从物理内存交换到硬盘上的交换空间中。这样，空出的物理内存可以用于加载更需要的页面。这个过程称为<strong>页面置换</strong>。</li></ol><h4><span id="堆和栈的区别为什么既要有堆又要有栈">堆和栈的区别，为什么既要有堆又要有栈</span></h4><p>堆（Heap）和栈（Stack）是计算机内存中的两个主要区域，用于存储程序运行时所需的数据和指令。它们在分配和管理内存方面具有不同的特点和用途。<br>存储方式：</p><ol><li>堆：堆是<strong>动态</strong>分配内存的一种方式，存储的是对象和数据结构，通过new关键字在堆上创建对象。堆的大小由程序<strong>运行时</strong>动态决定。</li><li>栈：栈是一种<strong>静态分配</strong>内存的方式，存储的是方法调用和局部变量。<strong>栈的大小在编译时</strong>就确定，由系统自动分配和管理(正是因为由系统分配和管理 所以需要在编译时就确定栈的大小以便进行静态内存分配)。</li></ol><p>内存分配和回收：</p><ol><li>堆：堆上的内存分配和回收由程序员手动管理。对象在堆上分配，需要<strong>手动释放内存</strong>，否则会造成内存泄漏。Java中，<strong>垃圾回收器负责自动回收不再使用的对象</strong>。</li><li>栈：栈的内存分配和回收是<strong>自动</strong>的，由系统在方法调用和返回时进行管理。局部变量的内存在方法执行期间分配，方法<strong>返回后自动释放</strong>。</li></ol><p>存储方式和速度：</p><ol><li>堆：堆的存储方式是链式存储结构，通过指针进行访问。由于堆的大小不固定，内存分配和回收的效率相对较低。</li><li>栈：栈的存储方式是顺序存储结构，通过栈指针进行访问。由于栈的大小固定且分配和回收自动完成，访问速度较快。</li></ol><p>数据生命周期：</p><ol><li>堆：堆上的数据生命周期可以比较长，直到程序显式释放或垃圾回收器回收对象。</li><li>栈：栈上的数据生命周期较短，随着方法的调用和返回而变化，局部变量的生命周期在方法执行期间。</li></ol><p>为什么既要有堆又要有栈？<br>堆和栈的存在都有其特定的用途和优势：</p><ol><li>堆：堆的动态分配特性使得它适用于存储大量的、生命周期较长的数据，如对象和数据结构。堆的灵活性使得程序可以动态地分配和释放内存，从而<strong>满足复杂的内存需求</strong>。</li><li>栈：栈的静态分配特性使得它适用于存储方法的调用和局部变量等具有较短生命周期的数据。栈的自动分配和释放机制使得程序员无需关心内存管理的细节，提高了编程的<strong>简洁性和效率</strong>。<br>通过堆和栈的组合使用，程序可以在运行时动态管理内存，同时保证了方法调用和局部变量的高效访问。这种灵活性和效率的结合使得程序能够更好地<strong>平衡内存的使用和性能的需求</strong>。</li></ol><h3><span id="计算机网络">计算机网络</span></h3><h4><span id="osi七层网络模型每一层有哪些协议">OSI七层网络模型，每一层有哪些协议</span></h4><p>OSI七层网络模型是一种将计算机网络功能划分为不同层次的标准模型。每一层都有特定的功能和对应的协议。以下是每一层及其对应的协议：</p><ol><li><p>物理层（Physical Layer）<br>负责传输<strong>比特流</strong>，提供物理介质传输的基本功能。<br>协议：Ethernet、RS-232、Fiber Channel等。<br>(Ethernet:Ethernet协议是一种用于局域网（LAN）的通信协议，它定义了在局域网中计算机之间的通信规则和数据传输方式。Ethernet协议基于CSMA&#x2F;CD（Carrier Sense Multiple Access with Collision Detection）技术，即带有冲突检测的载波监听多路访问。它允许多台计算机共享同一物理传输介质（如双绞线或光纤）并进行数据传输)</p></li><li><p>数据链路层（Data Link Layer）<br>负责将比特流组织成<strong>帧</strong>，并提供可靠的点对点数据传输。<br>协议：Ethernet、PPP（Point-to-Point Protocol）、HDLC（High-Level Data Link Control）等。</p></li><li><p>网络层（Network Layer）<br>负责<strong>寻址和路由选择</strong>，将<strong>数据包</strong>从源节点传送到目标节点。<br>协议：IP（Internet Protocol）、ICMP（Internet Control Message Protocol）、ARP（Address Resolution Protocol）等。</p></li><li><p>传输层（Transport Layer）<br>负责端到端的<strong>可靠数据传输和流量控制</strong>。<br>协议：TCP（Transmission Control Protocol）、UDP（User Datagram Protocol）、SCTP（Stream Control Transmission Protocol）等。</p></li><li><p>会话层（Session Layer）<br>负责建立、管理和终止会话，提供会话层服务。<br>协议：SSH（Secure Shell）、RPC（Remote Procedure Call）等。</p></li><li><p>表示层（Presentation Layer）<br>负责数据的格式转换、加密和压缩，提供数据表示和交换的格式。<br>协议：TLS（Transport Layer Security）、ASCII（American Standard Code for Information Interchange）等。</p></li></ol><p>(会话层和表示层 目前用的很少了 这两个功能其实都已经被其他层所覆盖)</p><ol start="7"><li>应用层（Application Layer）<br>负责<strong>应用程序</strong>之间的通信和交互，提供特定的应用服务。<br>协议：HTTP（Hypertext Transfer Protocol）、FTP（File Transfer Protocol）、SMTP（Simple Mail Transfer Protocol）等。</li></ol><h4><span id="常见的网络设备有哪些分别属于哪一层">常见的网络设备有哪些？分别属于哪一层</span></h4><p>常见的网络设备包括路由器、交换机、防火墙、网关和无线访问点等。</p><ol><li>路由器（Router）是一种网络设备，位于网络的边缘，用于连接不同的网络并转发数据包。它根据目标IP地址来决定如何将数据包从一个网络传输到另一个网络，实现网络之间的互联和数据转发。路由器工作在网络层（第3层）。</li><li>交换机（Switch）是一种用于局域网内部的网络设备，用于在局域网内部不同设备之间进行数据的转发。交换机根据目标MAC地址来决定将数据包转发到哪个端口，实现局域网内部的数据交换和通信。交换机工作在数据链路层（第2层）。</li><li>防火墙（Firewall）是一种用于保护网络安全的设备，它通过对网络流量进行检查和过滤，控制进出网络的数据包。防火墙可以根据预先设定的安全策略来允许或阻止特定类型的网络流量，从而保护网络免受潜在的威胁。防火墙可以工作在网络层和传输层（第3层和第4层）。</li><li>网关（Gateway）是网络中连接两个不同网络的设备，可以是硬件设备或软件实现。网关可以将不同的网络协议进行转换，允许不同类型的网络之间进行通信和数据交换。网关通常工作在网络层（第3层）。</li><li>无线访问点（Wireless Access Point）是一种设备，用于提供无线网络连接。它允许无线设备（如笔记本电脑、智能手机）通过Wi-Fi连接到有线网络，并在局域网内部提供无线网络访问。无线访问点通常具有路由器和交换机的功能，可以工作在网络层和数据链路层（第2层和第3层）</li></ol><h4><span id="为什么局域网-ip-通常以-192168-开头">为什么局域网 IP 通常以 192.168 开头</span></h4><p>局域网IP通常以192.168开头是因为这个IP地址段被IANA（Internet Assigned Numbers Authority）指定为专门用于私有网络内部的地址范围。<br>私有IP地址是指在互联网上不可路由的IP地址，只在局域网内部使用。它们允许多个局域网在互联网上使用相同的IP地址范围，而不会产生冲突。<br>192.168.0.0至192.168.255.255是一个<strong>保留的私有IP地址</strong>范围，其中包含了65,536个可用的IP地址。这个地址段被广泛接受并用于许多家庭网络和小型企业的局域网。</p><h4><span id="浏览器输入网址的过程">浏览器输入网址的过程</span></h4><p>当用户在浏览器中输入网址并按下回车键时，浏览器会执行以下步骤来获取并显示网页：</p><ol><li>解析网址：浏览器会解析用户输入的网址，提取出<strong>协议（如HTTP、HTTPS）、域名和路径</strong>等信息。例如，从网址”<a href="https://www.example.com/index.html&quot;%E4%B8%AD%EF%BC%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BC%9A%E8%A7%A3%E6%9E%90%E5%87%BA%E5%8D%8F%E8%AE%AE%E4%B8%BAHTTPS%EF%BC%8C%E5%9F%9F%E5%90%8D%E4%B8%BAwww.example.com%EF%BC%8C%E8%B7%AF%E5%BE%84%E4%B8%BA/index.html%E3%80%82">https://www.example.com/index.html&quot;中，浏览器会解析出协议为HTTPS，域名为www.example.com，路径为/index.html。</a></li><li>DNS解析：浏览器将域名发送给DNS（Domain Name System）服务器，以获取对应的IP地址。DNS服务器负责将<strong>域名转换为IP地址</strong>，使浏览器能够与服务器进行通信。</li><li>建立TCP连接：浏览器使用HTTP或HTTPS协议与服务器建立<strong>TCP连接</strong>。TCP协议确保数据可靠传输，建立连接则需要进行三次握手。</li><li>发送HTTP请求：浏览器向服务器发送HTTP请求，请求包括HTTP方法（GET、POST等）、路径、头部信息（如User-Agent、Accept等）和其他相关参数。</li><li>服务器处理请求：服务器收到请求后，会根据请求的路径和参数执行相应的处理逻辑。这可能涉及数据库查询、文件读取、业务处理等操作。</li><li>服务器发送HTTP响应：服务器根据请求的处理结果生成HTTP响应，包括状态码、头部信息和响应体。状态码表示请求的处理结果，<strong>如200表示成功，404表示找不到资源等</strong>。</li><li>接收响应：浏览器接收到HTTP响应后，会对响应进行<strong>解析</strong>。如果响应是HTML页面，浏览器会解析HTML结构，并请求加载HTML中引用的其他资源，如CSS、JavaScript文件和图片等。</li><li>渲染页面：浏览器使用解析到的HTML、CSS和JavaScript等资源，将网页内容渲染到浏览器窗口中，显示给用户。</li><li>关闭连接：一旦页面加载完成，浏览器会关闭与服务器的TCP连接，释放资源。<br>以上是浏览器输入网址的基本过程，不同浏览器可能会有细微的差异，但整体流程大致相同。这个过程使得用户能够通过浏览器访问并浏览互联网上的各种网页。</li></ol><h4><span id="tcp和udptcp是怎么保证可靠性的">TCP和UDP，TCP是怎么保证可靠性的？</span></h4><p>TCP（Transmission Control Protocol）和UDP（User Datagram Protocol）是两种常见的传输层协议，用于在计算机网络中传输数据。<br>TCP是一种<strong>面向连接</strong>的协议，它提供可靠的、有序的数据传输。TCP使用三次握手建立连接，通过序列号和确认机制来保证数据的可靠传输。它还具有流量控制和拥塞控制机制，以避免网络拥塞和数据丢失。TCP适用于对数据完整性要求较高的应用，如文件传输、电子邮件和网页浏览。<br>UDP是一种<strong>无连接</strong>的协议，它提供不可靠的、无序的数据传输。UDP不需要建立连接，直接将数据报发送到目标地址。它没有序列号和确认机制，也没有流量控制和拥塞控制。UDP适用于对实时性要求较高的应用，如音频和视频传输、实时游戏等，因为它的低延迟和较小的开销。<br>相比之下，TCP提供了可靠性和有序性，但会带来更大的开销和延迟，适用于对数据完整性要求较高的场景。而UDP则更为轻量和快速，但在传输过程中可能会丢失、重复或乱序数据，适用于对实时性要求较高的场景</p><p>TCP是怎么保证可靠性的<br>TCP（Transmission Control Protocol）是一种面向连接的协议，它通过一系列的机制来保证数据的可靠传输。</p><ol><li>应用数据的分割和序列化：TCP将应用层传递给它的数据进行分割，并为每个数据段分配一个<strong>序列号</strong>。这样可以确保数据能够按照正确的顺序传输，并且可以在接收端重新组装成完整的数据。</li><li>确认和重传：TCP使用确认机制来确保数据的可靠传输。接收端会向发送端发送确认消息，告知发送端已成功接收到数据。如果发送端在一定时间内没有收到确认消息，它会假定数据丢失，并重新发送该数据段。</li><li>滑动窗口：TCP使用滑动窗口机制来控制发送和接收数据的速率。发送端和接收端都有一个窗口大小的限制，发送端根据接收端的窗口大小来控制发送数据的数量，接收端根据自己的处理能力来控制接收数据的速率。</li><li>流量控制：TCP使用流量控制机制来控制<strong>发送端发送数据的速率</strong>，以避免接收端被过多的数据淹没。接收端可以通过发送窗口大小来告知发送端自己的处理能力，发送端会根据接收端的窗口大小来控制发送数据的数量。</li><li>拥塞控制：TCP使用拥塞控制机制来避免网络拥塞的发生。发送端和接收端都会根据网络的拥塞程度来调整自己的发送速率，以避免过多的数据造成网络拥塞。</li></ol><h4><span id="tcp-3次握手-4次挥手">TCP 3次握手 4次挥手</span></h4><p>3次握手:<br><a href="https://xiaolincoding.com/network/3_tcp/tcp_interview.html#tcp-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84">https://xiaolincoding.com/network/3_tcp/tcp_interview.html#tcp-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84</a></p><p>4次挥手:<br><a href="https://xiaolincoding.com/network/3_tcp/tcp_interview.html#tcp-%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E8%BF%87%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84">https://xiaolincoding.com/network/3_tcp/tcp_interview.html#tcp-%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E8%BF%87%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84</a></p><p>为什么TCP 第3次握手可以携带数据 但前2次不行？<br>TCP的第三次握手可以携带数据，而前两次握手不能携带数据的原因是因为TCP的连接是双向的。在第一次和第二次握手时，客户端和服务器只是交换了一些必要的连接建立信息，如序列号和标志位等，以确保彼此的通信能力。<br>在第三次握手时，客户端发送的ACK包实际上是对服务器的确认，表示客户端已收到服务器的SYN-ACK包，并且能够接收数据。此时，连接已经建立，双方都确认了彼此的通信能力。<br>因为连接已经建立，所以第三次握手可以携带数据。这是因为在第三次握手之后，双方已经同意了连接的建立，并且已经进行了一定的初始化工作，可以开始传输数据。因此，TCP的第三次握手可以携带数据，以便在连接建立后立即传输一些必要的信息或应用数据。<br>而前两次握手不能携带数据的原因是因为在建立连接之前，双方还没有彼此确认对方的通信能力和可靠性。在第一次和第二次握手时，只是进行了一些最基本的握手操作，用于初始化连接的参数和状态，还没有进行数据传输的准备。<br>总之，TCP的第三次握手可以携带数据，是因为在这一步之前，连接已经建立并确认了各自的通信能力。而前两次握手不能携带数据，是因为在这些步骤中，双方还没有达到可以进行数据传输的状态。</p><h3><span id="mysql">MySQL</span></h3><h4><span id="事务是怎么实现的">事务是怎么实现的</span></h4><p>事务是由 MySQL 的引擎来实现的 主要依靠日志和锁，我们常见的 InnoDB 引擎它是支持事务的。<br>事务具有4个特性ACID 主要是依靠日志和锁进行实现<br>持久性是通过 redo log （重做日志）来保证的(redo log 记录某个数据页做了什么修改)；<br>原子性是通过 undo log（回滚日志） 来保证的；(undo log每次记录更新前的数据 一旦发生故障崩溃使用undo log 回滚事务)<br>隔离性是通过 MVCC（多版本并发控制） 或锁机制来保证的；<br>一致性则是通过持久性+原子性+隔离性来保证；</p><p>redo log 与 undo log的区别:<br>这两种日志是属于 InnoDB 存储引擎的日志，它们的区别在于：</p><ol><li>redo log 记录了此次事务「完成后」的数据状态，记录的是更新之后的值；</li><li>undo log 记录了此次事务「开始前」的数据状态，记录的是更新之前的值；</li></ol><h4><span id="索引是怎么实现的">索引是怎么实现的</span></h4><p>通过B+树实现</p><h4><span id="介绍b树1000w数据需要几层b树">介绍B+树，1000w数据需要几层B+树</span></h4><p>由分支因子b决定 (分支因子即 一个B树节点可以含有的孩子个数)<br>每个节点可以容纳的键值对为m </p><p>记数据数量为 d<br>叶子节点数量 &#x3D; d &#x2F; m<br>高度 &#x3D; logb(d&#x2F;m) &#x3D; logb(1000w&#x2F;m)</p>]]></content>
      
      
      <categories>
          
          <category> 面试真题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字节跳动 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>滴滴代码题</title>
      <link href="/2023/11/28/%E9%9D%A2%E8%AF%95%E7%9C%9F%E9%A2%98/2%E6%BB%B4%E6%BB%B4%E4%BB%A3%E7%A0%81%E9%A2%98/"/>
      <url>/2023/11/28/%E9%9D%A2%E8%AF%95%E7%9C%9F%E9%A2%98/2%E6%BB%B4%E6%BB%B4%E4%BB%A3%E7%A0%81%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc --><ul><li><a href="#dfs">DFS</a><ul><li><a href="#leetcode-46-%E5%85%A8%E6%8E%92%E5%88%97">leetcode 46 全排列</a></li></ul></li><li><a href="#%E6%8E%92%E5%BA%8F">排序</a><ul><li><a href="#leetcode-283-%E7%A7%BB%E5%8A%A8%E9%9B%B6%E7%82%B9">leetcode 283 移动零点</a></li></ul></li></ul><!-- tocstop --><h1><span id="dfs">DFS</span></h1><h2><span id="leetcode-46-全排列">leetcode 46 全排列</span></h2><p>原题链接:<br><a href="https://leetcode.cn/problems/permutations/description/">https://leetcode.cn/problems/permutations/description/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> [] q;</span><br><span class="line">    <span class="type">int</span> n; </span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permute</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        q = nums;</span><br><span class="line">        n = q.length;</span><br><span class="line">        dfs(<span class="number">0</span>,<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> u,List&lt;Integer&gt; list)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == list.size())&#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;(list));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; n ; i++)&#123;</span><br><span class="line">            <span class="comment">// 相当于使用了一个used数组</span></span><br><span class="line">            <span class="keyword">if</span>(list.contains(q[i]))&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            list.add(q[i]);</span><br><span class="line">            dfs(i + <span class="number">1</span>,list);</span><br><span class="line">            list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1><span id="排序">排序</span></h1><h2><span id="leetcode-283-移动零点">leetcode 283 移动零点</span></h2><p>原题链接:<br><a href="https://leetcode.cn/problems/move-zeroes/description/">https://leetcode.cn/problems/move-zeroes/description/</a></p><p>最优解是快排思想 当然两次遍历交换也可以做</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">moveZeroes</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 快排思想</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; nums.length ; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">                nums[i] = nums[j];</span><br><span class="line">                nums[j++] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试真题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>字节代码题</title>
      <link href="/2023/11/28/%E9%9D%A2%E8%AF%95%E7%9C%9F%E9%A2%98/2%E5%AD%97%E8%8A%82%E4%BB%A3%E7%A0%81%E9%A2%98/"/>
      <url>/2023/11/28/%E9%9D%A2%E8%AF%95%E7%9C%9F%E9%A2%98/2%E5%AD%97%E8%8A%82%E4%BB%A3%E7%A0%81%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc --><ul><li><a href="#%E9%93%BE%E8%A1%A8">链表</a><ul><li><a href="#%E8%BF%94%E5%9B%9E%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9">返回链表的倒数第k个节点</a></li></ul></li><li><a href="#%E4%BA%8C%E5%88%86">二分</a></li><li><a href="#%E6%A0%91">树</a><ul><li><a href="#%E5%89%91%E6%8C%87offer26-%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84">剑指offer26 树的子结构</a></li><li><a href="#leetcode112-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C">leetcode112 路径总和</a></li></ul></li><li><a href="#%E6%8E%92%E5%BA%8F">排序</a><ul><li><a href="#%E8%87%AA%E5%91%BD%E9%A2%98-%E6%95%B0%E7%BB%84%E6%89%BE%E4%B8%AD%E4%BD%8D%E6%95%B0-%E8%A6%81%E8%87%AA%E5%B7%B1%E5%AE%9E%E7%8E%B0%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E5%85%B6%E5%AE%9E%E5%B0%B1%E6%98%AF%E5%BF%AB%E6%8E%92">自命题 数组找中位数 (要自己实现排序算法 其实就是快排)</a></li></ul></li><li><a href="#dp">DP</a><ul><li><a href="#leetcode518-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2ii">leetcode518 零钱兑换II</a></li><li><a href="#leetcode518-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2i">leetcode518 零钱兑换I</a></li></ul></li><li><a href="#dfs">DFS</a><ul><li><a href="#leetcode39-%E7%BB%84%E5%90%88%E5%9B%9E%E6%BA%AF">leetcode39 组合回溯</a></li></ul></li><li><a href="#%E5%AD%97%E5%85%B8%E6%A0%91">字典树</a><ul><li><a href="#leetcode1268-%E6%90%9C%E7%B4%A2%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F">leetcode1268 搜索推荐系统</a></li></ul></li><li><a href="#sql">SQL</a><ul><li><a href="#sql156-%E5%90%84%E4%B8%AA%E8%A7%86%E9%A2%91%E7%9A%84%E5%B9%B3%E5%9D%87%E5%AE%8C%E6%92%AD%E7%8E%87">SQL156 各个视频的平均完播率</a></li></ul></li></ul><!-- tocstop --><h1><span id="链表">链表</span></h1><h2><span id="返回链表的倒数第k个节点">返回链表的倒数第k个节点</span></h2><p>题目要求是ACM模式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> (<span class="type">int</span>) (<span class="number">1e5</span> + <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">dummy</span> <span class="operator">=</span> -<span class="number">1</span> , idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> [] e  = <span class="keyword">new</span> <span class="title class_">int</span>[N];</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> [] ne = <span class="keyword">new</span> <span class="title class_">int</span>[N];</span><br><span class="line">    <span class="type">static</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> v)</span>&#123;</span><br><span class="line">        e[idx] = v;</span><br><span class="line">        ne[idx] = ne[k];</span><br><span class="line">        ne[k] = idx++;</span><br><span class="line">        cur++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(<span class="type">int</span> k)</span>&#123;</span><br><span class="line">        ne[k] = ne[ne[k]];</span><br><span class="line">        cur--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;xxx&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> ne[dummy]; i != -<span class="number">1</span> ; i = ne[i])&#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;%d &quot;</span>,e[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化哑节点</span></span><br><span class="line">        e[idx] = <span class="number">0</span>;</span><br><span class="line">        ne[idx] = dummy;</span><br><span class="line">        dummy = idx++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= <span class="number">10</span> ; i++)&#123;</span><br><span class="line">            <span class="comment">// 虽然第一个位置 已经有节点了 但是要插入节点 那么要找到这个节点的钱一个位置</span></span><br><span class="line">            insert(i,i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">        <span class="comment">// 删除第k个 相当于删除 整数 n - k个</span></span><br><span class="line">        remove(cur - k);</span><br><span class="line">        print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>扩展完整单链表模板<br><a href="https://www.acwing.com/problem/content/description/828/">https://www.acwing.com/problem/content/description/828/</a></p><p>写法1: 哑节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> (<span class="type">int</span>) (<span class="number">1e5</span> + <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">dummy</span> <span class="operator">=</span> -<span class="number">1</span>,idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> [] e = <span class="keyword">new</span> <span class="title class_">int</span>[N];</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> [] ne = <span class="keyword">new</span> <span class="title class_">int</span>[N];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> v)</span>&#123;</span><br><span class="line">        e[idx] = v;</span><br><span class="line">        ne[idx] = ne[k];</span><br><span class="line">        ne[k] = idx++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(<span class="type">int</span> k)</span>&#123;</span><br><span class="line">        ne[k] = ne[ne[k]];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> dummy;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> ne[u]; i != -<span class="number">1</span> ; i = ne[i])&#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;%d &quot;</span>,e[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 先初始化哑巴节点</span></span><br><span class="line">        e[idx] = <span class="number">0</span>;</span><br><span class="line">        ne[idx] = dummy;</span><br><span class="line">        dummy = idx++;</span><br><span class="line"></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">        <span class="keyword">while</span>(m &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            m--;</span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> sc.next();</span><br><span class="line">            <span class="type">char</span> <span class="variable">op</span> <span class="operator">=</span> s.charAt(<span class="number">0</span>);</span><br><span class="line">            <span class="comment">// 在头部插入</span></span><br><span class="line">            <span class="keyword">if</span> (op == <span class="string">&#x27;H&#x27;</span>)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">                insert(<span class="number">0</span>,v);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&#x27;D&#x27;</span>)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">                remove(k);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">                <span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">                insert(k,v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写法2：头插法<br>这种头插法也要掌握 因为图论中实际上用的是头插法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> (<span class="type">int</span>) (<span class="number">1e5</span> + <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> [] e = <span class="keyword">new</span> <span class="title class_">int</span>[N];</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> [] ne = <span class="keyword">new</span> <span class="title class_">int</span>[N];</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">head</span> <span class="operator">=</span> -<span class="number">1</span>,idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">add_head</span><span class="params">(<span class="type">int</span> v)</span>&#123;</span><br><span class="line">        e[idx] = v;</span><br><span class="line">        ne[idx] = head;</span><br><span class="line">        head = idx++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> v)</span>&#123;</span><br><span class="line">        e[idx] = v;</span><br><span class="line">        ne[idx] = ne[k];</span><br><span class="line">        ne[k] = idx++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(<span class="type">int</span> k)</span>&#123;</span><br><span class="line">        ne[k] = ne[ne[k]]; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> head ; i != -<span class="number">1</span> ; i = ne[i])&#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;%d &quot;</span>,e[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">        <span class="keyword">while</span> (m &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            m--;</span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> sc.next();</span><br><span class="line">            <span class="type">char</span> <span class="variable">op</span> <span class="operator">=</span> s.charAt(<span class="number">0</span>);</span><br><span class="line">            <span class="comment">// 头插</span></span><br><span class="line">            <span class="keyword">if</span> (op == <span class="string">&#x27;H&#x27;</span>)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">                add_head(v);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&#x27;D&#x27;</span>)&#123;</span><br><span class="line">                <span class="comment">// 删除</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">                <span class="comment">// 删除这个数 则要找到这个数 前面的一个位置</span></span><br><span class="line">                <span class="comment">// 删头节点 还要特判一下 必需用head删 这点倒确实没用dummy node方法</span></span><br><span class="line">                <span class="keyword">if</span>(k == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">// head为指针含义 表示头节点 下一个所指的位置</span></span><br><span class="line">                    head = ne[head];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    remove(k - <span class="number">1</span>);    </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">                <span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">                insert(k - <span class="number">1</span>,v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        print();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1><span id="二分">二分</span></h1><h1><span id="树">树</span></h1><h2><span id="剑指offer26-树的子结构">剑指offer26 树的子结构</span></h2><p>DFS</p><p>原题链接:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// b 是否为 a 的子树 </span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">dfs</span><span class="params">(TreeNode a,TreeNode b)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// b为空树肯定为子树</span></span><br><span class="line">        <span class="keyword">if</span>(b == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// a空 但 b不空  b肯定不是a的子树</span></span><br><span class="line">        <span class="keyword">if</span>(a == <span class="literal">null</span>)&#123;     </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(a.val != b.val)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dfs(a.left,b.left) &amp;&amp; dfs(a.right,b.right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">HasSubtree</span><span class="params">(TreeNode root1,TreeNode root2)</span> &#123;</span><br><span class="line">        <span class="comment">// 题目要求: 我们约定空树不是任意一个树的子结构</span></span><br><span class="line">        <span class="comment">// 这条还蛮坑的</span></span><br><span class="line">        <span class="keyword">if</span>(root1 == <span class="literal">null</span> || root2 == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dfs(root1,root2) || HasSubtree(root1.left,root2) || HasSubtree(root1.right,root2) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2><span id="leetcode112-路径总和">leetcode112 路径总和</span></h2><p>DFS</p><p>原题链接:<br><a href="https://leetcode.cn/problems/path-sum/">https://leetcode.cn/problems/path-sum/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasPathSum</span><span class="params">(TreeNode root, <span class="type">int</span> targetSum)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 叶子节点 再进行判断</span></span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//考虑极端的情况 如果只有一个节点 那么必然是root.val == targetSum 判断答案</span></span><br><span class="line">            <span class="keyword">return</span> root.val == targetSum;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> hasPathSum(root.left,targetSum - root.val) || hasPathSum(root.right,targetSum - root.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1><span id="排序">排序</span></h1><h2><span id="自命题-数组找中位数-要自己实现排序算法-其实就是快排">自命题 数组找中位数 (要自己实现排序算法 其实就是快排)</span></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class <span class="title function_">Main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1><span id="dp">DP</span></h1><h2><span id="leetcode518-零钱兑换ii">leetcode518 零钱兑换II</span></h2><p>抖音支付二面</p><p>完全背包问题</p><p>原题链接<br><a href="https://leetcode.cn/problems/coin-change-ii/">https://leetcode.cn/problems/coin-change-ii/</a></p><p>朴素解法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回的是方案数 而不是 具体的组合 所以不需要DFS 这个数据量也不能用DFS</span></span><br><span class="line"><span class="comment">// 完全背包问题 </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> <span class="number">5010</span>;</span><br><span class="line">    <span class="comment">// 前i个种类的物品种 选任意k件 值等于总金额的方案数</span></span><br><span class="line">    <span class="type">int</span> [][] f = <span class="keyword">new</span> <span class="title class_">int</span> [N][N];</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">change</span><span class="params">(<span class="type">int</span> amount, <span class="type">int</span>[] coins)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> coins.length;</span><br><span class="line">        <span class="comment">// 都不选的方案数 默认为 1</span></span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span> ; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> coins[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span> ;  j &lt;= amount ; j++)&#123;</span><br><span class="line">                f[i][j] = f[i - <span class="number">1</span>][j];</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">1</span> ; k * val &lt;= j ; k++)&#123;</span><br><span class="line">                    f[i][j] += f[i -  <span class="number">1</span>][j - k * val] ;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> f[n][amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>从体积开始倒退 f[j] 可以由无数个之前的f[j - 1]的可能转移而来<br>优化写法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> <span class="number">5010</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">change</span><span class="params">(<span class="type">int</span> amount, <span class="type">int</span>[] coins)</span> &#123;</span><br><span class="line">        <span class="type">int</span> [] f = <span class="keyword">new</span> <span class="title class_">int</span> [N];</span><br><span class="line">        f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span> ; i &lt;= coins.length ; i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> coins[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> v ; j &lt;= amount ; j++)&#123;</span><br><span class="line">                f[j] += f[j - v];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> f[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2><span id="leetcode518-零钱兑换i">leetcode518 零钱兑换I</span></h2><p>非面试 但差不多 也有可能考<br>完全背包求方案数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动态规划</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">INF</span> <span class="operator">=</span><span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> (<span class="type">int</span>)(<span class="number">1e4</span> + <span class="number">10</span>);</span><br><span class="line">    <span class="comment">// f[i] 表示可以凑成金额i所需的最小硬币数    </span></span><br><span class="line">    <span class="type">int</span> [] f = <span class="keyword">new</span> <span class="title class_">int</span> [<span class="number">10010</span>];</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">coinChange</span><span class="params">(<span class="type">int</span>[] coins, <span class="type">int</span> amount)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(amount == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> coins.length;</span><br><span class="line">        Arrays.fill(f,INF); </span><br><span class="line">    </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span> ; i &lt;= amount ; i++)&#123;</span><br><span class="line">            f[i] = INF;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span> ; i &lt;= n ; i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> coins[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(v &lt;= amount)&#123;</span><br><span class="line">                f[v] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> v ; j &lt;= amount ; j++ )&#123;</span><br><span class="line">                f[j] = Math.min(f[j],f[j - v] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> f[amount] == INF ? -<span class="number">1</span> : f[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1><span id="dfs">DFS</span></h1><h2><span id="leetcode39-组合回溯">leetcode39 组合回溯</span></h2><p>抖音支付一面</p><p>原题链接:<br><a href="https://leetcode.cn/problems/combination-sum/description/">https://leetcode.cn/problems/combination-sum/description/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> target;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">int</span> [] q;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        q = candidates;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">        <span class="built_in">this</span>.n = candidates.length;</span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        dfs(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(),<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(List&lt;Integer&gt; list,<span class="type">int</span> cur,<span class="type">int</span> id)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(cur == target)&#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(list));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(cur &gt; target)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> id; i &lt; n ; i++)&#123;</span><br><span class="line">            list.add(q[i]);</span><br><span class="line">            cur += q[i];</span><br><span class="line">            dfs(list,cur,i);</span><br><span class="line">            <span class="comment">// </span></span><br><span class="line">            list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 这里的减枝 一定要放在list 操作之后 否则 无法将list恢复现场会影响之后的流程</span></span><br><span class="line">            <span class="keyword">if</span>(cur &gt; target)&#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cur -= q[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1><span id="字典树">字典树</span></h1><h2><span id="leetcode1268-搜索推荐系统">leetcode1268 搜索推荐系统</span></h2><p>原题链接:<br><a href="https://leetcode.cn/problems/search-suggestions-system/description/">https://leetcode.cn/problems/search-suggestions-system/description/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span>[][] tr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">20010</span>][<span class="number">26</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    Map&lt;Integer, Integer&gt; min = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(), max = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(String s, <span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> s.charAt(i) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (tr[p][u] == <span class="number">0</span>) &#123;</span><br><span class="line">                tr[p][u] = ++idx;</span><br><span class="line">                min.put(tr[p][u], num);</span><br><span class="line">            &#125;</span><br><span class="line">            max.put(tr[p][u], num);</span><br><span class="line">            p = tr[p][u];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[] query(String s) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> -<span class="number">1</span>, b = -<span class="number">1</span>, p = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> s.charAt(i) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (tr[p][u] == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">            a = min.get(tr[p][u]); b = max.get(tr[p][u]);</span><br><span class="line">            p = tr[p][u];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;a, b&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">suggestedProducts</span><span class="params">(String[] ps, String w)</span> &#123;</span><br><span class="line">        Arrays.sort(ps);</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ps.length; i++) add(ps[i], i);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; w.length(); i++) &#123;</span><br><span class="line">            List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="type">int</span>[] info = query(w.substring(<span class="number">0</span>, i + <span class="number">1</span>));</span><br><span class="line">            <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> info[<span class="number">0</span>], r = info[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> l; j &lt;= Math.min(l + <span class="number">2</span>, r) &amp;&amp; l != -<span class="number">1</span>; j++) list.add(ps[j]);</span><br><span class="line">            ans.add(list);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1><span id="sql">SQL</span></h1><h2><span id="sql156-各个视频的平均完播率">SQL156 各个视频的平均完播率</span></h2><p>原题链接:<br><a href="https://www.nowcoder.com/practice/96263162f69a48df9d84a93c71045753?tpId=268&amp;tqId=2285032&amp;ru=/exam/oj&amp;qru=/ta/sql-factory-interview/question-ranking&amp;sourceUrl=/exam/oj?page=1&tab=SQL%25E7%25AF%2587&topicId=268">https://www.nowcoder.com/practice/96263162f69a48df9d84a93c71045753?tpId=268&amp;tqId=2285032&amp;ru=/exam/oj&amp;qru=/ta/sql-factory-interview/question-ranking&amp;sourceUrl=%2Fexam%2Foj%3Fpage%3D1%26tab%3DSQL%25E7%25AF%2587%26topicId%3D268</a></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 计算<span class="number">2021</span>年里有播放记录的每个视频的完播率(结果保留三位小数)，并按完播率降序排序</span><br><span class="line"># 拆解条件<span class="number">2021</span>年  完播率  降序排序</span><br><span class="line"># 完播率 <span class="operator">=</span> 视频完播次数 <span class="operator">/</span> 总播放数</span><br><span class="line"><span class="keyword">select</span> a.video_id ,</span><br><span class="line"> round(<span class="built_in">sum</span>(if(end_time <span class="operator">-</span> start_time <span class="operator">&gt;=</span> duration,<span class="number">1</span>,<span class="number">0</span>))<span class="operator">/</span><span class="built_in">count</span>(start_time),<span class="number">3</span>) <span class="keyword">as</span> avg_comp_play_rate</span><br><span class="line"><span class="keyword">from</span> tb_user_video_log <span class="keyword">as</span> a</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> tb_video_info <span class="keyword">as</span> b</span><br><span class="line"><span class="keyword">on</span> a.video_id <span class="operator">=</span> b.video_id</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">year</span>(start_time) <span class="operator">=</span> <span class="number">2021</span></span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> a.video_id</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> avg_comp_play_rate <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试真题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>简历</title>
      <link href="/2023/11/27/%E9%9D%A2%E8%AF%95%E7%9C%9F%E9%A2%98/0%E7%AE%80%E5%8E%86/"/>
      <url>/2023/11/27/%E9%9D%A2%E8%AF%95%E7%9C%9F%E9%A2%98/0%E7%AE%80%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>sxx<br>markdown简历编写:<br><a href="https://www.nowcoder.com/discuss/385152759832604672">https://www.nowcoder.com/discuss/385152759832604672</a></p><p>Typora 简历模板使用<br><a href="https://www.happysimple.wang/posts/artwork/typora-theme-happysimple.html#_1-%E8%8E%B7%E5%8F%96%E6%96%B9%E5%BC%8F">https://www.happysimple.wang/posts/artwork/typora-theme-happysimple.html#_1-%E8%8E%B7%E5%8F%96%E6%96%B9%E5%BC%8F</a></p>]]></content>
      
      
      <categories>
          
          <category> interview </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>蚂蚁金服面经汇总</title>
      <link href="/2023/11/27/%E9%9D%A2%E8%AF%95%E7%9C%9F%E9%A2%98/2%E8%9A%82%E8%9A%81%E9%87%91%E6%9C%8D%E9%9D%A2%E7%BB%8F%E6%B1%87%E6%80%BB/"/>
      <url>/2023/11/27/%E9%9D%A2%E8%AF%95%E7%9C%9F%E9%A2%98/2%E8%9A%82%E8%9A%81%E9%87%91%E6%9C%8D%E9%9D%A2%E7%BB%8F%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc --><ul><li><a href="#%E7%A4%BE%E6%8B%9B-%E7%89%9B%E5%AE%A2-2022-%E7%A7%8B">社招 牛客 2022 秋</a><ul><li><a href="#mysql%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84">mysql索引结构</a></li><li><a href="#b%E6%A0%91b%E6%A0%91%E7%9A%84%E5%8C%BA%E5%88%AB">B+树，B树的区别</a></li></ul></li><li><a href="#%E7%A7%8B%E6%8B%9B-%E7%89%9B%E5%AE%A2-2022-%E7%94%B5%E8%AF%9D%E9%9D%A2">秋招 牛客 2022  电话面</a><ul><li><a href="#rpc%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B">rpc的执行流程</a><ul><li><a href="#rpc%E8%B0%83%E7%94%A8%E6%97%B6%E6%80%8E%E4%B9%88%E7%9F%A5%E9%81%93%E8%AF%A5%E5%AF%B9%E6%96%B9%E5%9C%B0%E5%9D%80%E7%9A%84">rpc调用时怎么知道该对方地址的?</a></li><li><a href="#rpc%E5%92%8Chttp%E7%9A%84%E5%8C%BA%E5%88%AB">rpc和http的区别</a></li><li><a href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8rpc%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8http">什么时候用rpc，什么时候用http</a></li><li><a href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84double-check%E5%86%99%E6%B3%95">单例模式的double check写法</a></li></ul></li></ul></li><li><a href="#%E7%A7%8B%E6%8B%9B-%E7%89%9B%E5%AE%A2-2022-%E9%9D%A2%E7%BB%8F">秋招 牛客 2022 面经</a><ul><li><a href="#redis-%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%9C%89%E5%93%AA%E4%BA%9B">redis 的数据结构有哪些</a></li><li><a href="#%E4%B8%80%E4%BA%9B%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E7%A4%BA%E4%BE%8B">一些使用场景示例</a></li><li><a href="#redis%E7%9A%84%E8%BF%87%E6%9C%9F%E9%94%AE%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5">redis的过期键删除策略</a></li><li><a href="#aop%E5%9C%A8%E5%B7%A5%E4%BD%9C%E4%B8%AD%E7%94%A8%E8%BF%87%E5%90%97%E5%93%AA%E4%BA%9B%E5%9C%BA%E6%99%AF">AOP在工作中用过吗？哪些场景？</a></li><li><a href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E9%94%81%E4%BD%A0%E7%9F%A5%E9%81%93%E5%93%AA%E4%BA%9B">数据库的锁你知道哪些？</a></li><li><a href="#%E8%A1%8C%E9%94%81%E6%80%8E%E4%B9%88%E5%8A%A0">行锁怎么加？</a></li><li><a href="#%E4%BD%BF%E7%94%A8select-for-update%E8%AF%AD%E5%8F%A5%E5%8F%AF%E4%BB%A5%E8%8E%B7%E5%8F%96%E8%A1%8C%E7%BA%A7%E9%94%81-%E7%BB%8F%E8%BF%87%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%E6%83%85%E5%86%B5%E4%BC%9A%E5%87%BA%E7%8E%B0%E9%94%81%E5%A4%9A%E8%A1%8C%E7%9A%84%E7%8E%B0%E8%B1%A1">使用SELECT … FOR UPDATE语句可以获取行级锁 经过什么样的情况会出现锁多行的现象？</a></li><li><a href="#%E6%9C%89%E4%B8%80%E4%B8%AA%E7%9B%B8%E5%90%8C%E7%9A%84%E8%AF%B7%E6%B1%82%E6%8E%A5%E5%8F%A3%E8%AF%B7%E6%B1%82%E4%BA%86%E4%B8%A4%E6%AC%A1%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9C%89%E4%BB%80%E4%B9%88%E5%A4%84%E7%90%86%E6%96%B9%E6%A1%88%E8%BF%99%E5%9D%97%E6%98%AF%E6%83%B3%E8%80%83%E5%AF%9F%E5%B9%82%E7%AD%89">有一个相同的请求接口，请求了两次服务器，有什么处理方案？（这块是想考察幂等）</a></li><li><a href="#%E6%9C%89%E4%B8%AA%E9%AB%98%E5%B9%B6%E5%8F%91%E7%9A%84%E7%A7%AF%E5%88%86%E7%B3%BB%E7%BB%9F%E6%83%B3%E8%A6%81%E5%9C%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A2%9E%E5%8A%A0%E7%A7%AF%E5%88%86%E4%BD%A0%E4%BC%9A%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0">有个高并发的积分系统，想要在数据库增加积分，你会怎么实现？</a></li></ul></li></ul><!-- tocstop --><h1><span id="社招-牛客-2022-秋">社招 牛客 2022 秋</span></h1><p>原面经链接:<br><a href="https://www.nowcoder.com/discuss/508672172324339712?sourceSSR=search">https://www.nowcoder.com/discuss/508672172324339712?sourceSSR=search</a></p><h2><span id="mysql索引结构">mysql索引结构</span></h2><ol><li>B+Tree索引 <strong>最常见</strong>的索引类型，大部分引擎都支持 B+ 树索引</li><li>Hash索引 底层数据结构是用哈希表实现的, 只有精确匹配索引列的查询才有效, 不支持范围查询</li><li>R-tree(空间索引）空间索引是MyISAM引擎的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少</li><li>Full-text(全文索引)是一种通过建立倒排索引,快速匹配文档的方式。类似于Lucene,Solr,ES</li></ol><h2><span id="b树b树的区别">B+树，B树的区别</span></h2><ol><li>所有的数据都会出现在叶子节点。</li><li>叶子节点形成一个单向链表。</li><li>非叶子节点仅仅起到<strong>索引</strong>数据作用，具体的数据都是在叶子节点存放的。</li></ol><h1><span id="秋招-牛客-2022-电话面">秋招 牛客 2022  电话面</span></h1><p>原面经链接:<br><a href="https://www.nowcoder.com/discuss/404011530516283392?sourceSSR=search">https://www.nowcoder.com/discuss/404011530516283392?sourceSSR=search</a></p><h2><span id="rpc的执行流程">rpc的执行流程</span></h2><p>RPC（远程过程调用）是一种用于实现分布式系统中不同进程或计算机之间通信的技术。下面是RPC的执行流程：</p><ol><li>客户端发起调用：客户端应用程序向远程服务发送请求调用，通常通过调用<strong>本地的代理对象</strong>来实现。代理对象封装了与远程服务的通信细节，使客户端调用看起来像是本地调用。</li><li>传输请求数据：客户端的代理对象将请求数据进行<strong>序列化</strong>，并通过网络传输到远程服务。</li><li>服务端接收请求：远程服务接收到请求数据，并将其进行<strong>反序列化</strong>，还原为可执行的服务方法调用。</li><li>执行服务方法：远程服务执行相应的服务方法，并返回执行结果。</li><li>传输响应数据：服务端将执行结果进行<strong>序列化</strong>，并通过网络传输回客户端。</li><li>客户端接收响应：客户端代理对象接收到响应数据，并将其进行<strong>反序列化</strong>，得到最终的执行结果。</li><li>返回调用结果：客户端代理对象将<strong>执行结果</strong>返回给客户端应用程序，完成远程调用。<br>总结来说，RPC的执行流程包括<strong>客户端发起调用、传输请求数据、服务端接收请求、执行服务方法、传输响应数据、客户端接收响应以及返回调用结果</strong>。通过这种方式，可以在分布式系统中实现不同进程或计算机之间的远程通信。</li></ol><h3><span id="rpc调用时怎么知道该对方地址的">rpc调用时怎么知道该对方地址的?</span></h3><p>在RPC调用中，客户端需要知道远程服务的地址才能进行调用。以下是一些常见的方式来确定远程服务的地址：<br><strong>配置文件</strong>：客户端可以通过配置文件来指定远程服务的地址。在配置文件中，可以设置远程服务的IP地址和端口号等信息。客户端在启动时读取配置文件，并使用其中指定的地址进行RPC调用。<br><strong>服务注册与发现</strong>：客户端可以通过服务注册与发现的机制来获取远程服务的地址。在这种机制中，服务提供者将自己的地址注册到注册中心，而客户端从注册中心查询可用的服务列表，并选择合适的地址进行调用。常见的服务注册与发现工具有ZooKeeper、Consul、Etcd等。<br>DNS解析：客户端可以使<strong>用域名解析</strong>来获取远程服务的地址。在这种方式中，服务提供者将自己的地址绑定到一个域名上，而客户端通过域名解析获取对应的IP地址。客户端可以使用解析后的IP地址进行RPC调用。<br><strong>服务代理</strong>：有时候，客户端可能无法直接获得远程服务的地址，而是通过一个代理服务器进行调用。客户端将RPC请求发送给<strong>代理服务器</strong>，代理服务器负责将请求转发给实际的远程服务。在这种情况下，客户端只需要知道代理服务器的地址，而无需了解实际远程服务的地址。</p><h3><span id="rpc和http的区别">rpc和http的区别</span></h3><p>RPC（远程过程调用）和HTTP（超文本传输协议）是两种不同的通信协议，它们有以下几个主要区别：</p><ol><li>概念和用途：<br>RPC是一种用于实现<strong>分布式系统</strong>中不同进程或计算机之间通信的技术，它的目的是让远程调用看起来像是<strong>本地调用</strong>，提供了直接调用远程服务的能力。<br>HTTP(应用层协议)是一种面向传输层的协议(面向传输层的协议是指在应用层中使用的协议，依赖于传输层协议来提供数据传输服务)，用于在客户端和服务器之间传输超文本数据。它主要用于<strong>Web应用程序</strong>*的通信，例如浏览器和服务器之间的请求和响应。</li><li>通信方式：<br>RPC通常使用<strong>底层的二进制协议</strong>进行通信，如Protocol Buffers、Thrift等，以提高性能和效率。<br>HTTP使用<strong>文本协议</strong>进行通信，数据以文本形式传输，通常使用JSON或XML格式进行数据交换。</li><li>传输协议：<br>RPC可以在<strong>不同的传输协议</strong>上运行，如TCP、UDP等。它可以根据具体需求选择适合的传输协议。<br>HTTP使用<strong>TCP</strong>作为传输协议，并使用标准的HTTP请求和响应格式。<br>4, 可扩展性：<br>RPC通常提供更高级别的抽象和功能，例如服务注册与发现、负载均衡、容错机制等，以支持复杂的分布式系统。<br>HTTP相对简单，通常需要使用其他技术和工具来实现复杂的系统功能，例如使用RESTful API来构建可扩展的Web服务。</li><li>应用场景：<br>RPC通常用于构建高性能和实时性要求较高的分布式系统，例如微服务架构、远程调用等。<br>HTTP广泛应用于Web开发，用于实现客户端和服务器之间的通信，例如网页浏览、API调用等。</li></ol><h3><span id="什么时候用rpc什么时候用http">什么时候用rpc，什么时候用http</span></h3><p>当选择使用RPC或HTTP时，主要考虑以下几个因素：</p><ol><li>性能要求：如果您的应用程序对于性能和效率有较高的要求，特别是在分布式系统中需要频繁进行<strong>远程调用或数据传输</strong>，那么RPC可能是更好的选择。由于RPC使用<strong>二进制协议和较低的开销</strong>，可以提供更高的性能和更低的延迟。</li><li>功能需求：如果您的应用程序需要更复杂的功能，例如<strong>服务注册与发现、负载均衡、容错机制</strong>等，那么RPC可能是更适合的选择。RPC框架通常提供这些功能的支持，可以更好地满足分布式系统的需求。</li><li>简单性和易用性：如果您的应用程序只需要进行<strong>简单的请求和响应</strong>，而不需要复杂的功能和高性能，那么HTTP可能是更简单和易用的选择。HTTP使用文本协议和广泛支持的标准，可以更容易地与其他系统进行集成和交互。</li><li>开发生态系统：考虑到可用的工具、库和支持，以及开发社区的活跃度，也是选择RPC或HTTP的因素之一。根据您的编程语言和技术栈，可能会有更成熟和丰富的RPC框架或HTTP库可供选择。</li></ol><h3><span id="单例模式的double-check写法">单例模式的double check写法</span></h3><p>当使用双重检查锁（Double-Check Locking）来实现单例模式时，需要注意<strong>线程安全性和可见性</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 私有化构造函数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;  <span class="comment">// 第一次检查，避免不必要的同步</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;  <span class="comment">// 第二次检查，确保只有一个实例被创建</span></span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在上述代码中，关键的地方是将instance声明为volatile，这可以确保在多线程环境下，对instance的<strong>读写操作保持可见性</strong>。另外，使用双重检查锁的目的是在并发情况下减少同步开销，只在实例为null时才进行同步创建实例。<br>将instance声明为volatile的原因是为了避免指令重排序。</p><h1><span id="秋招-牛客-2022-面经">秋招 牛客 2022 面经</span></h1><p>原面经地址<br><a href="https://www.nowcoder.com/feed/main/detail/324fac3d213f4254ab1766965a678bd9?sourceSSR=search">https://www.nowcoder.com/feed/main/detail/324fac3d213f4254ab1766965a678bd9?sourceSSR=search</a></p><h3><span id="redis-的数据结构有哪些">redis 的数据结构有哪些</span></h3><p>Redis是一种高性能的键值存储系统，支持多种数据结构。以下是Redis中常用的数据结构：<br>字符串（String）：存储一个字符串值。<br>列表（List）：有序的字符串列表，可以在头部或尾部插入元素。<br>集合（Set）：无序的唯一元素集合，支持集合的交、并、差等操作。<br>有序集合（Sorted Set）：有序的唯一元素集合，每个元素都关联一个分数，可以按照分数排序。<br>哈希（Hash）：键值对的无序散列集合，适用于存储对象。<br>位图（Bitmap）：由<strong>二进制位</strong>组成的数据结构，支持对位的操作。<br>HyperLogLog：用于基数计数的数据结构，可以估计一个集合中的不重复元素数量。</p><p>除了上述常用的数据结构，Redis还提供了一些特殊的数据结构和功能，如地理位置（Geospatial）支持、发布&#x2F;订阅（Pub&#x2F;Sub）消息传递、Lua脚本执行等。</p><h3><span id="一些使用场景示例">一些使用场景示例</span></h3><ol><li>字符串（String）：<br>缓存存储：将经常使用的数据存储在Redis的字符串中，以加快读取速度。<br>计数器：将字符串作为计数器，例如网站的页面访问量、用户签到次数等。</li><li>列表（List）：<br>消息队列：将消息作为列表的元素，实现简单的消息队列，支持先进先出（FIFO）的处理方式。<br>最新动态：将最新的动态消息按照时间顺序存储在列表中，可以轻松获取最新的N条动态。</li><li>集合（Set）：<br><strong>标签系统</strong>：将每个对象的标签存储为集合，可以进行标签的交集、并集等操作，方便进行对象的分类和检索。<br>好友关系：将用户的好友关系存储为集合，可以进行共同好友、推荐好友等操作。</li><li>有序集合（Sorted Set）：<br>排行榜：将用户的得分和用户名存储在有序集合中，可以按照得分排序，实现游戏排行榜、文章热度榜等功能。<br>时间轴：将帖子或事件的发布时间和内容存储在有序集合中，可以按照时间范围获取最新的帖子或事件。</li><li>哈希（Hash）：<br>用户信息存储：将用户的信息（如用户名、年龄、性别等）存储在哈希中，可以方便地获取和更新用户信息。<br>商品信息存储：将商品的名称、价格、库存等信息存储在哈希中，方便进行商品的查询和更新。</li></ol><h3><span id="redis的过期键删除策略">redis的过期键删除策略</span></h3><p>Redis采用了一种<strong>惰性删除(Lazy deletion)<strong>的策略来处理过期键的删除。<br>具体来说，Redis</strong>并不会主动监视和删除过期键</strong>，而是在客户端<strong>请求访问</strong>某个键时，才会检查该键是否过期，并在必要时进行删除。<br>过期键删除策略的主要原因是为了提高Redis的性能和响应速度。如果Redis每次都主动监视和删除过期键，会增加系统的负担和延迟。因此，Redis将主动删除过期键的操作延迟到了需要访问该键时进行，避免了频繁的过期键删除操作。</p><p>具体的过期键删除策略如下：</p><p>客户端请求访问某个键时，Redis会检查该键是否过期。<br>如果键已过期，则Redis会立即删除该键。<br>如果键未过期，则继续执行客户端请求的操作。<br>需要注意的是，过期键删除策略虽然能够提高Redis的性能，但也存在一定的副作用。当过期键的数量较多时，可能会导致Redis在处理客户端请求时，需要额外的时间进行过期键的删除操作，从而影响系统的响应速度。</p><p>为了解决这个问题，Redis引入了定期删除（Eviction）和惰性删除相结合的策略。定期删除会<strong>定期检查</strong>一定数量的过期键并删除它们，以防止过期键堆积过多。而惰性删除则是在客户端请求时进行过期键的删除，以确保过期键及时被删除。</p><h3><span id="aop在工作中用过吗哪些场景">AOP在工作中用过吗？哪些场景？</span></h3><p>AOP是一种编程范式，通过将横切关注点（如日志记录、性能监控、事务管理等）从<strong>主业务逻辑</strong>中分离出来，提供了一种更加<strong>模块化和可复用</strong>的方式来处理横切关注点。<br>以下是一些我在工作中使用AOP的场景：<br>日志记录：通过AOP可以在方法执行前后记录方法的入参、返回值、执行时间等信息，方便后续的调试和排查问题。<br>性能监控：使用AOP可以在方法执行前后计算方法的执行时间，并记录下来，用于性能优化和监控。<br>事务管理：AOP可以在方法执行前后开启和提交事务，保证方法的原子性和一致性。<br>安全控制：通过AOP可以在方法执行前进行权限验证，确保只有具备相应权限的用户才能访问敏感的方法。<br>缓存管理：使用AOP可以在方法执行前检查缓存中是否存在所需数据，如果存在则直接返回缓存数据，减少数据库访问的次数。<br>异常处理：AOP可以捕获方法抛出的异常，并进行统一的处理和日志记录，避免代码中重复的异常处理逻辑。</p><h3><span id="数据库的锁你知道哪些">数据库的锁你知道哪些？</span></h3><p>在关系型数据库中，常见的几种数据库锁包括：<br>共享锁（Shared Lock）：也称为<strong>读锁</strong>，多个事务可以同时获得共享锁，用于读取数据，不阻塞其他事务的共享锁。<br>排他锁（Exclusive Lock）：也称为<strong>写锁</strong>，只有一个事务可以获得排他锁，用于修改或删除数据，其他事务无法获取共享锁或排他锁。<br>行级锁（Row-level Lock）：锁定数据库表中的<strong>单独一行</strong>，可在并发环境下实现更细粒度的锁控制，减少锁竞争。<br>表级锁（Table-level Lock）：锁定整个数据库表，适用于对整个表进行操作的事务，如表的重建、重命名等。<br>页级锁（Page-level Lock）：锁定数据库中的页面，通常是连续的数据页，适用于需要访问多行数据的事务。<br>数据库级锁（Database-level Lock）：锁定整个数据库，用于进行数据库级别的操作，如<strong>备份、还原</strong>等。<br>除了上述常见的锁类型，不同的数据库管理系统可能还有其他特定的锁类型和机制，如行锁的实现方式（行锁、间隙锁、Next-Key锁等）。</p><h3><span id="行锁怎么加">行锁怎么加？</span></h3><p>在关系型数据库中，行级锁的实现方式可以通过两种常见的方式来加锁：悲观锁和乐观锁。</p><ol><li>悲观锁：<br>在悲观锁的实现方式下，数据库会在读取数据时<strong>自动</strong>为所读取的行加上行级锁，阻止其他事务对该行进行修改。<br>在读取数据时，可以使用<strong>SELECT … FOR UPDATE</strong>语句来获取悲观锁。这会将所选行加上排他锁（Exclusive Lock），其他事务无法对该行进行修改，直到当前事务释放锁。</li><li>乐观锁：<br>在乐观锁的实现方式下，数据库<strong>并不主动加锁</strong>，而是通过使用<strong>版本号（或时间戳）</strong>来实现并发控制。<br>每行数据都包含一个版本号字段，当事务读取数据时，会将版本号一同读取到应用程序中。<br>在更新数据时，事务会<strong>查当前数据的版本号是否与初始读取时的版本号一致</strong>，如果一致，则更新数据并递增版本号；如果不一致，则表示数据已被其他事务修改，需要进行相应处理（如回滚事务或重新读取数据）。</li></ol><h3><span id="使用select-for-update语句可以获取行级锁-经过什么样的情况会出现锁多行的现象">使用SELECT … FOR UPDATE语句可以获取行级锁 经过什么样的情况会出现锁多行的现象？</span></h3><p>使用SELECT … FOR UPDATE语句可以获取行级锁，确保在事务中对所选行的数据进行修改时不会被其他事务干扰。在以下情况下，可能会出现锁多行的现象：</p><ol><li>事务中<strong>查询的条件</strong>导致多行被匹配：<br>如果SELECT … FOR UPDATE语句的查询条件导致多行数据被匹配，那么这些行都会被加上行级锁。例如，如果查询条件没有限制唯一性，或者使用了范围查询，可能会导致多行的锁被加上。</li><li><strong>并发事务同时</strong>执行SELECT … FOR UPDATE语句：<br>如果<strong>多个</strong>并发事务同时执行SELECT … FOR UPDATE语句，并且这些事务查询的数据存在<strong>交叉</strong>的情况，那么可能会导致锁多行的现象。<br>当事务A执行SELECT … FOR UPDATE语句并加锁时，事务B也执行了相同的SELECT … FOR UPDATE语句并且查询的数据与事务A的查询结果有交集，那么事务B也会对其中的行加上行级锁。</li><li>事务持有锁的时间过长：<br>如果事务持有锁的时间过长，其他事务可能会在此期间等待获取锁。如果事务A持有某些行的锁，并且在执行期间没有及时释放锁，那么其他事务可能会因等待而锁住更多的行。</li></ol><h3><span id="有一个相同的请求接口请求了两次服务器有什么处理方案这块是想考察幂等">有一个相同的请求接口，请求了两次服务器，有什么处理方案？（这块是想考察幂等）</span></h3><ol><li>请求唯一标识：<br>在每个请求中<strong>添加一个唯一的标识符</strong>，例如在请求头或请求参数中添加一个UUID，并将此标识符与已处理的请求进行比对。<br>服务器在接收到请求时，先检查该标识符是否已存在，如果已存在，则可以判断为重复请求，直接返回之前的处理结果，而不执行重复的操作。</li><li>幂等接口设计：<br>在设计接口时，将接口<strong>设计为幂等操作</strong>，即使接口被重复调用，也只会产生一次结果或影响。例如，对于更新操作，可以使用<strong>PUT方法来替代POST方法</strong>，确保同一请求多次调用时只会更新一次数据。</li><li>状态检查与处理：<br>在服务器端，可以通过记录请求的处理状态，如将<strong>请求结果或关键信息存储在数据库</strong>中，以便后续重复请求时进行状态检查。<br>当收到重复请求时，服务器可以查询之前的处理结果并返回，而不再执行重复的操作。</li><li>乐观锁：<br>在数据库操作中，可以使用乐观锁的机制来保证幂等性。<br>乐观锁通过在数据库表中添加<strong>版本号字段</strong>，每次更新时检查版本号是否一致。如果版本号一致，则进行更新操作；如果版本号不一致，则表示已经被其他请求修改，可以返回错误或忽略当前请求。</li></ol><h3><span id="有个高并发的积分系统想要在数据库增加积分你会怎么实现">有个高并发的积分系统，想要在数据库增加积分，你会怎么实现？</span></h3><ol><li>数据库设计：<br>创建一个用户积分表，包含用户ID、积分总数等字段。<br>为用户ID字段添加<strong>唯一索引</strong>，以提高查询和更新性能。</li><li>缓存方案：<br>使用缓存技术（如Redis）来存储用户的积分数据，以提高读取性能和减轻数据库的压力。<br>用户的积分数据在首次查询时从数据库加载到缓存中，并定期进行更新或在用户积分变动时更新缓存。</li><li>并发控制：<br>使用<strong>乐观锁</strong>机制来避免并发操作的冲突。在用户积分更新时，读取当前积分和版本号，然后在更新时检查版本号是否一致，如一致则进行更新，否则需要进行回滚或重试。</li><li>事务管理：<br>对于某些需要多个操作组合的积分变动场景（如积分转账等），可以使用数据库事务来保证操作的原子性和一致性。<br>在事务中执行多个积分操作，如增加积分、减少积分等，并在事务提交时进行校验和处理。</li><li>异步处理：<br>使用消息队列（如Kafka或RabbitMQ）将积分变动请求发送到消息队列中，进行异步处理。<br>在消费者端从消息队列中获取积分变动请求，并进行相应的积分更新操作。</li><li>监控和日志：<br>在系统中添加监控和日志功能，记录关键指标和异常情况，以便及时发现和解决问题。<br>监控可以包括并发请求量、响应时间、错误率等指标，用于系统性能和稳定性的评估和优化。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 面试真题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 蚂蚁金服 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>code无重复字符的最长子串</title>
      <link href="/2023/11/25/%E9%9D%A2%E8%AF%95%E7%9C%9F%E9%A2%98/code%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"/>
      <url>/2023/11/25/%E9%9D%A2%E8%AF%95%E7%9C%9F%E9%A2%98/code%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>小米日常实习 二面</p><p>原题链接:<br><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/">https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">char</span> [] cs = s.toCharArray();</span><br><span class="line">        <span class="comment">// 用作滑动窗口 字符 以及 出现的位置</span></span><br><span class="line">        HashMap&lt;Character,Integer&gt; hash = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(hash.containsKey(cs[i]))&#123;</span><br><span class="line">                left = Math.max(hash.get(cs[i]) + <span class="number">1</span>,left);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 更新 字符出现的 最后一个位置</span></span><br><span class="line">            hash.put(cs[i],i);</span><br><span class="line">            <span class="comment">// i 是当前位置 已经包括在窗口内了 所示 i - left + 1</span></span><br><span class="line">            ans = Math.max(ans,i - left + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试真题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 滑动窗口 </tag>
            
            <tag> 小米实习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>code山脉数组的峰顶索引</title>
      <link href="/2023/11/25/%E9%9D%A2%E8%AF%95%E7%9C%9F%E9%A2%98/code%E5%B1%B1%E8%84%89%E6%95%B0%E7%BB%84%E7%9A%84%E5%B3%B0%E9%A1%B6%E7%B4%A2%E5%BC%95/"/>
      <url>/2023/11/25/%E9%9D%A2%E8%AF%95%E7%9C%9F%E9%A2%98/code%E5%B1%B1%E8%84%89%E6%95%B0%E7%BB%84%E7%9A%84%E5%B3%B0%E9%A1%B6%E7%B4%A2%E5%BC%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>小米日常实习</p><p>原题链接:<br><a href="https://leetcode.cn/problems/peak-index-in-a-mountain-array/description/">https://leetcode.cn/problems/peak-index-in-a-mountain-array/description/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peakIndexInMountainArray</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> -<span class="number">1</span>, r = arr.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length;</span><br><span class="line">        <span class="keyword">while</span>(l + <span class="number">1</span> &lt; r)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(mid + <span class="number">1</span> &lt; n &amp;&amp; arr[mid] &gt; arr[mid + <span class="number">1</span>])&#123;</span><br><span class="line">                r = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                l = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试真题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分 </tag>
            
            <tag> 小米校招 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面经汇总校招</title>
      <link href="/2023/11/25/%E9%9D%A2%E8%AF%95%E7%9C%9F%E9%A2%98/1%E9%9D%A2%E7%BB%8F%E6%B1%87%E6%80%BB%E6%A0%A1%E6%8B%9B/"/>
      <url>/2023/11/25/%E9%9D%A2%E8%AF%95%E7%9C%9F%E9%A2%98/1%E9%9D%A2%E7%BB%8F%E6%B1%87%E6%80%BB%E6%A0%A1%E6%8B%9B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1><span id="中厂">中厂</span></h1><h2><span id="多益网络">多益网络</span></h2><h3><span id="java对象创建的方式除了new">Java对象创建的方式，除了new？</span></h3><ol><li>使用<strong>反射</strong>（Reflection）: 可以使用Class类的newInstance()方法或者Constructor类的newInstance()方法来创建对象。这种方式可以在运行时动态地创建对象，适用于需要根据类名或者构造函数参数来创建对象的情况。</li><li>使用clone()方法：通过实现Cloneable接口并重写clone()方法，可以创建对象的副本。使用clone()方法创建的对象是原始对象的浅拷贝，需要注意对象的成员变量是否需要深拷贝。</li><li>使用ObjectInputStream和ObjectOutputStream：通过序列化和反序列化来创建对象。将对象写入到流中，再从流中读取对象，可以实现对象的深拷贝。这种方式适用于需要在网络传输或者持久化存储中传递对象的情况。</li><li>使用<strong>工厂方法</strong>（Factory Method）：通过定义工厂类和工厂方法来创建对象。工厂方法可以根据不同的条件或者参数来创建不同的对象，提供了更灵活的对象创建方式。</li><li>使用<strong>依赖注入</strong>框架（如Spring）：通过依赖注入框架来管理对象的创建和生命周期。框架会根据配置文件或者注解来自动创建对象，将对象的创建过程交给框架来处理。</li></ol><h3><span id="java中字节流和字符流的区别">Java中字节流和字符流的区别?</span></h3><p>Java中的字符流和字节流是用于处理输入和输出的两种不同的流。它们之间的主要区别在于处理的<strong>数据单位和数据类型</strong>。</p><ol><li>字节流（Byte Stream）以字节（Byte）为单位进行读写操作。字节流主要用于处理二进制数据，如图像、音频、视频等文件。字节流在处理数据时<strong>不会对数据进行解析或编码</strong>，而是直接按照字节的方式进行读写。</li><li>相比于字节流，字符流提供了更高级的<strong>字符</strong>处理功能，如字符编码转换、字符缓冲等。它们适用于处理文本数据，能够更方便地读写文本文件中的内容，并且可以避免因字符集不匹配而导致的乱码问题。</li></ol><h3><span id="java实现线程让步">Java实现线程让步？</span></h3><p>在Java中，可以使用Thread类的<strong>静态方法yield()<strong>来实现线程的让步。调用yield()方法会让当前线程暂停执行，让出CPU资源给其他线程。调用yield()方法后，线程会从</strong>运行状态转换为就绪状态</strong>，然后等待调度器再次选择它执行。</p><h3><span id="jvm-oom问题的常见原因-以及-解决">JVM OOM问题的常见原因 以及 解决？</span></h3><p>JVM（Java虚拟机）的OOM（OutOfMemoryError）问题是指在Java应用程序中出现内存不足的错误。这通常是由于应用程序请求的内存超过了JVM所能提供的限制，导致无法分配更多的内存空间。</p><p>常见原因:</p><ol><li><strong>内存泄漏</strong>：如果应用程序中存在内存泄漏，即对象被分配了内存空间<strong>但无法被垃圾回收器回收</strong>，随着时间的推移，内存占用逐渐增加，最终导致OOM。</li><li>大对象或者大量对象：如果应用程序创建了过多的大对象或者大量的对象，并且无法及时释放这些对象，那么内存使用就会迅速增加，超出JVM的限制。</li><li>错误的内存配置：如果JVM的<strong>内存配置</strong>不合理，例如设置的堆内存（Heap）过小，无法满足应用程序的需求，就会导致OOM问题。</li><li>递归调用导致栈溢出：如果应用程序中存在无限递归调用的情况，每次递归调用都会在栈上分配一些内存，当递归层数过多时，会导致栈溢出，进而引发OOM。</li></ol><p>解决方案:</p><ol><li>优化内存使用：检查代码中是否存在内存泄漏的情况，确保及时释放不再使用的对象，避免不必要的内存占用。</li><li>限制对象创建和存储：减少不必要的对象创建和存储，尤其是大对象或者大量对象，可以考虑使用对象池或者缓存来复用对象，减少内存开销。</li><li>调整JVM内存配置：根据应用程序的需求，合理配置JVM的内存大小，包括堆内存、栈内存等。可以通过调整JVM启动参数，如-Xmx、-Xms等来增加堆内存大小。</li><li>优化递归调用：检查代码中的递归调用是否存在无限递归的情况，确保递归调用的终止条件合理，避免栈溢出。</li><li>使用垃圾回收器：选择合适的垃圾回收器，根据应用程序的特点和需求进行调优，以提高内存回收的效率。</li></ol><h3><span id="redis中的bigkey该如何排查">Redis中的bigKey该如何排查？</span></h3><p>在Redis中，”bigKey”是指占用<strong>大量内存空间</strong>的键。当一个键的值非常大时，它可能会导致Redis的性能下降，甚至引发一些问题，如网络传输延迟、持久化备份缓慢等。<br>排查方式:</p><ol><li>使用Redis命令<strong>MEMORY USAGE</strong>查看键的内存占用情况。例如，使用以下命令获取键名为”myKey”的内存占用情况：</li><li>使用Redis命令<strong>SCAN或KEYS</strong>遍历所有键，并查找内存占用较大的键。例如，使用以下命令遍历所有键，找到内存占用超过一定阈值的键：</li><li>使用Redis的性能分析工具，如<strong>RedisGears、RedisInsight</strong>等，来分析内存占用较大的键。这些工具可以提供可视化界面和更详细的分析结果，帮助快速定位bigKey问题。</li></ol><h3><span id="什么是-mysql当前读和快照读">什么是 MySQL当前读和快照读？</span></h3><p>MySQL中的”当前读”（Current Read）和”快照读”（Snapshot Read）是指在事务隔离级别为<strong>可重复读（REPEATABLE READ）</strong>时，对于读取数据的方式的不同。<br>当前读（Current Read）：当前读是指在可重复读隔离级别下，读取数据时直接读取数据库中<strong>最新</strong>的数据。当前读会对读取的数据<strong>加锁</strong>，防止其他事务对该数据进行修改。<br>快照读（Snapshot Read）：快照读是指在可重复读隔离级别下，读取数据时读取的是<strong>事务开始时</strong>的一个快照（snapshot）数据。这意味着事务在执行期间<strong>不会看到其他事务对数据的修改</strong>。<br>在可重复读隔离级别下，MySQL<strong>默认使用快照读</strong>，即读取事务开始时的数据快照，而不会受到其他事务的修改影响。这样可以保证事务的<strong>一致性</strong>，避免<strong>脏读和不可重复读</strong>的问题。<br>但是，有时候需要读取最新的数据，而不是快照数据，这时可以使用当前读。当前读可以通过添加FOR UPDATE或LOCK IN SHARE MODE语句来实现。例如，使用SELECT … FOR UPDATE语句进行当前读：</p><h2><span id="经纬恒润">经纬恒润</span></h2><h2><span id="java的基本数据类型有哪些">Java的基本数据类型有哪些？</span></h2><p>整数类型（整数数值）<br>浮点类型（小数数值）<br>字符类型<br>布尔类型</p><h3><span id="string-是-java语言中的基本数据类型吗">String 是 Java语言中的基本数据类型吗？</span></h3><p>不，String并不是Java语言中的基本数据类型。在Java中，String是一种<strong>引用</strong>数据类型，用于表示文本字符串。</p><h3><span id="在java除不尽的情况如何解决-比如1x2f3">在Java除不尽的情况如何解决？ 比如1&#x2F;3</span></h3><p>在Java中，使用<strong>BigDecimal</strong>可以解决除不尽的问题。BigDecimal提供了高精度的十进制计算，可以处理小数点后的任意位数。</p><h3><span id="在java中为什么-为什么正数最大值需要231-1">在Java中为什么 为什么正数最大值需要2^31-1？</span></h3><p>在Java中，正数最大值为2^31-1，是因为Java中的整数类型（如int）采用的是<strong>补码表示法</strong>。补码是一种用于表示有符号整数的编码方式。<br>在补码表示法中，对于一个n位的二进制数，最高位（最左边的位）表示符号位，0表示正数，1表示负数。因此，对于一个32位的二进制数，最高位是符号位，剩下的31位表示数值部分。</p><h2><span id="其他">其他</span></h2><h3><span id="数据库死锁事务">数据库死锁(事务)</span></h3>]]></content>
      
      
      <categories>
          
          <category> 面试真题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>面经汇总实习</title>
      <link href="/2023/11/25/%E9%9D%A2%E8%AF%95%E7%9C%9F%E9%A2%98/1%E9%9D%A2%E7%BB%8F%E6%B1%87%E6%80%BB%E5%AE%9E%E4%B9%A0/"/>
      <url>/2023/11/25/%E9%9D%A2%E8%AF%95%E7%9C%9F%E9%A2%98/1%E9%9D%A2%E7%BB%8F%E6%B1%87%E6%80%BB%E5%AE%9E%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc --><ul><li><a href="#%E5%A4%A7%E5%8E%82">大厂</a><ul><li><a href="#%E5%B0%8F%E7%B1%B3-%E6%97%A5%E5%B8%B8%E5%AE%9E%E4%B9%A0">小米 日常实习</a><ul><li><a href="#java-hashmap%E4%BA%86%E8%A7%A3%E5%A4%9A%E5%B0%91">Java HashMap了解多少？</a></li><li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8">什么是线程不安全？</a></li></ul></li></ul></li></ul><!-- tocstop --><h1><span id="大厂">大厂</span></h1><h2><span id="小米-日常实习">小米 日常实习</span></h2><h3><span id="java-hashmap了解多少">Java HashMap了解多少？</span></h3><p>HashMap是Java集合框架中的一个重要类，它实现了<strong>Map接口</strong>，提供了<strong>键值对的存储和查找功能</strong></p><ol><li>内部实现原理: 是基于<strong>哈希表（Hash Table）</strong>实现的。HashMap使用键的哈希值来确定键值对在内部数组中的存储位置，这样可以快速地进行插入、查找和删除操作。在HashMap中，键是唯一的，而值可以重复。</li><li>底层数据结构: HashMap底层的数据结构和链表(JDK8 以后会有红黑树)</li><li>扩容机制： 初始化大小是16 当HashMap中的元素个数超过<strong>负载因子(默认为0.75)与容量</strong>的乘积时，HashMap会进行扩容操作。扩容涉及重新计算哈希值、重新分配元素位置等操作，以保证哈希表的性能。需要注意的是，Java 8及以上版本的HashMap在<strong>链表长度超过一定阈值</strong>时会将链表转换为<strong>红黑树</strong>，以提高查找效率。这是为了解决当链表过长时，查找效率下降的问题。</li><li>HashMap可以用null key作为键值</li><li>HashMap是<strong>线程不安全</strong>的</li></ol><h3><span id="什么是线程不安全">什么是线程不安全？</span></h3><p>是指在多线程环境下，当多个线程同时访问<strong>某个共享资源或执行某段代码</strong>时，不符合预期的结果可能会发生。</p><p>线程不安全的情况常见于以下两种情况：</p><ol><li>竞态条件（Race Condition）：当多个线程同时访问和修改共享的数据时，由于<strong>执行顺序</strong>不确定或者没有适当的同步机制，导致最终的结果与期望不符。例如，多个线程同时对同一个变量进行自增操作，由于线程调度的不确定性，可能导致最终结果不是期望的累加值。</li><li>共享资源的不一致性：当多个线程同时访问和修改共享的数据时，由于没有适当的<strong>同步机制</strong>，可能会导致<strong>共享资源的状态不一致</strong>。例如，多个线程同时对同一个对象的实例变量进行修改，由于线程之间的执行顺序不确定，可能导致该对象的状态不一致。</li></ol><p>为了解决线程不安全问题，可以采用以下方法：</p><ol><li>使用同步机制：例如，使用synchronized关键字或Lock对象来确保多个线程对共享资源的访问是互斥的，避免竞态条件和共享资源的不一致性。</li><li>使用线程安全的数据结构：例如，使用线程安全的集合类（如ConcurrentHashMap）来代替普通的集合类，避免在多线程环境下出现问题。</li><li>使用不可变对象：不可变对象在多线程环境下是线程安全的，因为它们的<strong>状态不可修改</strong>。可以通过设计不可变对象来避免线程不安全问题。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 面试真题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>code最大数</title>
      <link href="/2023/11/25/%E9%9D%A2%E8%AF%95%E7%9C%9F%E9%A2%98/code%E6%9C%80%E5%A4%A7%E6%95%B0/"/>
      <url>/2023/11/25/%E9%9D%A2%E8%AF%95%E7%9C%9F%E9%A2%98/code%E6%9C%80%E5%A4%A7%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>蚂蚁金服校招真题</p><p>原题链接:<br><a href="https://leetcode.cn/problems/largest-number/description/">https://leetcode.cn/problems/largest-number/description/</a></p><p>贪心 + 排序<br>将两个字符串进行 拼接后进行判断 a + b &gt; b + a 则将a排在前面</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">largestNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        String [] ss = <span class="keyword">new</span> <span class="title class_">String</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; nums.length ;i++)&#123;</span><br><span class="line">            <span class="comment">// 这里要给注意要加一个 &quot;&quot;  或者直接给ss全部赋初始值为 &quot;&quot;</span></span><br><span class="line">            <span class="comment">// 就不会变成 null + nums[i]</span></span><br><span class="line">            ss[i] = <span class="string">&quot;&quot;</span> +  nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        Arrays.sort(ss,((o1, o2) -&gt; (o2 + o1).compareTo(o1 + o2)));</span><br><span class="line">        <span class="type">String</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; ss.length ; i++)&#123;</span><br><span class="line">            ans += ss[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 再特判一下 前导零</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(k &lt; n &amp;&amp; ans.charAt(k - <span class="number">1</span>) == <span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans.substring(k - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试真题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心 </tag>
            
            <tag> 蚂蚁金服校招 </tag>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>code翻转数组</title>
      <link href="/2023/11/24/%E9%9D%A2%E8%AF%95%E7%9C%9F%E9%A2%98/code%E7%BF%BB%E8%BD%AC%E6%95%B0%E7%BB%84/"/>
      <url>/2023/11/24/%E9%9D%A2%E8%AF%95%E7%9C%9F%E9%A2%98/code%E7%BF%BB%E8%BD%AC%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>多益网络校招</p><p>原题链接:<br><a href="https://leetcode.cn/problems/rotate-array/">https://leetcode.cn/problems/rotate-array/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    三次翻转</span></span><br><span class="line"><span class="comment">    1. 全数组翻转 这样尾部的k%mod个数就会移动到队首</span></span><br><span class="line"><span class="comment">    2. 然后再将首部k%mod - 1 和 k%mod,n - 1的数分别翻转就能得到答案</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rotate</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        k = k % n;</span><br><span class="line">        <span class="comment">// 整体翻转 </span></span><br><span class="line">        reverse(<span class="number">0</span>,n - <span class="number">1</span>,nums);</span><br><span class="line">        <span class="comment">// 翻转(0,k%n - 1)</span></span><br><span class="line">        reverse(<span class="number">0</span>,k - <span class="number">1</span>,nums);</span><br><span class="line">        <span class="comment">// 翻转(k%n,n - 1)</span></span><br><span class="line">        reverse(k,n - <span class="number">1</span>,nums);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">int</span> start,<span class="type">int</span> end,<span class="type">int</span> [] q)</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(start &lt; end)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> q[start];</span><br><span class="line">            q[start] = q[end];</span><br><span class="line">            q[end] = t;</span><br><span class="line">            start++;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>由于 多益网络要求的是ACM的形式 格式再附上ACM格式的代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">        k = k % n;</span><br><span class="line">        <span class="type">int</span> [] q = <span class="keyword">new</span> <span class="title class_">int</span> [n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; n ; i++)&#123;</span><br><span class="line">            q[i] = sc.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        reverse(<span class="number">0</span>,n - <span class="number">1</span>,q);</span><br><span class="line">        reverse(<span class="number">0</span>, k - <span class="number">1</span>,q);</span><br><span class="line">        reverse(k,n - <span class="number">1</span> ,q);</span><br><span class="line"></span><br><span class="line">        Arrays.stream(q).forEach(e-&gt; System.out.printf(<span class="string">&quot;%d &quot;</span>,e));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">int</span> start,<span class="type">int</span> end,<span class="type">int</span> [] q)</span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (start &lt; end)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> q[start];</span><br><span class="line">            q[start] = q[end];</span><br><span class="line">            q[end] = t;</span><br><span class="line">            start++;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试真题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>面试准备</title>
      <link href="/2023/11/24/%E9%9D%A2%E8%AF%95%E7%9C%9F%E9%A2%98/0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/"/>
      <url>/2023/11/24/%E9%9D%A2%E8%AF%95%E7%9C%9F%E9%A2%98/0%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="66e8f63fd386384c323be9241b60d58e2bf3aaa2099049147d5dc8502743d201">dc49651648acacfd7b8aa92c798562c50f39888456ccbb95186c7a4273069f6a488c6e95eba3cd6b1edbc4ef1c7dd2ed766d68659788ed98606bad2f1d54648475b17c4255d424da66f77598ecce809cce13f06de2a1e8e6d0fb14fa026629d5ac8234cab2b2caf6108b1913e3e90bee91f209777fba4d7884e268bd6f403aac7bd4e207696146220c8630f0de095206e2f4be56f29dadac9dacd179e2c4a7942ab1517f8909e43b2f2b7856d8d1c52ad174e75d25a7457c55c65f7c0214d7a1af792bbb669ae03813643bd8f2687a9aa96f143f884f43be43e7075777c9fde6b5455d7e30c1ea02afa54947090806a71dbc08179cbed0673b098e457b0eced2dcb1752836bf5922f405b2a28d5519394db69c5872c0e9350f5d464b543e5f018faf9ba6678e3b12d896afa523fa2ffb42b82898d652eb1f156a286a28696dda8c8e539e95c816101aff5b0e83c0dd547ba5adabc04288cf5b08a3d02500bbf392cd8cf57ea37245ba498f3bfc5219877756932946bf222d9b0ac34fce1549a8392d523a2453b3a681550f409b51d5d697d47635d2550c805f3caece69de56c1af8f53909e40a11c3d0c21c9ba275b0bcf2a4e973b75a2a7c95ac357b82b8280344d7c3f9c7dc112e306e35f2e729dc2db5c52dc79dfe9c89d3bd76f752e670a606d20e0ffa4fd998a34b6df31b33c9d50d759bc5377f76f692a94d49e1679996e60107db1c97fbb718faefba8465f26983f5a320714846f6981ab98cbe6e70c342c422445ceca274372bbceccd2a7d1e237a5931dbffc2fbb52bfa761c9c26d2bac70d23cbbb54fbd67dd50fdc109aa86b34108c9515a81b32512558b38f48c34d0b951c2c31f9707edea72152d22f9eb1374f1b1b3a2a6a5ded93e3c998a54360707c4f657d7992e708c7f3168e1c8905ef483ca1b667daabf95a036a83ddb84cd922e08864fd972664f7abf0cd70a427e88b5189b60a3a289d607ac00429f5c18fe65307c1a1fabec239aa036fd84764edc8bac4facb69f4be4441bef76b7a2b682de2daed3c17ff5b982e2b2ad1275d770b77908afe0e833f0f551639facabecb43b129ae759ef6917a44fb45288cde14e2d3487683e8dfd96318b2ee97302dc0eddf137e2060d334c1c173dd974c3635089d6ef56aac4f3a79c9b35804c9a5eb25a8f541f0be35b967fbafbb653d8ce37d6d4acf2c94c338f7b0844c6b34c25133d57079b79d79dd92105877f2d03d2ca21d9444c32fefbf5f0f65096a74fdc4ddd73ea71dbac878d7126f3f559aaa0b61ba565aa701678b6eb64272fcc9384073cbe976d591694cb1bbdccf773e0717c32d01ff2e50a797f1c7641cd4b532c5b8e936e38eb52b1aa44c35e85e9a044f55de3c70fd9295ecb40c01dc7a05a2fefa01e5fc54794153f985159f9f6ed4f171fd2d7022603c7bad8d9c95af3ed9bdb70f08c8a781d761f985e68af702b5f0a8fdd95e963bbf8219f388a0d5c3faa452f3651a8c66cc72f9f14b71ed1f246bacdfd62ea43870c7e2e37ec245afc79abcac1324c215187968ee47a2aa85166dcbaa6e0088ec830f9b96bd9f7508c46860db02afec1f3511acb272ae8b61b7a47465318b7b82edf7cb3a5f379ff7461d6a2cd4a40605a8e80f1ba3b158e418644c30de03e17f54d789ae6f7f93dc2be66ae4a9e78fcededb7818b365ca08444b95ee1f6f2a0f41a5f7cbb462f12ce5d134ad0023774552c2e9c664e216d4dbb04b8ecb1c0809fde70b5d9ee25cba7beaa3e0ba46cbfd936d761a48d468cc5fd058e5f9d0f609cdf4c0b2e36d518c8e16aac81c9a3bec42c7eb2eca520a33d155269811e56716fdd919016e756bfb22d247e78a3ccc3559248140560b95afb225c824fd972a4311c575f0d0a1d7104e6c0cad92039e8bfa3a0cb714e3785d4869184bcf56459fbe735a70d7e82553fc38b65cf64e69cb30a7def56512aa325e97c9e170e843b840348b1b58d42ced3ebee80d3a089149cb6eb5e7b747901bd8a119a7949fa438861385bd1d377e608209d08d6b9f27d5769550dc804457982aba516a631bb0f057c1973916b3ba525ece75645790f36f3afc5ea1f01fb895504f74c9fb6634db82a19249b5919cbb7b7c4fa025add21e21702d8dc9f6f4cec2bcf58b5875d03c4d0e151439436fb808987295d14de5fc743aadaf0cd1a43c9d0f3fbe907567cb52586fb7ce28b2411541990a82f63212cfffe28e2916f173a7a2f622e17135c5702fbec178fdfecb93a368933fe7d1b1e440847f799e2bc23406d983080644305f4792e3d4728866ace52fbe6f6b5d08144a2a3bf0940ad3ace2299e09101da8a91063756baaa900545891bacd3a20fe2bd8cdca5439a6a30740f4e8b4ed725910a7ecc50efd80b5f06acb419dac2e774229618b6a97cdbb596c4cf0f370ce14766d07385c814b07114a247c8415904be3147c9346820c6008f0685468e44977ac57ae85bdfb881492557ec7d9c8efc562e1f40cf46a240a6ad1681fed88d9e274120ca53aa3a170bd789c13b964ae824f0d09b4ff484521c731e53ce2913a1e77c382aeb37b7446dfb8afaa8beac9d03613c81dcd93c102eaef644abe116cbf390ec13a4e479dff193b256fb1a8557268581e3e018588fa129c5f1fa86fb6c05ace4006390ea5bece3847a37e8a21bef070a2be805d6799b84bd6936f3244986dd00a20705df3413a0fe70e1ad5ce4cca684d3e98b7fa473c4065fa9571bb88ec8ab4e71791f386fb0f22f3bae09b9d58642adb374dca82e244c595043089ef289281b29c50f81e1da3e54652ff766b1edd893ef030bae4cc5629bb4f0040a3f4115d142d1f0915d252b5cdf62ded8f174bb78eef95074fbb412213fa3ace8357211fa42b1f0a97b693ed5281364706ad4b198b685071f51c7f7bc2a423cac948d9cea2674b36d7548fec6a1ecfbc338372acdb7946fd3b09ff9e7569c07c90ba822324ebb124e4eb8d5142984637c44a9d6f62f641c84b89a074fe49d3caea1c447515b2f5adfc38c3f16dbe861c181a50438da621dd63331d92b21bad7c4980dad6ac1a17386760d010704b2ff02c98f32a4045e7f27a79aa2016ef1eec608a5aa26be54e5975c86a8f558b82463d766f3fdc34944695e1b00ba4f24dc6c95df0cda5521fd94fd6d7de850fe5e35dc69ab858c761af4c18b874f3a021764a91d8c7498c37b2bf436fe360c36c72c132547626841a4160af37c7d4dff8f2a0c15c171ad79045cd098bb63424c448689b7ae6da8bd50cc4d6109a090a9ab3cbdff677404c3a9106fe16e53d541686a286b085a125c537e22ea67f545b29d139df004a65ff7e5b32f628c50c120b906dd7b4be52a28c470ca1aec306ebed179ddf3e72b22d3eb924a5ba71a320b0baf4d1f640f483f98d75291c2e3b8d2f8dd00ac8bc096bdc7a6c2d4cdc952bf2cd323dfe7c1f49a6a0578812e53f6ea8a97e34aca02ffa9b49b01aad3a1fe37b4e265ff626d1747dfaf3629d57a0fbf75038c3a9cf044c848fae4e75f54c3fd39ce646ef9e2b31a32d9092dbe3b66bf6341b3f0b0772477d664122428652dcfe4b85f9ee1d3e255906e1bc69ea46a103dee3183830e1bdc3e9e0e9b9c43207218fe96fa0c7d593779c320aa903e29b5ff78352b74aa15e4856c037a325646d387baf91319af7bdcfcbb61907317ee2b38c4160ecc79a9cce4f66ba3e0623a70d51bd045512a81bd45924231abdb691cb6709b008aba478fcd8e16505df4b745f9461aed6a42a50195abb8f8f42015928da63c2cd757d05085599f5f1091b687b723dee59f09f770c0d0eaf00afade6e74df2dae1ea3bbbbae9010e10f9915faff919365245abba58d1aa7fb6da140f6abb2d8028e031eef3604097d99252600bc4ea2600452ebd2127be93b318a30aae2b18b1d52a47d86e13138cff0412d9977c512e4f6f293e294b31c532b7d99624a054d79eafad763fd00238b59a8a4736a51b76db8cd59f3502b61ce39b61c7aa586bac96a3811d7a423fddd81ab9ab919e32608b361c4ad2675463dd000711db468484c9af8a2ae4d9f075fec70582f309871ece865c9d92de119caa0705e0e298138d9da5aab6535b9fbc4a85f3e799b29a4703c85e6ebb0950108efb8c28431df3b0c70a556fee2f48065add4339e40472d044b98b17098501c6c321bcdd0f3a509e13de06b1e753097b64bbeac60b3fe824c3a72b0000428f22fc06ba23458a4ac4b39dc1a75e4f6c98dca0810dcff8c34c4933084b51bcf01699d453701ec4d03aa5201abbf3b0a5fe426dfd2535a748b86b24a727c253594be3f306b22c3690cb23fc7bc2da9f85e99dfc5712df697df2fbb010a838c7006c9f9229f2c69fd26b3906e930e472310be0107aec1207545e744a7b1714b1bdcc00d8cb4b7085fa824600277d578418e4c0f13755146eee43472463a9fffcb6753e25eedee6f89f6d2684b60a316a68f3094410b6d0a7aefa0f682a2ebaf30193b130bb8ef7a3a9d6011f529d0598c67652184cdbaafd332f76f8b4d9a2bd408d533f8d22d336c32dcb6e266eef4911af60d4292a87d023c41a27d53ee581dee715b1aa0f84e6f8476464a5d9aca2fa215a5ddf91c8a460f77b4b96b065c3ebb9c380a9629ebebb47719ab16b08d7aab944c65754407a3dfe9d124aca87a1a7707c4db0e9e50ee19177b51fe869386713e137fab088b8b407da18736cdc849d7794b09c09f590f5c13c142a69ae4927a957dfb7287d4cbc6b5d8a0f3a9fa3475adcf8c96752145f92239a8daf0c42b2b4fed6d4e1b9f17fda3a7510719073593f95ef372457ea6cdfa1a3f55596d2f43c3788a165242c2dc2cc106f936f3e888d2f71bf20ed8550e18501647204063f5ae0559ce1a3ac575ad6f97ecb0b8e769f9e746a42ad186a501a1ea5663b17b38c35a7ff10fac8ea95c345bd3a25cad24130763947773a75c1d99d37620652cf5fcb7e3ce40dfe893d0c9acb54d0a5e66dddfa61aa74bf63a6648da37cd0277a63b1b77f4b34a5564b7293c494d1d40e3d1837f4e9ff744f67a6bc24f7f5fc106574a50322846d75842c80e44718a5f039debf80dc1bda51cdcd81ce9ecf4cd0a7073c7647ee790a1575ed78f6a16867a947d64b50055210c8642d370e7f1755131825ad71d9364442b7520f7b42accdab7f3b76c0322bbf3034d0511b8ca11ffce09f849064b0a3834bf4954681869573c74f136b821299d4f039cec7079f2fa5d761c935d813207d1d12931b139576bf37482542e47454439d6a24a56c252f81f2677055c0259b24447cc4c153133b059da8786adc46005298b350048d4b1c8aa8516ad2c462f880e9b5651ef6ae48a3de2559c2ad9e6381c46e60a7889ddc95f60a753484d0a55a84fadec0de2a09e9fd3c34431f20750702d804d3ed8f48e5bff2ceeeb235018b78479bc801caf75d93527a01a79abcf97d3466492b788e1e4e191300d2e2603f88aee29fe6629f71b28356939cff9567ea1a62f6c05ca937f93202d842bd930fbad0b62dd336287febfd3cfc29c4f8340597ee9316ffc107644468cc3ca9000cac0c8c64a2aabc80c4635a52a4bdc63e4f1587a480f4ee2c679f25152fddf5ba775d59f0c92f9b5844f6568756deed710d0326d0537dc9f14352d358f85a8a24c2a36ff55c7e1e92208cd500e569c041a91c9c3dc0e1c5f7f58cacc70f3f006d3df4865243bbf213dfe50f43c061b1f78485de260c4746f606922cbf04e6dafea0bb864b77e4e11b1ec9eebeb54e63b342c43c89391c85f28be5634804df028ebea6a566c8c4227c88c70312bddf36ed39eee53b18664603df207cab892da8dbd5d52e6587e92cf17d0b8266ea9faa57d71fc60350b74dbbb1d6f7de76644b8ba08ce4f7004ec60c730c5678d13e54985798fc9fdf912f3d01fb514e0b5164dccf32cded32ed41e0c4d9908a4876c3d46bf5ce60d15454394bc046f9732abd7584baa8c5e6a3d3fd2637e633f7ba46984d495513faa923657d5ad4fff86d69232a9765aab766008de3528a08b8166c0c4950992b12aa9a3e6417f67a886bb0127a70af7e170f69e7aaf7ae6467ac8171f260dd27dd696c9cb3839acc8bfbda11ce02a65a74b3c12c623238d93e2b58ac2d16c7cbd33843f3c09f824441ea9d4e50b1df49bfd04a4ea9ff189f012dc653ec611f53d460a9c477a181de8149a582775c1b40ff7dc921b86f08ecb6398ce169eaf9c08c990dd6f9e1851562006ccda0a5679c1125c47d42e3df482b280385eca0c9fd662ebabed0aa64d0d20898b6c06358c3557d3db746b69551d2cd6592132c6cd07dfe693ed093f5b68a04edf784379c158d30c61808f1d89ab50885c3b64240d6d59b7367c4c4c8b37dff751083604128ae2259b45c622dd2422b166d8250e55208952a4d0f7d05715d19914e1c95734ec3ef3e9305fc46a56d63426eac4a27d483a976f58f5dd714b68d3706ef9acec982f97947ebb279d0aa6ffeaf91b9feb030dd17da196eadd0f51db456c34b59fb9370ceeb0bad7aa52c0e571618464739ce9c7e0771489a9632240856825609f107d04a4703e56145841ec11bff8cf3c7d51af74a88547a49c9795e2e9e7b276b0ec6c92577e4aebed48af7524d735a48383e8d60fce8c5c4602a74cfe2b3c4a080983e7de617f97cbe94bdb0ec9b501249a73f996c8a3c306e7eafc4325508dd5bb4a6ad13c760c8d8340b7ed7892348d713848dd522c4a907bab39097d04207c6fc2977242885a9b5069f9e4dbb67662681212271722f15e67c2bac2d7ac0852ff400ed8779e276453d965b1c3e0ef81b423f2fe10e6440c2591d73593ac1adbb06c93e7c3fc08d57e5117d8c3405e647e4bc83c83070f12042078870d073dd3f6e1ca1369f9adf33ee7c7ba2fd6a7ce1d38a86038d8d7979e9d13ff140b25a005857e9cdd4c500a44279e0e7270caa5acf288151be939a2c23b28af1755a05ccd500402db03cd71876eda53074ab819908f2e16c8395ef9967d3dc8bf4f07e0b87c095f4d6a9c12ac174be9710c275ddcf1c9352fe67f7f7a6c6ed002a7e782db03e6f3cba9ea482a1e365330d389b2ecf4df97cb253d746a0b31c48696fee7ed0f3a01af9c5ccd11d388828b33cea00d8b01343d0d142b12d948a3f8d51dc40facd850b0df47df235747da94f62267326eb6ec8fac985d563a1523e9af0962164478c5f5c945addbf797e66a56bedf154efd4eb03f0c397b93864896f2ac74655ae6697473977258517090b9bd1ffae35de28789fdefab347a84fa917f1551b0823a490287f84738751b68af4a248ff93869445a3ba6409b72c7230cc4310b0ecb6b2c9edd3fc5b592404c11bebc43291af74a0bd46e50204fa051f743355e8aa68adcad6b6e203cacabd098c33940a58f8f69ac69073defb0d4a31622a394203b94adc5d8e9e8c8f34eeb9e7c89b54955e70bee7698ddf82eb27c0d2df48cd22681c5c19665585e5165dfdeed5cb4858d2b779cd6aff0dae645ea55ac3408205451bf8072dd454757ca1166b52020adf948c7d463c2c1650253fc8b04b70cfc89a5675aee38b50bb48076e4c420abf2fb7a13c1ba41410afb4860b0d45729cf4f07e63acb6fa747311a5f1d89104a3edc5a1166b20f32c5aff430a59142551325e906c4c911b4481b7f0101e651bab00c72bee905edb9f2f6ad432054aff9c4fb622d21c915804ed70edbbabb0dc569e91eab08c4cbb0e3bdf4a2bb0cdfa234bb63d42b5c929358417b2c6261603f45745d105b77c3ecf8cfd65aa3bebbe97054c87a02685c828e26c40b71bf3f3976a30a71055b183b2db66ce29d4abe9f24b1bd682f6f19f362bfbce47c699aaa981f6065892e8cff7af48bd719697de3102baf60bba7f57f09526dadb7abe3b951027249abd38073adbca2614b539fc192c50e27408e2e4396862a9f01bc151c4b3eb99feb9e43f1c6365a2a3f4e0d9fd7ae58c19b7851404a1aff11d06b7beb1a23923445aa9497bb03c65acdbfc4e701db82fad40cb1691965b5123fc16a6f1eef370dab1f5800c3d983fe2eebd8f3a5f6490ae725dd58edb8bf4c0df5672024ea51690cf01811ede41aa770259839aa61e399ca23c28971969db6a6edb26eaae0ff0492ebf6a45c2a1c4329c21f9551ccb06996872d8d027117d7928532ccb999ee9321dba7406793543b48becec3576e0089a4d9f51a35b33ad52f59f4c4db1c7150799a2b6c2eae4d0f4d68e88cdcfc35f9f0924394f19a0671f665e8d21971fb254279abf2f45476e72d0439a484fce03f78052ac46223801141ca61a58962af1bdc1a07c4034b73f00344da4646c83c97bcb18f5f46c4c15b0d34df5393ab8f74ef2ebacea4b651db08ba24e12bddad2e8c8576b1b92c11e13b3d8ba1abee606f813a6ad893d5f06b88923c1820d845ae94ff3bfc9abd569f4592065510757c8866299b5a91a6d2137b8c66edb83a63eff05e644b1db78ff56d8b374de0a6315efb80c396e4aabc3ea8750aebdfce2a1b34f2bce29e34d6ced4489394a64d907ed411ddb363a5581818a8a03ca6918654f7d8e0cc1362da3c4e85764127726b8eb15e3f10c856fafb4fa605495b77942164eac5e329b1db2f422e853883a2c68f915596a31127db5015244cba27449255f3d5b55bfce9f9a185ad4cffc3cbdef7d5d37b7176bf94b5ed01de03ff48b962255cf169d88bdcab72ad054ac391ed40563909152ed5aa56dd78b3c1ebd5c3ae8af8df1ccf921b7c64126f07db2626cb52fac5b325df1589683b43c492089147964ebb6ecbba5c2d84009bd5dfa15e0b1b63e83953d51f2501af14ad4304e91859c181d95cd36f4c1ac98e84bf33852d9a0ab05819501db4984f48f3ecc73b1cb126f2fc63f02f47f6d29f2fc609d9a77b8263402d643a1e36f361f499df85b82ffa10d687618787a7ae039faf9f5a1ade8ea772beff19182d1ca7d2c44c2f3be99d79fb1da0119c02e2099dc97e4e73c1d3572031c9ee975aaddbdc2f69eb78cae00ab0b3ecafdc33b7d15ae0cd28a141c8f188c63423fd40f301c5b83d13548f91a0ee49f3742f995dccbed2e2dfb551358f6df23dfb321ad841202c371be6f4158c16f34446bf82a10ff616b469bab4884e7294ba07aeca57d7e3feaeba79412666aa0f47dc3b41f7fca3b114581a3663fb5888cf4c8b3a2e2edeb0b2cb127a5a1d77b2a82a4c560c54b61b210b86ea7085a84f4ec91b789884596bc46b81c8a1ee9884e106e10a9f01baa9887bbe016406f23af731ac7008d9affceb6069463e9cb5a4688b3319e22be99eafc08328a012445e11e0bf898d677baaa781b1c590ffe41382ea53fd8b763ab2623c56eb0b93976b8050d46be89f9c98e4d8989ae84a8712e0c1135c10ecdda63615f06636241cf51c16dc602c4f3242b8b346e09b5674e0da1c2cae7fefe519e82f770c45b74b82984026c78e6d2492e88909de4e0edcec3ee00d33a1797fa34908fc4434c2fe30a73f765302c1afc35e264529502e71e356f92dd7a9f3f5a457975576096cd88c12bde337f644c741477c0c47c17f54c470e3940d9717aafd920937a5605638f92c0508d8fbcf1325975d6b810ffa8b124bef19ec632ca8003cc166bd35005fd33d4a6af11be73fe6054ed3c13e0410b4f4db5d2bb43d424e676df8a4e7936cb7c997d0e471adf2704d05ba88a069df9200fb013ad2994ad5fb9057059cac90278ace4624050668fa991a76da04a484de7184ee376b0686820bdf7f45f96bee15ae140c92a31572c8f8371dc3a76b71ab7d2f1e7405eb124530853a3a5f454b77d068a409754e4b9d85bd0b7967f4884adbb20e1b43872ff8803fecd62d7f629face7b52f873272de6c7a87b8825a35f67eb022034bd3ca5a2699a150f3258b722799aec0c18535f3fa453f2e6eb781ed6aface67c2b1a2d3ec238abda75612ddfb13682466235c0b3d41864b7d264d7e6b48a5872c4c284d872fd026066b5eaba6c919c05008f5142e4ba87d7002ddbc370e310948fa0c16e866fe95d1c064f245b5d0f74eb0a871a469ef706a084cd549a6d16db62d8613f799b50bcf0b127e56985168c463af9cc2c5a6f1bdaaf820177e0c8b03e2a7577f6c0232a8473a97c3ad6355fc9179d02c73b308af19dbd24ce64406666cca46d7fb747b7de75831ec239e588ba7d927f11f074517f62838c597dbd6dc250168515333bf2fe2699695afcbb3407d4846f7643099479dfdf42b5cbbceddf1f40ed0871463c13e639324993fbc1b65c8f2d4b99b1dbb0f6ad302e75b7d3379a46ac3241d379e27828c9b72a414d27dc6364b75ac01830c04df8e72cc436ac03abcc585e86eed3ac747d265f5fb8ccd73bcd222eec7bfeb36a03157e1867a4aba0c5f461d7306311896534f5287f04b0072dc62787626912ce1eed067a3075739fa61c79cb352226515f23c5a068efa8dcaa2b796774712fb3d59a447efbc8c1fc084e4a337e58f41d87c0285fd88598a5fb600267735bf90abd4e4a2df86a2e0d3477f43778ee8ad33d7c902fd5c32ad8d033a69b32d45331941eed75310af373769eec9bc0a4c32302c368a6586c34d87d284dc733e17f2c73b5faea72e582e45747bc343f077d85ec5ea1db3c03fbca4e6e9b2bc422d703e93cc0506b66d60228ef3b1656d7c2272101a56c29c68434821b357673176cb9d57e845e316b31ace6a3a0c9f381211929454980361b194c204f88ff36fd8f25c6e0a108398c0996e3f22db563aa99f0d5daaeece8967789ff118cb066b7dc3a448654be708d0186332b0dd995193b96b9e8ca9f9af8e2ff2123b256beda80732cd17afd3c91b15d1b4e826bdb46566977f72fcb26aeb75fb5f7f278c1efe0163e3d40b5780a31f2905c2dc0ed6a6cfe305362093ab98dfeb374ec774830d8dfac3c1d7d2d0bc729ae633c5604e82617fa674847a53d44e36556d855e275a85a2e5c0b0cbc15bcbe56923dca8a8cabb9b924c8fe037a15fd87465426e657357e10d1cbbab820b8127450a66c2269c361367c8538f756c281bd444e2e68213c5966b6302986a1a23b9d1ff8d07e1827fb507bf09d0d21a0ad75c49079f4f7ff6d4b18f43fb1358a5e87c448c1e11028c9f0d4ceaf9c1426fe88ae6f7d334710299e8f58e4f1b21f5f7df7fc4f219cf373966c11d4b2927115a366bf14dbdac27b55b0885a55895431e9f2483620310ee27c5afbd6333ef3812743df679a135e87abace80d222d8a49a7231ed0bd4dcc6f238c51050d61d7c59ab062c6948dff60f8dc6e53438fe94c0b1e1f06098e1e198f1ca920245d8a2399707e4cc60f5edeca006ccbb1cfdb9cd346e16cca3d253a07d285c14b5daf963f5009aee16cdf3708d1cf1db880560747c5f761b632fa46f825fd54aae4d79d9491b3cb68bf6ff7262f3fe662ac3caafea57ed2dc1b7d97c78c249c972395c9a2b3a5f30e6b164b49efa0372c4926155cf23811e51fd9da1a30ab8eb9697fa5492883d42e5d4dda9cfa2832fb91d44203c5099ea6f597d33386e0485412358e1cd10e294eed857b14429f820cffee19715f0bc61117cd27d8ac07637f574f19684cf53ff7c58dfc5aaf7674bb404507c6d4501089e26c1f727dd60470a303897bd36ffe13abcf2180a0f3e87efe1a75cd1a191293dfbb0263d532799b5b780e79086312e3d0f09f97acef04ab54243d4e13fa6feff76b0bde6778240b88acf4cc92b9361c4776796cf180c03b068c9dbc43972fa126d03d8b85c931b76ca1d016490bf77d2505abfdea4f71469d54c2b0026329617ad55f0c07830408a6f31c7f24ea020a15e8c652c164c7114876eb4d58bec01d353e80c3854bd2e532bcafb26fd71fa75e3a7f42949147adbdbf95f7df539863b76f2ee51c428335793868dad99ef4687e5bc609d8f7f492911c854e80e133ee133d6b864d31de3f68940fa4dba8e55ccc2fdbcf807f608a55f64c61d8bcb28188b47e117823b64181baad558edbf4850a8685beb2c88b92299a68ba0d490e985124bc506df2a53cf7fef8a52ff6457be5d34001e5adcbe784cefb77b27199a42f4e5eeebaa89496152f0e791f6962389249eaccd09f5c8487a9eff35d92b63d9f4a0dc7f469016780919335337091f84ddcaef0a811d04961c9ba81083980c9591fda4670962b5a04d2edc47e92753560d2eb4ec3081e9ffa5c7af18f8140dafe99b069e5e3374010ac6f89aab0dafe30e5632236bdeda5676d5f80b246b0f99d59731c7f46826cdebf2f4283bcaa315e48a6cab676b6612a3915894cef3134a086400cda8cd7e065be13b510cc2f962ae47d22d2857b938b1ef56848e977888e2daea5dc244e7d4c8f597d0e45f35261f2da6f8fcb414e70b7b73c87d6538f9c0732e1f7fdbc4dda01acb9f8c01c61164e80402dfe70e10a25362a97be3b0a4c719987bf40e0a870c2eaf4fff153ae0bd01aa79d939f1aac0018504a00d01db9695948aeb7a5f70a77a61449be4425d9ef63901d3c3c2d7eab06539aa01310ba7a2a8a0e8e3e2b4bded51a3175c66a1d4dfec4ad5ccb9047e38884e2ee4e4296a88b19bfdb899768ef5ed189c7b2ec8e9604e3ea9c646996c89179b23908f1ac2a3b9ce91e51b136248a398345c6e29389daa4ea8d8132c01fe800dc7471dcf4cdb98dbbfc7ac36a2e7b24b23ba0298da9243231a24888f62870fee2f7da0b15c2d24c130cd416d7b28b3470737cca52a157d3dc9e36887349dc8a6785da0b06d6376b89924384e64116abd5c64985f64bd4a1cac192e69e43f12b88f8889b665626047250fcb30eeb5f511f11af509c5a7e79da1fa92c7e16b5c98b5236759e0ceac9e3a9d08cd4258c275062cee9754d882ad9f295669d1401951092ecf2cb6b3e13ea2bdefa66be00d085ebc70230f889e50281f7856479fae9e3aa910d6f631e1ccf1f0a4fe56f672ad86c1808ccb8e4c5288399ea0e1c543760d8c1582b40a12a2ed0ad7c9eeea4ae6abd7baf53b263a3fb420974e31f8b003a489e2526eb52c4011dd0add8866d6222c136152847e90e0d56b7d02552e6d499be43279ce714f6ae9e144838353cf0cfd0b3689743f9927bf4a4e8ca9602815859fbd8c5e9a5e68ec54db11f14f1b530a13a86ff60b8bc071d53ddffbe8fa60b7adf6d1bb03c6bf320226d0a0ec6e3b9e7dfc107d7896cd1e4ae08ef41d10a47af57a8ac91bf426098728bf39f4ba67f54cb9919c3503d0fd9208ab21a0c65e8966aa04a4d923aeb979ccf96228d48ee577e275c4ddf51340e37e7d0189d5c2260e3bc50a140040361eaf56d43a0ec037c3abbc3a1e62d596e49e3f238315b2553ee811012873b671a9d5534620cc17f16e2bbdbe330c1a171cb7c7eec711aa74ca4345316f3ab3f031fcf3ae3d55fb145cb163bafc495c43ec06574eced192488dc2344a5acb7eb7e1ee4f97b5686ab09a6ac99a8e40b0c35311a430dd96e5df3f6df55377f9e43506395497de7d49bcef822a851417135ea10fb5fc1a20ecaf2d76b1caef77c5626450b1f63c99f8f67118b31afb91c48911e05a5c8169618fdbd07d8e647dd391948183ddc93f2a4581f216dbae11d2c701be1f00645a3213248ab6202d01879cb57e5cd779c72213191cbd1726563a4d1e1912ecabef093d0bf8586a173d76c19c401d25add7e654ff55ee5a89543f2ae8ba7b9ad93b85a149d8840fc351b39dddcfd08ea07569dcc4272ba9bad82e548714246826c63e67839948202e1614eeef8ff13fbee7d72128d8fa3e44386481594c6a405add480958ae372fb393774fb6aef7d63876ad9ac252d38183d9b7b2e250293d27787189e447f3adc239332db7852f95bc3806a2033cc88c50ca0563ad58f4329245eb6eae39a81e6587ee3b635a45909e52d7490023cdd67765d26e97b8591eb271a63adca3f352fc6b22b90340f97626661c0698b81795a8cda36f45b39b6bbf108d916e7a5d1da747ca4c63a6579bec46b216b3e5c610358405d7a8419ce1c2025fa403e9f7745299449e3f27415fb81051c671334ab6f44c74c57a80f7b366db2861978e188a41617218fcd922b05ea19ac8dfeea35d68bdb04a738a2928bf74dee13548f66dd2d314a41946a939429cdd5695b8ad4e842999288ede4b35f1a88135223638292bcf1c13becf2d1be2114c3cf2ac42aacd26f5ef627a7449f8edd0d48dee11e36de33a5a8a8f697e0fba1d57e69dbf7d3af377b60e7c1c1e5089d0a758dd85bff14a7b9a35bbefed004d7b10abe7a0d73e0ed169d25cc534ff48765772cfeb4aa2eb2cea86112b78b52f9306025fc65f6a37be44b7f201570c1301a8a52bf59d66eb559b35581db55d70e6fa08203ffa8bca7afb35e639b1cdd61fbe1ded8725bd1a91253ad8c60ea43704fe2cb6ee2f404bf564686ea0dae53584b95bae3f52efccdd9f53ee306616c614676deb263b590b0c450b2eb772089e15ea58018046bfe7a845c269d8c437f9d5c1f1527105c1fac030df4d9f1f2e37dc998dd4fa8bb2e874c630b52af06c2ef14890374ee86356e0171afa0fc14b2c89f380f7c8adb55c54b49bafaca0f9af74eface340ae98f51d2e07bb0d95dad1b920fe68d7ab0c3a872b5dba23c4a1894c1d75ebab27283515e71ab5321465745d47064962271d23b7962ab534d6a268982488884eec1df8bd130bbaabd86cd37c7a5ef952a31950d7f090f480522f6efbdc836f057fb5770e4a6c2106b04f305f584a95bf46ade306c7417e3014dbd4312bc6619ad5608e039c3d219f3e2694c5100cd124c4f7372320e0ac0c3ed2690fd35eda8309d612a9ec08e7d54a0da963bd95733a1c2afa3adbad6748897fc44dadeebc3fa38b13274c78c0355a270809f95c5571a51446d4c79c66fa921aca9b793cb68371e347666ed17134f41976e2e59eec38e77d24306fbd1d4112e28486be890f09777d2db6fb1ecf553b7a830611134561c03179a0f2fb8fc82f3454fec269b35ff73e2fa552c453794ee0a7786bcfd82f3801532f941a24752e4eaf8f51247f527b219aad684df76a7ea177d9e541d1357f3716ccaa31363d287a2d56bb23540ec4a73483a3d2955e606484d7d3300135cd51d202dbd7a702c6eca6487c16b6020d1c856ee0b86a5a93165858dacea0aa8ccfdf873ea989cab0afbe9d0644bf36eb2602c3b36bc1f06b9b65e84216f613af46022590886de920ccccffc37a032cc24529103e45bc41cca1e94f7263413c3698aebf9a972fa6665cd64425c9da86689815328d0b5d77320181a71129483c215163f992fa44d8ede1e52bfe1f4a77f30b5650fd89fb855fe5f2fc8e2a4bc76270cbe03d7d48d9ff13fcb06729336145f26a4f160cf1ec4dd0b76da3e31faa3148ac63572da651b415fd33945d1ef63fc977480bda686f9a1828821b69c5b1ac4df59ff2af3fa43dbb9839e7de4714dc34947b74e7eda5b7fec78888211b217a2d9907c6138a659c911e5b78e40b9f78e34194db87130c6245b9fc8e8928c57adba52f22b81f18222fb088569f782f19efbab9b266d169b0de03a5040e2f1eaa232824b38d7be7b2045096f26786384729e657659b8ca8467df17d85cce2481a81cf97a99ca41638e2bb47ad9852d323a4c731cfdf8a293f5bd87928224b1e20aa915308d28770cac93610b17481daf4cd5a5a908792ad3e0004abd06f5163103422db36e1769a692b66f238c2afd8dede159f04f819c9bea831fdf265d8c833d946853a78e7d135a853c0dfb9aec77931984bb5a402bb30a2ebcb95d96fb48af02cac97ca3ceae791ff14a7e308bb64d80be5d1064ba55e3e73825fff7365f4f387eb76d1b38fb9807aab0fe8bb22b2a5fd9ac553da9b47e88d268d9c8a582240927fe724a686d3e1b9fa96fdc8d549e70e92c4fd794c187840b4179f1b8bdedf0b79196328651d5864670912ef14dbba875590a03fb0a3e4d7bcb174d07817c82770d109e38e3a9378524f4655cc217894da8e73c10e368193ef7e68f5407d4573c269d608f70baf10a3df567a5d74477abca68e8a58e39090c066c961692d04b3f7f92f67c155645a1b52fa52a884fe443bfd63a8dba95e7ec786743fede0a19ad8a3de61f7a93bc7219fded4abd88c65eee348d4abe3984456d6249569e8ada7391fa6c71253c73024d57e786fcc951cc65112421816f5458ac5431813131f93e00ee3c3f8af68ce87599f967bef9a5d95371637316da1fe840748bb6c9a15d8d4768df0c721391c428fea53c6e40f47baf72e197ce9ea18d06d6376a7ffe6d6ddf160aefe4fabfc89de36609f09f376f8769fb760a7be7796841e8ac5acec09a40a4b7dde57989f6aeaa9812b97019d24782ad961bf020231c6083d098a67d7998e810db08f8914ca4a65461c43182866a0614ed1c79cfae22a6c658cb3aa4abac6ea4a4e8b7087bb412fd087e582b94c6c6cc29b87e185ca2ecadc6ec13447a95de0996bc1e1610ce227ad0d74780be8cab2d24272037d8c6d308355018a66a26d65c2346bbad35d79b9fa5888533f5345388fdf670b97ebc8a59454b242913f5522d9fbcc67d929385720ffe4b24303d3abf1736096acb19ef2f04e674e3925808750e4d9d4e561823ddf61f4a800624e291cf17986820b8a82c2ef99c60f229934e9d61f0aea1aae3570ecee2005d7c380fb15e3f8a05d03bbccbd986da7b3f68f28980b64ee5e3b50605ba3d648dc57d215ac609874879d286f018ef2b52ac6b3ea2a88ea05f23f1842ba0b459db13e48f1a6f987a46032018c8f196712c0edba7dd746506cd8c95f6ca045d5631c11a90551e26242ff7adfcc9784a184c1629ca912cd8beef72ac6875fce16b838573e2c6375da604f265d6476957075eddd19b2b15f9ea199ec1d5106becccf2ecb05f709dc0b9e24fb4d8bde865b1697b058b7be0836919c840c3a055cbe8441a7e5ac2efe8086b33235df661d14849a80929fbc8a72d7c3dc189c0bd2e0f0407aff4fefa411f014efe72e6f6025eb18d0383c78127e7bd6c6cd03aee01dfad1ee54ab7d827f46278faae27ec5e0082594e49317544c4e0e8a53e50e035bb91fae904eaf2489e7f34ee00b41828a3fe12f796c83c68ee7abe5328e3391ed327abf2e8a8770d27712af6d67778dcaf66e61070dfb669472821bd011986841942326bc5797480446598c285155233885fc9bb2f9b5c9c713cbb9a55bea0a0663208f8bd778bbe7f025acb52d6788e44a8b89ff9822ca95dcd723f6610be9023ebab2b9d3c8772fc294db566a5fa1f20543708802111d08ba35781d2dc96971ee4b5cc137b37d83c82d35d46f22236e0cdf4c095ba1bc134cd93c1521d1914447e2a6821f32047aac4fde3b2beead1973ee01778a7be5c8e54fad23746d5dc4efbe8f849e411234aad1402d2b2bcdc13f096f5f3430db4c6a9bdb9683ad6b26ade853013a34678c62f2e644bc47d43295ddf06e431ff4495b02e1e02ce6d99d7425557027c40d4d0cffa8684034097db681523f29ed9bca06d1b255ae9b0be50905b4082c30b4f163557f799eb476cb87acbfe27aa86fc41089ed48688bf77fdda763883816dc07e2204db4ad4afab5e9f94a3797079173cf96bd1b0e4acdd03898972c521a57eb8e95f4d23fce4087d0fc9397ab6eaeb453053a59aa0a7d3aef6608b90805323357b3a4436981d6a6444e4905e88ff2f637c6edc7306d34b675a1fc420d58816140215b1b62a706674362046295949d8326cdf311daa294829244d74113c83a302735c5d7f8362ee3c55fe48e70c1412aee1190236af5d4e8a1ef164ab119db50255152b3389295eafb40109f33c23d054e322ff0cfada9f844739d4f82db95784a7389db1d08c4340a293ef9ee80ec7d2e5a93ebd7e6ee45e4c44849b71929ffa8503c5049dce3cd85919f408c43d5494ac4383c0a457ae5ed6d24fcc7c28f1fb081bfa3d08827fa7db89304f2b0131b69b6ef13fc272104a7e0999dcd06d7da51e318bd87e051c3c826321169e5e3c3f45e25b5734b2d19d12ffe2798883d1d714c66c522a62f40bf16e7808a5598786cdc3a94ec81da54e363699b17838a3ffaa40f32d15a2e39bc67878e2891a0a61ec275ed5ee6bd0232543314d34d8f3bba8ce5c7154f0af6f5f82943135e0576d4c35fb56ba28e51a74b3093126c3b61176e879a2cc0b6d98422c77e3c764f41bde632d52160714aca89247c726765c0f7682cd197dde91c27920dc7d7afeecc483b5686ddbd006dfa43ca19edc28b7563bb4f927a9a0924cb50e6fa4dece5fe11352a31525c06475ba305fd3b1fcdf5e7d19596912f5a3fd82df21c867812f73f1fc5f9fdbbea16883642d01bd830a09f588d6cfaf7068de8f54430f60192d265a04416e6c1261e20244c04d5186879ead47ac0e2ae0b13f9c7de00c795962fc50d0bd880b9cac7438b84e259ea733876ba06009259c9785c00adfc917089b97c90b18deb2b22f64a4d137249336dac7182caa21dc912f3c9ee83f0c8443e552c2653c5026f87afc6a8642375f2816772d89f9f84ce49ec6c84b055710d1721b52fcd5aa5b551a4261e7eb789d43376d4f2c18b3d8a1623527922b57c1f727e95b4592bdda1659838dafb49e0b01808b1e3768ea74b4a9191d5610eb4497da7dcb621252a70d39fa4e4151871f189baaaa5254566d88851572f43de82b94d8bc9f879f4d1e278b2ed01c2d7e23f5b1cd7126791aa87b700b21e08d022f50c5dc5ca09cb595b1a94ce1af7056c839438be71d4430f060787ae4e73fe31070cf82e926994582129f64ff52eac8971794100199243d1640a89bdf985692c83edcd6bd6d9c9b1c14dc899f9783fedcebf6e12d02990555c01d9d9e798285a586914e661b2413aebeba735e9f94981f4f52aead84d7d3e4197d05aebe1473dd27a6c2c3e534c2804dfd6f022683861e017473378a8287ab6e9159a5c7accf7421179ff10233f634fdbf784b0ce2cf5e590a04c0cf5fdd93f8a021b64251f7761c63275dd103e7f594383ccb0871471af7ac207f8a50f4daf68b599000b81479b73367decb9f07eccbebc53f75e1af93642a14b69da39b6b6aec11063cdc3e8542dd27aebd1ef71a28777dac22e13cefb79735300837d198b3c49742507ff6f23bd436793daab66ae834ccd9c842b95faa3e2b9bdc91fb031ec45b51adf9b967b2e398cdcc066156dad24415baa1645d63cb1b8db9df72a033b22536e346bd24a554e0481437ef2a7cda36f0019001aea7aa4724711884e79e04698f4aa2ae02bd929d5346f39d636e80781973856fce657c2a712701a0996ddcba0f13a0dce433dcfcf2bf0a579256c9744caebaadbbb72cfa25a76cc96b30e84bb09aa92f497e045f04ad70150db99cfd105fa74151648d393dca91b7ac6f8f2a338ebecce7c30be543b55468a8ce10fe3e871284e11ec79f838a205ca005880e57b0a7789f5aa8d103f0495307526a5356cd8bd33a3d53c2097b509a2cffce81777d089ba72f280ca6fa914e8e09547f590db90bed7532f5f145b75244a4747e1feea101e0172f647c09d67849c656b26475091fa540b6bd74b23f40a6a191482ea42f849c14d6ebcc3e5864c27692734a9571de536472b03f72c56baf0cf2511c3d5fa6eb86a9fab5526e765e244459c16552bb2ab2ee2aed283581f499f6445219859e47b6444ca8099b4f108395f63a0415b21f541cc33f75a3de3e4ae7da8783e61968068325663da7270e746fdaad18385d7b4b87eafd4a3890c54cef251a350971b5d825fdaf1057ec5a5e2c4d2e08a100e5d451b3e305b4cd2151a2d79a22c8c03bfd3cf73d67d7887a4cdadcda4e9c3e645897e3bb7d741b950863b9fdeca74fb4f61012b504797330cb40122cc2505d6b2cb7f904b087d7280f626a6716563d0af84c9689bc008b59a02420d471379004efa5c1e17a6b22fd6eff1bef3d1e06b8dcbab128ef13cc4e04e0d6537383306fa3d996cee9e54614119e33fdeb0752445154124c9a8d419a6829ff44b67d609b6366df3b2c67378b249d1471bbbc272f26cf03bfa51a04148d4d61a7ee3532cef88ada1193cd95792b6b1448435d3c2f37b28823a843cb62f1bb69b1d12a08dfed45fa200db80f7db066243da95b0b3c8c022f8dd844d908851f124070976fe1f8af26c5521c7f0ea2e431815d63cdc723ba4fb50228c921b0cbe247c976ed61d13892ff2fb5f1f71b477786b5c7447aa4ec266122a6824787d07aa4fa42c6a2c260f4f9e3d8b9e1acf468a7a9cf57c981d50295b3b604e0deef9b14a2437b562184a8686f5b5fe6828741bf10f6f0e56239d4330c8f1227d7737d3bbe12ea7850ddcf000cb8800124da9cb012bf602dc81925d3172b91e1e268212ad988af6772ce60db0befc10f9a1e35a1a812dec9d158224c4d8b52b1567eacbd7ce6bf1d6e63d6cf99778a85a08f47c8909b58a0a61c01816e2d04c48818a4c3db43db71dd16ca510ddaad2e58b15c74785217395e8f8e8ab4dd113efa3e84d3bb36105761ffd3884fe31f6b5169afdd5482a504091a11b36e8e6a0eb666030604149318af58ee3c6ea76e7c8e71752403903dfc2a8ff8a4f4db482f2c1bf2ef33a6ef7f18e84075f3c3e5f05d28982e7be98d4cd41ebf4687d3a18d93a4d4a04fc4313fb73c7e48d884655c8242b7b0f63b29280e96ae4c1c9fa60823d1ea63aa91f2e8b7ccfae716ec8c190efc3b891b406f9396b66e896e1569bef260b9e0c2239c7b4fe97050db5c6eaaf14ad3b19ae1e34c0032eb0d641e84e3386a9c433669f2317f294f74022c1c86b8c2b816d3a0c4788394e984b965e9438907a52bdd6539a14300b844fceb5faae14f5ed368624760d9a0164c27c7ce2bf4cdd50c792f0f723b5224fd38940fd843cfc3c7ed877587d108af2387b7ea25b3959eca08bce405a765e8e0a126febace64f1cec1295ff57b23e4806552dbd1576ed86ca09158cdf0dd415291a27c7ae4e7286c44cc66e476ca2f1d4c9c2fe5e9eeda207af8e47eb49c349fa1d40a635637cd87d9a37b3b4de83e333e9c255894254bb42e5eebf6339661c2b565c989d22d386bb55753cda8679341a2e0ccf5771fe685ed3098bf50df6de72a155ba6812a57b17861a5241eb5d31fd5499248b69f5246e0e1a4751519fcff4ee8e5880913ffcb996d9f2aba2a8fd734806df8c0df86fb618c770d5c545feb5730c6c4ba89778093eaa510a63a665764951b2750eb9bd7100c0b717ddea96cc67b2aef56f5278feb2ad2a0753439f75aa4af04489f0ab01ccca4b9fd359422b01ee623dc2a8bacda524fb758a7b288154bb9a8175304f2a504848434c6b90a18ca738ee1a33e814e68ff89e47574fb6a9bb2781d78048d3ffabef74e802c2676e84779cf67982b9a3156be0dd83779e4820c0a710a5237cf0e718af67cbb90d3fe63b363d49ba291ed86b8606819793ac5f3c926d0e5b99f705cff24f6d638440ce96af3509bf4a95f97780cda62cc9dc398547ce7f164e2107cdb323cc18c7cdd69ff7ec3ac18dcb815f9efeed741e596267220a7d323d0da56c7bb9930c4ca313403ba85f4542d69277efe96d9487a41d3759a2872eb2a0bb2b73c5445402d0e89cd7a56a1d718d762d9f58d4f73bca730ce13f92d2098788476bc717c3b0cba7601301a6ae12a53feb6d3a5b18e0d12579e11374a505282a976acdae4183a5f1fc06cacc9eb31c39c795df3a41c688dc9bec99be8cbb6cb97d15ea33dfebace3523264349c96001320a0b5f8fba955bc68402144c44fcf1b4549f3a110c0f07c29bd28473228939789afb3f522bc0c1630d75b0a18ea9e5fa3c010177079bda3ae0162fcd9f2fa1ccdb5b9eda9c0ebf6a64c1855901a48970ae4860069f6016b5f3dc945be0e1348586071b9f569fcadacfcc366a5638ed7a4b05b4e7596efe898c6793ef929244f5ffdc16cbff994cb28dbc816d2d809542031ec0bac19a5c1b07ad5f5d00a75786a3e3452769f0fff6df9d26a7a6758bd6dd7e608f47f061eb0874725044c92d2faedde6c9c125a830df3dfd60eaed8d65467984dd188c8bac6cc65b3bc6f1e28faab2be3275f1e0b0374fbdbacb37834fe12bdf1fabbd30058bfe62a715cb1b2367b101ee11c7d28119e58960b0fdb3babced8cd52c64957e24251535380d6de1ae44ffd8e6ebad3e598bba0debf3fb397cfbb002e3b38a8f699fba30c2b5468d3480845f9e444d5c996628aaab109ab27144121175338850014017e1664775f2357e7cabc263b94bfd7bc86dcd0d37aa536ee22bc97d5acd9e34ad3a76378d8d828e70f58938b8257a2ff84a81b5d5b5c3b0bd0e3a1aba53aa85607b5af107fc14fb0e54206d3ab416befffd248dba3851d26b8f3a754c45e815a672554b1da20cd5eff90b44f86c6f505c35c9d0b1ab1907a9513619b681ede5484e770c9534648cd9b824ad02b6b65cca334eb30111b13d421926e07b9dfc4e277f4e74121bab72e9932279966dfc0855fe996ff5cc2e6c5a8b2b7f67d7d9e30630436d94f7ee9b624deec7311a6f4dd69c60a0049438f9bcb89b7854d2c1ea9d9616807063cc6e8e67c5a85ba6ac79e18cb2073186d1966ee454430c93defd84437f6b7892e80327df9dde76d1c3ae99778d1f968010caf913d9d96bacb49c3325b2f1a34e160f59dd9a6900b3ba79bfb66f9100cafd44cf8eb6f82eb22f2cb6b9964f181b0cb93adf0ebccba99ab4fa5b6ccaf7cf33f0fff08b8dde8a5ac1674191233bb2fde334886b69efc10e93004c003d671e3d9946f1b4404dfb84973db8fbb74335aa99a63090e5f72acf759f873892eb9f01700f779ddbfc482915558e00dfc82e162506accd3126858c81a83d4cfca19179ab6678f08cc6b45164f7de0473e0e28fc50cb0eff86c6809ce7a01e99784a0c32458cec563fa3888ed5608e3921d8133f5154d6b8f53d8efa6fb869bfb8ee41598ea821f950c4417f088db0136048fc5bdeb8c518d2d58de44a8536e94fb96827097633d0ebed6dedb55f412895d9dca2f3907c49eef0111bbae8ef9485c70735c86a5b9542f224a8ee15e7d5c513b71b72110cc1ec27078ec825842b3ce1a8a2bcfbfe0b043aeeb347eb9867f189e046ed441986dbb02c15c20b109fd276004a6619475fe66effc1f53e776d11509bd3d1c7847d4f3d2985669d40793786a497e78bc0be5fa45568a816f61af24126560047a5e001506a2b07b72bffcbeba26c29f67637f0b952139acf70400e5e66a479a8662bbc94919a3c6942b5f34a4f47a5d9a0dc0ef292530dfc490455aaf10ea64456a814f2bbe78754b13a8935cc552454b93e35e22926bf5c8e181c96b6ed5159e563229131b098ce5028475ef294964bf7a7156133bb95f927f80acd6611ad864a25a7a71f62c766dbb20f714c4e7a1af9b88f365648bb8c381578fac11d5100ad4fefaf10dcfac4d8ffed566c607b2a4623dd5b1f5b3c0f6a7c59ec60f158fc5caa9ac0212bd6842bca059579948b352facbbb6ccc3c9b228ea77d1d1bdee381a89751d5378ce8d6473462aae7eead16ac17cc3123a5648c2cf884a418b5493d945c2c5c5aff472d5dfe3775c00825fef79937b6f2ddba08ba1037b4180da0070c5d394954da3c3ae91022ed3c7f40b611832ded9aae13a35c980abf7ffa0ecfbae7fea2753d2bcf88b49b814c98844152d8481df0118675aeedb94ee0a315d0cf18ec522bc3db9d3c97ecf4436784c7e15fe9cf61b35209469b83537b3094b5560933d069f4076f64f6de922f00acf954fa80c09cffd7a8c11ee20160be54c77afedab2ef6f31e62e385bd7da26f08819e7c5e2e0e491746e67970d8714007d24f09200b680ce4d7a5f8edb70094f69ac21e0a1a491d38fba9001ca902f703d3821fc5806cdc39a96c90a4bc0f0e0d70f3b3a1aee1a6876a62dfa9a231a9aeb1af3d4357b8d9f48e5a13292f4756ad35b25c7956850e92bd69590ae3fb9fe137f6ddbd68dce6b2f9c7e16a1e9ca78dd620e5c6004aecf51428c9d2573e09808a1fb335422ab1426f39549b8929b99386cc2af83eb6b6bb535ae82cf11e14432de0ceba15efde58add329554935b229506dd5cd987d4764b0cb131879b40da52c0d8b6590294348b0149830127c014dac1cb262d37a5f08ae75d3079a9a7737c7cec7185bae779c7f604c72a85c32070a4758bfcac24904a799109b81047abc9a2ddf769ec326675720c09c1b42cd4da623fda6dcddb6a80b50035cfacc8a16a62a09ad079a1e5dae7a0c1af78d8e5a682bacd9895a7e8a701e7f69c0312206636d3d3af6a1ada5cd7709aa9f90057c288631ba87e2b0e1c0089e1b460149cd9cb6e5ca722704e6e5ee5317725a4c4944985162f408a36a5b302255e9a2f3110376c20a52d7a670ac4acea6a18b3a06d2bc04d7a0cff744ada0a4fa98c697e554b0de99e3c90dd5e532c568e26bdbc17d2a03bc01b54c8fe57b90a01921e8f6e5543f955a9547153ce41afc19d3c009c7bee7e380e725d979aaa4c1e631dbc5ec1ebef68b6ae34894efdb80d2bd4dde0210b300b1c4e88d12b7bcd9c4524447ed5fdd72003ba0e8813305a904f1a8dc69b0d1032178c3e6717d61f5dcfb8db9386f6ba8ab8603f8f04912c42000ac322cf2ce9b3a95c213335f3f32faf2a899a7a3d08e64b72d614a55ac5ef0225e37287351fad5a91dd66be4e4f1f2ed0d38e2444d3740eecbb63840fbfa2f683c2f8969ed14d8e0aeead796293b40877cae2520ac1e6fe625a188abdf20720d07d2e24cbff477672e1aa586334cd77dad8803662ca3cea61a47161d528698300daa7a071097f1ede3d94d8929264d766bd94e8551608f8f94a800ff46df62f2faa04d879a1b4ed913f2feb3983ebe036a90a3e0ad09e5678b0088f84af04aa53e76ac289ec5eb3c6b2408d6ef83aed4e99cd18d4d230ebe3d91603becc43fe9b521bbc99fee454f1f220362bb0f611ea36bad9da40bfc4f538983fe5a995f2425a7a94b331bbd2ca8590f437c4e8035868d64275e2ad5885a6590b512629a683c2048c48f71a541f464dee60f47049c4fb3a9e22338b64a99282b54698859771767a9e340b3bdce28309c4891009e4c1c725042514c1dc4706abcef380dc3286ad8ceda8c344a7e4c23f211a3d3a33e4e0da2c6d4418871c50c3afb1776c1c87ea5b8c46eb551fcbfba184a26f8709cca9bd333e5a15b65312f82b214d24beda3bc8baeaade69e67a8e5b009288a6f22f6985bb57d41087f70e43970d885a1a89845989d2e1f5cc5818e5f445ab73bbe4beaa91a5199a42e40b9edbdfff361b84c7b7b6529be90a2a6e2958eb98b52b8aff1cc95676c214a932649e4537455baa98cf26a71962918d610eef5247746de422d225baedebb453b1b6c8003258fc932bc73414675f9f56cc45ee9b1bc59783a570bfc5bfbad13a47cb4392103652d67667eaf32a1c5be2707ec2aa46cd5d1c8ca46a07e871d215ecd2105d7359ffb3e2e903ca0dc27ca9bf88685a3078bdbbfd5d2895970cc85a01fef50fa9a89dbde7fa5b8caed7af49d60c5c2c71f0ba52ea1e23188321ae9f0a90071295b2ec5723f3b8d74792a815cba0f7ec7760538ec1dd8ea8112f175c1ba9c535a37a876bb7c3e14fedec51045f74afaa4240d1db4d6bcffa18c4ff1e025212cd4ea8753d0779c7f9325ad1fa1882cd26305946de49ab29bd122f0144cfe81d055fc0b5e263b0fcb0cad934af3eca0252613118ea2ef94f03ae3bf3b7258c4988931ce67b35cae7f4072366a2ce30b4fae1398e9702f90821f56c17d7a8c25ed37f44144460dac9abacbfc1e25ef4ce471ed11662b2c4986e0bb6aef6c80ce7dc8e84e34a2104cb6bd95b3551aa0cdb5a85c29b5e24bc4f8dc371e99274fa272e99cc0846a2f52c9baac0a79f854f0f03673ecea2e2861f431367b2842e513182dbcb82b951120b56d8b0005f072307011c0ef395036697bd3100fdfdf92b2027559d120803e8e789b86a48be1967aa6aa6ed870e820e93b4425639489c5106b230735bb22d0bbbd6977acfd628fae2a4892f03db91722134b6d8220b2f06724bfc19f12d716d8366ebac8afc751092892c32ec0d8e443d5b199801108d19346a05256afdcae8d730f240ff8b895ecd7613f535d30eb5dfcfce4a9f9c9b431b55d500297f360af0a279d90b51c6871f387c56916037cfcfc180e68673c0c5408691922b4746360bb52a2c7dc957ecac372a5057cbf393b5277801279ec775443a869f5207a9b282b030c3f40bcf891f87cc6e5902a3d944b401589f472d9b1bebfcc16c6f4e7762c5cbf6121411ee34f7ef309b5d605f3361a68fd97d8964f96ca913d10eb0282bfb7a0d376dfc0afd008654442a6f1365bcb5c1edeeac48696557a198d9ace88d72fd49cd51acf2519c328c1647c8684569641f0e1bc036eee0bddab84095ac0f18789df85ee0a1dc927bb1fdcfe9aa1aea4e90d6bb65161e68c5ba8443710538e0f173ac1ac55a2cb307f9f2fc19c4d18726a62d1b3f385ca6fbe1e7942da456ddad1c986f8b6d80aed1558c75f9950482d33ef4b42061f6dd14c55f256d48eba83b30a102d4402ffa098573ed02ac6939ae35be3793a8455285ebe24324b34d6ea8915407025ce2bf3553a508334179d9fbb320cac47cd3ae46b21880c18fdc1f9ff30462da0a13c0c11cc8f40f652a212b44874b878d553985799fde03ebdda2f22771b01383758989818ba6fe4409a95459956c9465f08533386f068a276e8bd6452efb5adecdd79098fad3040bdf40f8bbc7609d70bb53038866c4154a73daca7433a553d92030d41efbed61cd449621eb6bc65f7a40e7c9069cd633992d6af370a46559130ac0fa9447f1b1c5c4bbb6c753eedbc8c9e7e3c233b769d3d52ebe3789c0e16e94671bcb87ef6cbf04706a6cf0f88987e5fc70c1bd8ef9630182440de2c8a7d53d3bf532878fbe41f4dd8a97e932fc4d356db387c671c634fa8d08042459dd15ce505eb42f6c9d1f635b1e1067b8abac947345229f3bc14ef5387ae619f27a4fdea2c096ffb92aec3cdcb769b1d1652db878f9b9cf175886add7c2b452481fcc2ce443ec61efffbee1bf9b31245f3bfc7cc451a5974b773283594d6df552aee00876c8de4550d73c09574ae12f43c4bdf27b2077a58373f9ddab469cf5a49d26fc9ed2e8c1b783bd9dc33ec3bd86fcab7b039354a4d251fe8dba5d23be6f2c62ea7b142a73473fd452a573c19a2abe65277744a4fc94b8367ce15eb3f9b8a413d676558bcc528d815eaefa811460de4cbb5261a7fe48f6a7ede4823a6a028f9105637c7d1e18d916dbc3505d1b22e6989ab306cca313038f654247a4dbe27e0086b50cb98ca532e48f65eb857b3ce16051a0659aa77584b18346a6ea4aa04cc0171a206463cac4839cf52488574dc146d930eb0a54fe34468d780793ad547c922f4d973aaa7c476958803fac9eb315069490e5e93010202bb3bc463ad6d6b0df431e99a7af114d4336ac045be1402a1c710103f2e54d565f8c405960dbf5c6118c0a4f8384ecdcd6a2e9ad3f587bd9e3ad42f5ab25f6478138b230b2fdb5c3ddf86b1d71e7f7dfb5f82e9ec7808c31989f975634dc6c49d26924200ac58e61d02f09e55853df80ecd97ce6189d7ade488da47e189202525a605f52bba5831b31e6dd5eb878bc002b6e70b744cfc9e780b1c43d562577f4972546ffe05a6acb5ed8d9cb60cccc50dcb0123eece33b6ff7e756580ef0cc646dc258c3ea6fa289b3f3ad8a75ef1444bccb623207aba188f6b1f3238158aa32e10e7af71eec8ffcd4ae764925d8ceb1d78067a4282cf41ca35d6f9e010bfd6c61a45f11b4792581e0bc17594b950871f9f1d9dee8ac053136fbbc7bfc8997d6064c566b0a5449946ab219aef4d48d2907722056b030e8bab5162387e3a217ed29379d7b266febcdc21420159c2c298c4d1705a46dd41c4da09f13d6e7275b02578c0b5b8301a9f204e100c5824eff16826864412c37e5bf2791f8d5d66d914651ca4c62c157bd175c8be16ee495e1c72b4ac98d5d8fe1e32f251f4a37fb32e9c986f5010b8ac16980204fbf35419fe8fd66d1e2cb71e3f38a294075275b12f52ec8f263f3a5413a4f8afd9161376237d61d63f28fc1c8d3ce877be72c3ed6de2752b6c71309cef7bbd94eb251db1459a0d4fae4588f2b23a0cdef13c494b669124a2f79b981318d9f7aadba6e059e3133f213764285d670208095b5a0e3e8cb20c81bc6c430deaefe3dc89145adce56858484076a190ac95457a27ad912c58d4dea0f4cd6b90f582df6a16d850359130fbdfb8a5b4d536c7982bdf05d188e7284e5529dd5d4f7104ee9c00de32011fb101d364dcb353821c31b2a8409e6a5d5aff33ef5d53d89e3aaff040bbd61f49056f04708f60494682ca5bd8047f5d7c8fa995b04a71cc1122ba3f3b494b74fba42399f475a75ec80e2ce9c68e25969da2e8c3739f854fcf9edeae3fd38c5f95257730b4e4794b728a4a784d707e6b32d44d5378f929d8181af027721736c6c812a23f31a2d96098e9a965fb5e222c3fa8ef67b8218af6c61c33d06c1556d6cd3ea1c6cc26afdb149939f6dba926223f5dc9cc74edb638f0efe57686e37c35acaf33ea480611f0d5a9fa681d29a5cb85fac16ad62e230298cdf828226e861d8cdbcb622afc371373ebbadd23e556da3ee03ff34504d6c711cb02328dc0e8fcc6441dcb96b40e42a1765fbd4dee61dcc51a06232b63cac0a38055aedd70b054e106b60ad38937dc4f58d33978acacf75db422d2b371b3096ea81f984d31b8997d60c19e1b4f9c35c177195edd3208dd5f3f9b7ff3358c970a5dfc2b23d6df307465f77ba1491c67de1ae677bb35cc2312d58cba312795129b28148548f10716ed7ba097abf4ce243a03b6ae55b7f1c50fe2656c8b4f640f9bd286f91caf64c298830837262b6b79d1da388657bd041603eb6eaf73e4287db7db9de9589713d1e126dc41cd1bfa5fc99710aaaaeaf310608e5b52d588dd9272a1bee53cb7ad946dd8b2f89e32e31a7f11f13814efcb406fc8ef59d58928ac62d89c3f5fb033063684bbda268e01ee6a5a9c3c11f6db65e41d9b73dd713abf8e1df39f967f45f6f12f1d820e91ad08f3f2c261eee1072c3867aa289873454731a415846d5f8a89fe5a4dc9a1d079105551b70d5b91847ec63e91694e5e9230828b0e265ac9a389177061f13b82024ae2896918e8140ad7926b3fa395048af6f558df514da39932e9bda91d691595a5b4aa17a885fcc0b80e9adaa237ec06b84c98a8059f2c35e1c1d611c002b6af3d409fef47fb97b1d114e8e7ace6da1620095d25eaacf4592ab2dc73cef4dd2439f1c134d070550b9e544fc90ac74563ffaaf55fc58324d2d0f9c7e56d0efb7c9475d1d9d69c115a7a97ee9ad3d4a846c6a54982a2b6e7fb74068245a28dc97df809ab08b83f124e5987be0c82ae8d8601c5df95ab5f3ee508cdf11111bca2ef87b97c71d935075eb154d8ffdc401ea18e3e47255d94393d2349e5e6b3e57af321490436a766d24e4f0183b38ec5590539d462cfa9d24b5129c4e5c7944da4e8f32c47ee8a9ea464bd69fefc59606180ffd88eb2977949e2b44d061e6f52cf07ac8914e789fc3e2a4bee7213f3b09b038ae9287f07ad0bc0e849881432a06bd4e08e89af70e56aae01f8bc8691306fb13ea3c5628c85e7bece054670ae41bdd81225eabaea05ee88b54e52d0902dfa633a3d839747cfdb136de5b6bfe48670248e79695edbddca585df175234f5942cc1ddb06348db2e1e1589358168819d0280887df1f41bc6dbbbfb886d3e4a2418d7e2641c299e14350864c664d6461d43b263930703f2802cc314b36849eb73f6d93c581137c44e04510ccefcb2c9755aede5b78d44f36e93cac2d30ecbbc444077cc510c0d76a8e06379c787d41b9b2b4cc3734178c7887fbaf52135aec3c47e1d7f63935e724ed3cef097800999e0636b54a4f7d5f934e0495e69393703fef441772958482ec26470cbc228a5b7481d65663441008cb63d31c3a08fc077d806c642cb6421f1992a313b0b1b92a5748d8d3a42e07293a5d21262e555e0fc5b576890efcfeda16910c630b232cfc884b327b989d79a1874e4172e3c520d5d624957ae2667f3aea7b51060fc919334ff9eff50f6d3b0c2e5e368a77eee1bf5b94d250a3a8ab3737529cad94a07a2201368ee56c350d59b2fa8af9517e113819c6241b53c81196ade7fd324e844db9f513921428acdf6b53f3220bcfdd205b8497f0800ff455ea73f043d9dd6cd779a927ad7c62c98c052c8ddd2196d8fd859848b4746fdd03698a5f2ff81466bcf3156c3fb0f4d20afee2ae05ef205a09d2d773bdbec83b04c14da3288f7850828272b387021a52a89dcd0dd26320ff668565befa50e5f149a6dc507d5dde82e637863a73d56a385c81d76e4c08ec6ed68ea57482acfd5d66365b1b7e4c772c21d59ae04ba5a88347d6ca5e7261315c4fde82cc70185ec7a1a50d55862136bfa7f1ba684e070f6bed3f462eb0a7ae93b635d5f7faa3b8b8ba6f804b2e787c70f1c287991980f622b6ba4366f9f4eb9a83ce95e91200417e85b2a0a6923f5b35d295d46a2eba5798825d89ed88187f064065d440558bd07e0cddb81d5565b8cfee9e1434c04d16295ea5b16b53b7bf708f3ade30bd52d6bc5fa937fd60eb093f47b454becde8487c1984235c6cde119a95e6609af7890f02c974429f1b3ff48183f02785864499ba219315564775bfa9b4b8085a8f06bf13b05c25a92e57d4db002be9416b519b48f10eaccb68d043f7153d7a0d28e04254dbd5709a67fbbf5f3b9a09a99362cdc0c536450cbfa27b3c6fa630283fe4b1760ac1d78e16e519aa715c6a7dd8eabca96e18ede2634e76d422ea3222f691bd5b4210884e1c5c63c6875846aaa88738bb78a425cc20de4c526521093b39168bc2c67607e23d5ddacd067f146458d85f35be7dac1f873ea252b2b7fdeb35d7c07b9d07914b820ff19d33cb124f1030e0511042a0d27be2decce0f05a7650a2b3348e9a13daad90ceff7d3fa67116d085ce7cdf8019dd0bba7a8169446dbbfa066b3fda5701845a026b7c01e952fae9fe13da52d4e323a82e876836a39966f6ff966f458b95609cfa9b6ee8e26499c3e62f4e5b59397a5064b424f7d94c083f828e2bf420d821f5f0c2c9de23cec3baed582b8a3de7dc5aa20db52b6c1a2111f05e0cfcef0cabee15056f257d85098fa4dc98b1e92dbaec61e5d6730512b5b3ca2b173d9b86e1e29932f85e734af9273b37972548e746d610439aa6f75901492b9037537edb312f43e5b88fb3136b4e6a62e6c515d2030ed9d075bbabb92ce3cea4241ecb3007b0fbf27569d9b01cda4be8811a1b85c938f3643f8fd76e6684fbe3a89cb7dca8a6d6b03c89197c2709ace1ef06bf119afdcaa1907cf3e91cb0aa3212dbee15f5e1838b6ada57ae4e0879ed9b3324a0fe82415c546144694c6641de364e7b138f2aa716f19f9707675f7df4da5208d58510ef8d4e96f4a85fc62ffdeb243a5708cfe2fa13e27a6206508da88d1883988f0bf691b7fda7b3dfeb2ba04fbbb5c9c63bf446a0f8ec2652c92baa604948e53af0b24cb76efb783ef509bea0a124ff4f1b2b45294706f89c24c4a29e817c7453ec9f9b3f678ed7a5e12b06039fcb02a24f654db6457faf56066a3630e433a969867cd1c604546a1e71dbae16082b1dc176d858449749bb451a90524ad2682f5721e70a1728c95cfecf219213c7eb10169bdebf9b72f3a458c57cbc01b8d1800a73023b90f5f6343fc1b4be3f43702e5a13b42c6a4ac697ae0fd5e30f4b9015aaf647c10608932018220a047a4b766f6c84fbe109f716b9a0a08f41c114795d8a8a1abe27234d0b4b3612c90f3d77f64814d610228c52fd6336390d21afab2225bd1439e1a572c6078e79864e33cbe4bec22af7b1b2382c7bc3ddcc00cbb0fb934ffe3c5a536d1951eef65e56c057d5e97e118acd66bcbb0a1a433b5e58d4d26bf00ba4cc9217da48864ee4ced19fec4946817d28c9c3d3f46844e0362e90514fec4e2a1d32c5d2af36cdf700ba82eda916535a6f5207aeeb6bd3c7276b0889c38d95383916be86cc52cb929eb0d46e7edb2ab5c4c59fc5e41b08823fedb80a3819d0a7a25b15c45200f1f042e00a390d60f78805a0aab380ebb53b9a52c21bed26bd2dc6574cbec5d2719ec9bc9dc9bfe040bb13141529ac2989634a9d474ffdf660827a6b651ad11e10cf567d3eded0a71b23119821c9f9bc4c3b7717c64bd64b3e2a76bab6f2e788d48151c39cbba61d459bcf7e8a6ebbc1440ba836dccc10615468a256c41518f8c62b10e5088d25213e7b658626df57c71c2f21750a5d388c6bf99fdda75cf4b8e30ba3356e4084318e9a93d50d169d63f3c56a5fe714930e2b74644ae118c0aba9909b37ea2630997f6cb4bd8c351926db9e58c26a479da25695169ae2f7338d4654bc1b9082bbb5b59499249dfdb7fa11ccfabe5a9644a3d351ec28e9db4920e5d5eb5720ce40343393677a7ce81a6f1e4c62561f5fe6c7c636e37d079f0a5201cebbda4ab072b1d9bf0ac9a604804fcfd3c798811c44dfd8e72077da2fd7b35bd8fc740f699a2df4c2b2a610b1599641ec2e46c65b7aefcc4fc0fa37c48bd7ad925208bbee2511402a9e2f79f36ee3f182d025bbb8118f9fb9aed7305dd2b6d6e121623dcf1dfd71c0c697eb8f34cd8446824d7a2f700ef46348b717bd3cd6eb181e9372be785499268759cd7bb9f3391c63e4e93b8ff112920fac9eb338ee8c9cf3589c8ca64daea8481a3f39cc2d6820029fdc1a4c1249ee25f06e394886345c4826b1d2934a5cb13de622baf6ca8f4f0468b3c7444ca7be29fbb0aa226ae5cb2b7bcb732bc3c986b6a41c73c9f53288c0135bfbe85136aef068e9bbbdb57ff13219e0d9dac8fa0e6eac1bdb912fe0253661a4d96229c059e21ccb50051e9939d7ff985103c98fc2520e2914a49a1203af4c6a4ea0a197a8737cedd8dd73fed32ff6f7dc2fee39eae28b550b07de0b1ac66002fbf65c6a1669b371240bc85626ca6370ad68017f2214a8c47298c7dd78ab74328fc98742a9f3d4eee97f2ba8f3c731127bf0e68a7df5982cb1045ec2ef18a44c53fa14b45ca3664d06bc2c631251cf9e3545d29fc4dd0108ede3352431a4bf47effe9bb54cb680d2511ed8472b477b222b79bfc0fb72683881457da7ad8f1cd184a822d4a05f08ba7246618920190046cb54230321c0c8273dff33e39adad808743c34bd91e8d42ae9bcfae46d6b99fbc8b8d59bf41e3d6b9c65c9b8d5b30fdf875ed58316a74fd469af0b0c703421f3f6091dc8b351cec14c9367d7601ef3305120fbc354b82670728d6b08a10f6b9ccda90caaf69f2f60b6371a3d15dccb88ab20a648ffa30663f5342484c7bde0191e9b7eafe0a2410146ab0a829462eda9e673bc54222a8</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 面试真题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>code字符串压缩</title>
      <link href="/2023/11/22/%E9%9D%A2%E8%AF%95%E7%9C%9F%E9%A2%98/code%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8E%8B%E7%BC%A9/"/>
      <url>/2023/11/22/%E9%9D%A2%E8%AF%95%E7%9C%9F%E9%A2%98/code%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8E%8B%E7%BC%A9/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>美团1面 </p><ol><li>初级版本字符串压缩<br>原题链接:<br><a href="https://leetcode.cn/problems/compress-string-lcci/description/">https://leetcode.cn/problems/compress-string-lcci/description/</a></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">compressString</span><span class="params">(String S)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>() ;</span><br><span class="line">        <span class="type">char</span> [] cs = S.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> cs.length;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (j &lt; n &amp;&amp; cs[i] == cs[j])&#123;</span><br><span class="line">                count++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            res.append(cs[i] + <span class="string">&quot;&quot;</span> + count);</span><br><span class="line">            i = j;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res.length() &gt;= n ?  S : res.toString() ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="2"><li>中级版字符串压缩</li></ol><p>原题链接:<br><a href="https://leetcode.cn/problems/string-compression/description/">https://leetcode.cn/problems/string-compression/description/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compress</span><span class="params">(<span class="type">char</span>[] chars)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> chars.length;</span><br><span class="line">        <span class="comment">// i j 分别指向 当前处理位置 和 答案待插入的位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(i &lt; n)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">while</span>(idx &lt; n &amp;&amp; chars[i] == chars[idx])&#123;</span><br><span class="line">                idx++;</span><br><span class="line">            &#125;      </span><br><span class="line"></span><br><span class="line">            <span class="comment">// 先赋值字母 如果有大于1的重复出现那么进行压缩</span></span><br><span class="line">            chars[j++] = chars[i];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 统计有多少相同的元素</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> idx - i ;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// count &gt;  1 则开始压缩、</span></span><br><span class="line">            <span class="comment">// count = 1 不压缩 否则 1变成2 就变成增长了 </span></span><br><span class="line">            <span class="keyword">if</span>(count &gt; <span class="number">1</span>)&#123;  </span><br><span class="line">                <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> j, end = start;</span><br><span class="line">                <span class="keyword">while</span>(count != <span class="number">0</span>)&#123;</span><br><span class="line">                    chars[end++]  = (<span class="type">char</span>)((count % <span class="number">10</span>)+ <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                    count /= <span class="number">10</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                reverse(start,end - <span class="number">1</span>,chars);</span><br><span class="line">                j = end;</span><br><span class="line">            &#125;</span><br><span class="line">            i = idx;</span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        <span class="comment">// j为答案待插入的位置</span></span><br><span class="line">        <span class="comment">// j - 1 即为答案的位置 由于数组从0开始 故返回j</span></span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end,<span class="type">char</span>[] cs)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">t</span> <span class="operator">=</span> cs[start];</span><br><span class="line">            cs[start] = cs[end];</span><br><span class="line">            cs[end] = t;</span><br><span class="line">            start++; end--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="3"><li>高级版字符串压缩<br>原题链接:<br><a href="https://leetcode.cn/problems/string-compression-ii/description/">https://leetcode.cn/problems/string-compression-ii/description/</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 面试真题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 美团校招 </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>code删除排序链表中的重复元素</title>
      <link href="/2023/11/22/%E9%9D%A2%E8%AF%95%E7%9C%9F%E9%A2%98/code%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/"/>
      <url>/2023/11/22/%E9%9D%A2%E8%AF%95%E7%9C%9F%E9%A2%98/code%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>美团校招一面</p><p>原题链接:<br><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list/description/">https://leetcode.cn/problems/remove-duplicates-from-sorted-list/description/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">deleteDuplicates</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>();</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> dummy.next;</span><br><span class="line">        <span class="keyword">while</span> (cur.next != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (cur.val == cur.next.val)&#123;</span><br><span class="line">                <span class="comment">// 这样不会死循环 因为每次都删除了一个元素</span></span><br><span class="line">                <span class="comment">// 所以cur不需要后移动一位 </span></span><br><span class="line">                cur.next = cur.next.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试真题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
            <tag> 美团校招 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>code二叉树的右视图</title>
      <link href="/2023/11/21/%E9%9D%A2%E8%AF%95%E7%9C%9F%E9%A2%98/code%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE/"/>
      <url>/2023/11/21/%E9%9D%A2%E8%AF%95%E7%9C%9F%E9%A2%98/code%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>原题链接:<br><a href="https://leetcode.cn/problems/WNC0Lk/">https://leetcode.cn/problems/WNC0Lk/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 层序遍历 返回每层最右边的一个节点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">rightSideView</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        q.offer(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!q.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> q.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; s ; i++)&#123;</span><br><span class="line">                <span class="type">var</span> <span class="variable">node</span> <span class="operator">=</span> q.poll();</span><br><span class="line">                <span class="keyword">if</span>(i == s - <span class="number">1</span>)&#123;</span><br><span class="line">                    ans.add(node.val);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                    q.offer(node.left);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                    q.offer(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试真题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试真题 </tag>
            
            <tag> 字节校招 </tag>
            
            <tag> 腾讯校招 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>code螺旋矩阵</title>
      <link href="/2023/11/21/%E9%9D%A2%E8%AF%95%E7%9C%9F%E9%A2%98/code%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/"/>
      <url>/2023/11/21/%E9%9D%A2%E8%AF%95%E7%9C%9F%E9%A2%98/code%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>原题链接:<br><a href="https://leetcode.cn/problems/spiral-matrix/">https://leetcode.cn/problems/spiral-matrix/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    右下左上 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 注意一下坐标就行了 程序中的坐标系会与传统理解坐标系有些不同</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> [] dx = <span class="keyword">new</span> <span class="title class_">int</span> [] &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> [] dy = <span class="keyword">new</span> <span class="title class_">int</span> [] &#123;<span class="number">1</span>,<span class="number">0</span>,-<span class="number">1</span>,<span class="number">0</span>&#125;; </span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">spiralOrder</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> matrix.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">boolean</span> [][] vis = <span class="keyword">new</span> <span class="title class_">boolean</span> [m][n];</span><br><span class="line">        ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur != m * n)&#123;</span><br><span class="line">            res.add(matrix[x][y]);</span><br><span class="line">            vis[x][y] = <span class="literal">true</span>;</span><br><span class="line">            cur++; </span><br><span class="line">            <span class="type">int</span> <span class="variable">tx</span> <span class="operator">=</span> x + dx[d];</span><br><span class="line">            <span class="type">int</span> <span class="variable">ty</span> <span class="operator">=</span> y + dy[d];</span><br><span class="line">            <span class="keyword">if</span>( tx &lt; <span class="number">0</span> || ty &lt;  <span class="number">0</span> ||  tx == m || ty == n || vis[tx][ty])&#123;</span><br><span class="line">                d = (d + <span class="number">1</span>) % <span class="number">4</span>;</span><br><span class="line">                tx = x + dx[d];</span><br><span class="line">                ty = y + dy[d];</span><br><span class="line">            &#125;</span><br><span class="line">            x = tx;</span><br><span class="line">            y = ty;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试真题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模拟 </tag>
            
            <tag> 微软真题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>code最大子数组和</title>
      <link href="/2023/11/21/%E9%9D%A2%E8%AF%95%E7%9C%9F%E9%A2%98/code%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C/"/>
      <url>/2023/11/21/%E9%9D%A2%E8%AF%95%E7%9C%9F%E9%A2%98/code%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>字节校招 2面</p><p>原题链接:<br><a href="https://leetcode.cn/problems/maximum-subarray/">https://leetcode.cn/problems/maximum-subarray/</a></p><p>原题链接:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// f[i]表示以i结尾的 前i个 数组中 最长子序列和</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> [] f = <span class="keyword">new</span> <span class="title class_">int</span> [n + <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span> ; i &lt;= n ; i++)&#123;</span><br><span class="line">            f[i] = Math.max(nums[i - <span class="number">1</span>],f[i - <span class="number">1</span>] + nums[i - <span class="number">1</span>]);</span><br><span class="line">            ans = Math.max(f[i],ans);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试真题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 字节校招 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>code安排电影院座位</title>
      <link href="/2023/11/21/%E9%9D%A2%E8%AF%95%E7%9C%9F%E9%A2%98/code%E5%AE%89%E6%8E%92%E7%94%B5%E5%BD%B1%E9%99%A2%E5%BA%A7%E4%BD%8D/"/>
      <url>/2023/11/21/%E9%9D%A2%E8%AF%95%E7%9C%9F%E9%A2%98/code%E5%AE%89%E6%8E%92%E7%94%B5%E5%BD%B1%E9%99%A2%E5%BA%A7%E4%BD%8D/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>华为校招主管面</p><p>原题链接：<br><a href="https://leetcode.cn/problems/cinema-seat-allocation/description/">https://leetcode.cn/problems/cinema-seat-allocation/description/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0b11110000</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">middle</span> <span class="operator">=</span> <span class="number">0b11000011</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0b00001111</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxNumberOfFamilies</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[][] reservedSeats)</span> &#123;</span><br><span class="line">        HashMap&lt;Integer,Integer&gt;hash = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; reservedSeats.length ; i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> reservedSeats[i][<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">col</span> <span class="operator">=</span> reservedSeats[i][<span class="number">1</span>];  </span><br><span class="line">            <span class="comment">// 最左和最右两个位置为 无效位置</span></span><br><span class="line">            <span class="keyword">if</span>(col &lt;= <span class="number">1</span> || col &gt;= <span class="number">10</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mask</span> <span class="operator">=</span> hash.getOrDefault(row,<span class="number">0</span>);</span><br><span class="line">            <span class="comment">// 左右两个位置 无效直接忽略</span></span><br><span class="line">            hash.put(row, mask | <span class="number">1</span> &lt;&lt; (col - <span class="number">2</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 直接反向做可以加速 否则会超时 </span></span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> (n - hash.size()) * <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 只对 有预约的行进行操作</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> es : hash.entrySet())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> es.getKey();</span><br><span class="line">            <span class="type">int</span> <span class="variable">seats</span> <span class="operator">=</span> es.getValue();</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>((seats | left) == left || (seats | middle) == middle || (seats | right) == right)&#123;</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试真题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 哈希 </tag>
            
            <tag> 位运算 </tag>
            
            <tag> 华为校招 </tag>
            
            <tag> 华为真题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法模板-动态规划</title>
      <link href="/2023/11/14/algoSummary/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
      <url>/2023/11/14/algoSummary/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1><span id="序列dp">序列DP</span></h1><h3><span id="leetcode-674-最长连续递增序列">leetcode 674 最长连续递增序列</span></h3><p>原题链接:<br><a href="https://leetcode.cn/problems/longest-continuous-increasing-subsequence/description/">https://leetcode.cn/problems/longest-continuous-increasing-subsequence/description/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">    f[i] 以i结尾 长度最长的连续递增子序列</span></span><br><span class="line"><span class="comment">    本题要求的是  最长连续递增子序列</span></span><br><span class="line"><span class="comment">    连续 说明 f[i] 的状态只能由f[i - 1]转移而来</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findLengthOfLCIS</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> [] f = <span class="keyword">new</span> <span class="title class_">int</span> [n];</span><br><span class="line">        Arrays.fill(f,<span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span> ; i &lt; n ; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; nums[i -<span class="number">1</span>] )&#123;</span><br><span class="line">                f[i] = Math.max(f[i],f[i - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            ans = Math.max(ans,f[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3><span id="leetcode-62-不同路径">leetcode 62 不同路径</span></h3><p>原题链接:<br><a href="https://leetcode.cn/problems/unique-paths/">https://leetcode.cn/problems/unique-paths/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    f[i][j] 表示 以i,j 坐标结尾的 机器人可以走的最多的路径情况</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> [][] f = <span class="keyword">new</span> <span class="title class_">int</span> [m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 初始到起点 只有一种走法</span></span><br><span class="line">        f[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span> ; j &lt;= n ; j++)&#123;</span><br><span class="line">                <span class="comment">// f[i][j] = 1; </span></span><br><span class="line">                f[i][j] += f[i - <span class="number">1</span>][j] + f[i][j - <span class="number">1</span>]  ;</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> f[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="leetcode-70-爬楼梯">leetcode 70 爬楼梯</span></h3><p>原题链接:<br><a href="https://leetcode.cn/problems/climbing-stairs/description/">https://leetcode.cn/problems/climbing-stairs/description/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    f[i] 表示以当前 第i阶楼梯结尾 爬到楼顶的最大方案数</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> []  f = <span class="keyword">new</span> <span class="title class_">int</span> [n + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        f[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        f[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">3</span> ; i &lt;= n ; i++)&#123;</span><br><span class="line">            f[i] = f[i - <span class="number">1</span>] + f[i - <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> f[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="leetcode-64-最小路径和">leetcode 64 最小路径和</span></h3><p>原题链接:<br><a href="https://leetcode.cn/problems/minimum-path-sum/description/">https://leetcode.cn/problems/minimum-path-sum/description/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minPathSum</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> grid.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> grid[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> [][] f = <span class="keyword">new</span> <span class="title class_">int</span> [m][n];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; m; i++)&#123;   </span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n ; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>)&#123;</span><br><span class="line">                    f[i][j] = grid[i][j];</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">0</span>)&#123;</span><br><span class="line">                    f[i][j] = f[i][j - <span class="number">1</span>] + grid[i][j];</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(j == <span class="number">0</span>)&#123;</span><br><span class="line">                    f[i][j] = f[i - <span class="number">1</span>][j] + grid[i][j]; </span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    f[i][j] = Math.min(f[i - <span class="number">1</span>][j],f[i][j - <span class="number">1</span>]) + grid[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> f[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3><span id="leetcode-368-最大整除子集">leetcode 368 最大整除子集</span></h3><p>原题链接:<br><a href="https://leetcode.cn/problems/largest-divisible-subset/description/">https://leetcode.cn/problems/largest-divisible-subset/description/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">largestDivisibleSubset</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">// 数组要有序</span></span><br><span class="line">        <span class="comment">// 否则 如果 nums[i] &lt; nums[j] (i &gt; j) 时无法正常判断倍数关系</span></span><br><span class="line">        <span class="comment">// 且状态也就失去了递推性</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="comment">// dp数组 以i结尾的 符合题意要求的整数集的最大长度</span></span><br><span class="line">        <span class="type">int</span> [] f = <span class="keyword">new</span> <span class="title class_">int</span> [n];</span><br><span class="line">        <span class="comment">// 回溯数组 用于记录以i结尾 符合题意的整数集 状态是由哪一个状态而来</span></span><br><span class="line">        <span class="type">int</span> [] g = <span class="keyword">new</span> <span class="title class_">int</span> [n];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; n ; i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">prev</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span> ; j &lt; n ; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] % nums[j] == <span class="number">0</span> )&#123;</span><br><span class="line">                    <span class="keyword">if</span>(len &lt; f[j] + <span class="number">1</span>)&#123;</span><br><span class="line">                        len = f[j] + <span class="number">1</span>;</span><br><span class="line">                        prev = j;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            f[i] = len;</span><br><span class="line">            g[i] = prev; </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(f[i] &gt; max)&#123;</span><br><span class="line">                max = f[i];</span><br><span class="line">                idx = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(ans.size() &lt; max)&#123;</span><br><span class="line">            ans.add(nums[idx]);</span><br><span class="line">            idx = g[idx];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3><span id="leetcode-300-最长递增子序列">leetcode 300 最长递增子序列</span></h3><p>原题链接:<br><a href="https://leetcode.cn/problems/longest-increasing-subsequence/description/">https://leetcode.cn/problems/longest-increasing-subsequence/description/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLIS</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> [] f = <span class="keyword">new</span> <span class="title class_">int</span> [n + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; n ; i++)&#123;</span><br><span class="line">            f[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span> ; j &lt; i ; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] &gt; nums[j])&#123;</span><br><span class="line">                    f[i] = Math.max(f[i], f[j] + <span class="number">1</span>);</span><br><span class="line">                    ans = Math.max(ans,f[i]);</span><br><span class="line">                &#125;    </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="53-最大子数组和">53 最大子数组和</span></h3><p>原题链接:<br><a href="https://leetcode.cn/problems/maximum-subarray/?envType=daily-question&amp;envId=2023-11-20">https://leetcode.cn/problems/maximum-subarray/?envType=daily-question&amp;envId=2023-11-20</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// f[i] 表示以nums[i]结尾的连续子数组的最大和</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> [] f = <span class="keyword">new</span> <span class="title class_">int</span> [n];</span><br><span class="line">        f[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> f[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">            f[i] = Math.max(nums[i],f[i - <span class="number">1</span>] + nums[i]);</span><br><span class="line">            ans = Math.max(ans,f[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2><span id="股票问题">股票问题</span></h2><h3><span id="leetcode-121-买卖股票的最佳时机">leetcode 121. 买卖股票的最佳时机</span></h3><p>这题可以用DP做 但不是最优解<br>最优解是枚举 只要有 后面的最大减前面最小的组合一组成立即可 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    只能进行一次交易</span></span><br><span class="line"><span class="comment">    f[i][j] 表示以第i天结尾 持股状态为j的股票交易最大利润</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> prices.length;</span><br><span class="line">        <span class="type">int</span> [][] f = <span class="keyword">new</span> <span class="title class_">int</span> [n][<span class="number">2</span>];</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span> ; i &lt; n ; i++)&#123;</span><br><span class="line">            f[i][<span class="number">0</span>] = Math.max(f[i - <span class="number">1</span>][<span class="number">0</span>],f[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">            <span class="comment">// 当前 由于只能进行一次操作 那么对应的前一次操作一定是买入 或者 之前买入但不动了 </span></span><br><span class="line">            f[i][<span class="number">1</span>] = Math.max(f[i - <span class="number">1</span>][<span class="number">1</span>],-prices[i]) ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Math.max(f[n - <span class="number">1</span>][<span class="number">0</span>],f[n - <span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最优解 枚举 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> prices.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; n ;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(prices[i] &lt; min)&#123;</span><br><span class="line">                min = prices[i];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ans = Math.max(ans,prices[i] - min);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3><span id="leetcode-122-买卖股票的最佳时机-ii">leetcode 122. 买卖股票的最佳时机 II</span></h3><p>原题链接:<br><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/description/">https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/description/</a></p><p>用贪心做会更快一些  但dp也行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> prices.length;</span><br><span class="line">        <span class="type">int</span> [][] f = <span class="keyword">new</span> <span class="title class_">int</span> [n][<span class="number">2</span>];</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span> ; i &lt; n;i++)&#123;</span><br><span class="line">            f[i][<span class="number">0</span>] = Math.max(f[i - <span class="number">1</span>][<span class="number">0</span>],f[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">            f[i][<span class="number">1</span>] = Math.max(f[i - <span class="number">1</span>][<span class="number">1</span>],f[i - <span class="number">1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Math.max(f[n - <span class="number">1</span>][<span class="number">0</span>],f[n - <span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>贪心解法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主要是理解交易的拆分性 一组跨越多段的交易 可以由一组连续的交易组合而成</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> prices.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span> ; i &lt; n ; i++)&#123;</span><br><span class="line">            res += Math.max(<span class="number">0</span>,prices[i] - prices[i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1><span id="线性dp">线性DP</span></h1><h3><span id="leetcode-97-交错字符串">leetcode 97. 交错字符串</span></h3><p>原题链接:<br><a href="https://leetcode.cn/problems/interleaving-string/">https://leetcode.cn/problems/interleaving-string/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    f[i][j] 表示使用s1的前i位 s2的前j位 (不包括第i位和第j位) 是否能拼凑出s3的前i+j位</span></span><br><span class="line"><span class="comment">    f[0][0] 代表1位都没有 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">char</span> [] cs(String s)&#123;</span><br><span class="line">        <span class="keyword">return</span> s.toCharArray();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isInterleave</span><span class="params">(String s1, String s2, String s3)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s1.length(), m = s2.length();</span><br><span class="line">        <span class="keyword">if</span>(n + m != s3.length())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">boolean</span> [][] f = <span class="keyword">new</span> <span class="title class_">boolean</span> [n + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// int l = n + m;</span></span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="type">var</span> <span class="variable">cs1</span> <span class="operator">=</span> cs(s1);</span><br><span class="line">        <span class="type">var</span> <span class="variable">cs2</span> <span class="operator">=</span> cs(s2); </span><br><span class="line">        <span class="type">var</span> <span class="variable">cs3</span> <span class="operator">=</span> cs(s3);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化 省去边界判断 </span></span><br><span class="line">        <span class="comment">// 初始化时还要注意 如果前面一位无法组成 那么后续的肯定就无法满足条件 </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span> ; i &lt;= n &amp;&amp; f[i - <span class="number">1</span>][<span class="number">0</span>] ; i++ )&#123;</span><br><span class="line">            f[i][<span class="number">0</span>] = cs1[i - <span class="number">1</span>] == cs3[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= m &amp;&amp; f[<span class="number">0</span>][i - <span class="number">1</span>]; i++)&#123;</span><br><span class="line">            f[<span class="number">0</span>][i] = cs2[i - <span class="number">1</span>] == cs3[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span> ; i &lt;= n ; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span> ; j &lt;= m ; j++ )&#123;  </span><br><span class="line">                <span class="keyword">if</span>(cs1[i - <span class="number">1</span>] == cs3[i + j - <span class="number">1</span>])&#123;</span><br><span class="line">                    f[i][j] |= f[i - <span class="number">1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(cs2[j - <span class="number">1</span>] == cs3[i + j - <span class="number">1</span>])&#123;</span><br><span class="line">                    f[i][j] |= f[i][j - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> f[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2><span id="跳跃游戏">跳跃游戏</span></h2><h3><span id="leetcode-55-跳跃游戏">leetcode 55. 跳跃游戏</span></h3><p>原题链接:<br><a href="https://leetcode.cn/problems/jump-game/">https://leetcode.cn/problems/jump-game/</a></p><p>这题动态规划可以做 但不是最优解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// f[i] 表示以i结尾的点 当前可以到达的最远距离</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canJump</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;=  <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 总长大于1  但只能永远停留在原地</span></span><br><span class="line">        <span class="keyword">if</span>(nums[<span class="number">0</span>] == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> [] f = <span class="keyword">new</span> <span class="title class_">int</span> [n];</span><br><span class="line">        f[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">         <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span> ; i &lt; n ; i++)&#123;</span><br><span class="line">             f[i] = Math.max(f[i - <span class="number">1</span>],nums[i] + i);</span><br><span class="line">             <span class="comment">// 已经超过终点直接 返回true</span></span><br><span class="line">             <span class="keyword">if</span>(f[i] &gt;= n - <span class="number">1</span>)&#123;</span><br><span class="line">                 <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="comment">// 永远只能停留在原地 </span></span><br><span class="line">             <span class="keyword">if</span>(f[i] == i)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一次遍历的解法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canJump</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; n ; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; k)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            k = Math.max(k,i + nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3><span id="leetcode-45-跳跃游戏-ii">leetcode 45. 跳跃游戏 II</span></h3><p>原题链接:<br><a href="https://leetcode.cn/problems/jump-game-ii/description/">https://leetcode.cn/problems/jump-game-ii/description/</a></p><p>DP可以做 但不是最优解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">    f[i] 表示到达第i个位置所需要的最小步数</span></span><br><span class="line"><span class="comment">    类似于上升子序列模型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">jump</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;    </span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> [] f = <span class="keyword">new</span> <span class="title class_">int</span> [n];</span><br><span class="line">        Arrays.fill(f,Integer.MAX_VALUE);</span><br><span class="line">        f[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span> ; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span> ; j &lt; i ; j++)&#123;</span><br><span class="line">                <span class="comment">// 可以到达当前点</span></span><br><span class="line">                <span class="keyword">if</span>(nums[j] &gt;= i - j)&#123;</span><br><span class="line">                    f[i] = Math.min(f[j] + <span class="number">1</span>,f[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> f[n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最优解<br>贪心</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">jump</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前可以到达的最远下一步 </span></span><br><span class="line">        <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 结果</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据题意 n - 1 就已经是终点了 且是一定到达的</span></span><br><span class="line">        <span class="comment">// 所以只要保证能走到 n - 2这个点 那么n - 1就一定是可达的</span></span><br><span class="line">        <span class="comment">// 反之如果保证了 走到 n - 1这个点 那么可能走到n - 2 就已经满足了条件了答案反而会多了一位</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; n - <span class="number">1</span> ; i++)&#123;</span><br><span class="line">            next = Math.max(next,i + nums[i]);</span><br><span class="line">            <span class="comment">// 那么必须进行 下一跳 直接跳到最远距离 </span></span><br><span class="line">            <span class="keyword">if</span>(end ==  i)&#123;</span><br><span class="line">                end =  next;</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1><span id="树形dp">树形DP</span></h1><h3><span id="acwing-285-没有上司的舞会">acwing 285. 没有上司的舞会</span></h3><p>原题链接:<br><a href="https://www.acwing.com/problem/content/287/">https://www.acwing.com/problem/content/287/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> <span class="number">6010</span>;</span><br><span class="line">    <span class="comment">// 数组模拟链表</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> [] e, h, ne, happy;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> [] has_father;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> [][] f;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> idx;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        e = <span class="keyword">new</span> <span class="title class_">int</span>[N];</span><br><span class="line">        ne = <span class="keyword">new</span> <span class="title class_">int</span>[N];</span><br><span class="line">        h = <span class="keyword">new</span> <span class="title class_">int</span>[N];</span><br><span class="line">        happy = <span class="keyword">new</span> <span class="title class_">int</span> [N];</span><br><span class="line">        has_father = <span class="keyword">new</span> <span class="title class_">boolean</span>[N];</span><br><span class="line">        <span class="comment">// 初始化 链表</span></span><br><span class="line">        Arrays.fill(h,-<span class="number">1</span>);</span><br><span class="line">        idx = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 这里一定要从1开始 因为后续 root是1  同样也是防止出现f数组的越界问题</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span> ; i &lt;= n ; i++)&#123;</span><br><span class="line">            happy[i] = sc.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; n - <span class="number">1</span> ; i++)&#123;</span><br><span class="line">            <span class="comment">// a , b  b是a上司</span></span><br><span class="line">            <span class="type">int</span> a,b;</span><br><span class="line">            a = sc.nextInt();</span><br><span class="line">            b = sc.nextInt();</span><br><span class="line">            <span class="comment">// b -&gt; a  所以a 有根节点</span></span><br><span class="line">            has_father[a] = <span class="literal">true</span>;</span><br><span class="line">            add(b,a);</span><br><span class="line">        &#125;</span><br><span class="line">        f = <span class="keyword">new</span> <span class="title class_">int</span>[N][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">root</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (has_father[root])&#123;</span><br><span class="line">            root++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dfs(root);</span><br><span class="line">        System.out.println(Math.max(f[root][<span class="number">0</span>],f[root][<span class="number">1</span>]));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> u)</span>&#123;</span><br><span class="line">        <span class="comment">// 选择这个节点作为根节点 则直接赋值</span></span><br><span class="line">        f[u][<span class="number">1</span>] = happy[u];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> h[u]; i != -<span class="number">1</span>; i = ne[i])&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> e[i];</span><br><span class="line">            <span class="comment">// 先向下递归</span></span><br><span class="line">            dfs(j);</span><br><span class="line">            <span class="comment">// 不选该节点</span></span><br><span class="line">            <span class="comment">// 则上一个节点可以选 也可以不选 取最大值即可</span></span><br><span class="line">            f[u][<span class="number">0</span>] += Math.max(f[j][<span class="number">0</span>],f[j][<span class="number">1</span>]);</span><br><span class="line">            <span class="comment">// 选了该节点 则上一个节点只能是不选</span></span><br><span class="line">            f[u][<span class="number">1</span>] += f[j][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;</span><br><span class="line">        e[idx] = b;</span><br><span class="line">        ne[idx] = h[a];</span><br><span class="line">        h[a] = idx++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>code最小路径和</title>
      <link href="/2023/11/13/%E9%9D%A2%E8%AF%95%E7%9C%9F%E9%A2%98/code%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/"/>
      <url>/2023/11/13/%E9%9D%A2%E8%AF%95%E7%9C%9F%E9%A2%98/code%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>leetcode 64 最小路径和</p><p>原题链接<br><a href="https://leetcode.cn/problems/minimum-path-sum/">https://leetcode.cn/problems/minimum-path-sum/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minPathSum</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> grid.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span> [][] dp = <span class="keyword">new</span> <span class="title class_">int</span> [n][m];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n ; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span> ; j &lt; m ; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">0</span>)&#123;</span><br><span class="line">                    dp[i][j] = dp[i][j - <span class="number">1</span>] + grid[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(j == <span class="number">0</span>)&#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j] + grid[i][j];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j] = Math.min(dp[i - <span class="number">1</span>][j] + grid[i][j],dp[i][j - <span class="number">1</span>] + grid[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>][m - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试真题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 字节校招 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>code岛屿数量</title>
      <link href="/2023/11/08/%E9%9D%A2%E8%AF%95%E7%9C%9F%E9%A2%98/code%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F/"/>
      <url>/2023/11/08/%E9%9D%A2%E8%AF%95%E7%9C%9F%E9%A2%98/code%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>原题链接:<br><a href="https://leetcode.cn/problems/number-of-islands/">https://leetcode.cn/problems/number-of-islands/</a></p><h2><span id="法1-bfs">法1: BFS</span></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> [] dx = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">0</span>,-<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> [] dy = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;-<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> n,m;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numIslands</span><span class="params">(<span class="type">char</span>[][] grid)</span> &#123;</span><br><span class="line">        n = grid.length;</span><br><span class="line">        m = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; n ; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; m; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                    bfs(grid,i,j);</span><br><span class="line">                    ans++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>  ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bfs</span><span class="params">(<span class="type">char</span> [][] g,<span class="type">int</span> x,<span class="type">int</span> y)</span>&#123;</span><br><span class="line">        Queue&lt;<span class="type">int</span>[]&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;x,y&#125;);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">            <span class="type">var</span> <span class="variable">t</span> <span class="operator">=</span>  queue.poll();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; <span class="number">4</span> ; i++)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">tx</span> <span class="operator">=</span> t[<span class="number">0</span>] + dx[i];</span><br><span class="line">                <span class="type">int</span> <span class="variable">ty</span> <span class="operator">=</span> t[<span class="number">1</span>] + dy[i];</span><br><span class="line">                <span class="keyword">if</span> (tx &lt; <span class="number">0</span> || tx &gt;=n || ty &lt; <span class="number">0</span> || ty &gt;= m)&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (g[tx][ty] == <span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                    g[tx][ty] = <span class="string">&#x27;x&#x27;</span>;</span><br><span class="line">                    queue.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;tx,ty&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2><span id="法2-dfs">法2: DFS</span></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">char</span> [][] g;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> n,m;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> [] dx = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;-<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> [] dy = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">0</span>,-<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numIslands</span><span class="params">(<span class="type">char</span>[][] grid)</span> &#123;</span><br><span class="line">        g = grid;</span><br><span class="line">        n = grid.length;</span><br><span class="line">        m = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; n ; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span> ; j &lt; m ; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (g[i][j] == <span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                    dfs(i,j);</span><br><span class="line">                    ans++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; <span class="number">4</span> ; i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">tx</span> <span class="operator">=</span> x + dx[i];</span><br><span class="line">            <span class="type">int</span> <span class="variable">ty</span> <span class="operator">=</span> y + dy[i];</span><br><span class="line">            <span class="keyword">if</span> (tx &lt; <span class="number">0</span> || tx &gt;= n || ty &lt; <span class="number">0</span> || ty &gt;= m)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (g[tx][ty] == <span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                g[tx][ty] = <span class="string">&#x27;x&#x27;</span>;</span><br><span class="line">                dfs(tx,ty);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试真题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 华为校招 </tag>
            
            <tag> BFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>code二叉树的序列化与反序列化</title>
      <link href="/2023/11/08/%E9%9D%A2%E8%AF%95%E7%9C%9F%E9%A2%98/code%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
      <url>/2023/11/08/%E9%9D%A2%E8%AF%95%E7%9C%9F%E9%A2%98/code%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>原题链接:<br><a href="https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/">https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/</a></p><h2><span id="法1-dfs">法1 dfs</span></h2><p>写法1 重构时使用cur进行标记 会快一些</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Codec</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    *   前序遍历 序列化编译为字符串</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">serialize</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;N&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> root.val + <span class="string">&quot;,&quot;</span> +  serialize(root.left) + <span class="string">&quot;,&quot;</span> + serialize(root.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在leetcode中 static变量只会初始化一次 </span></span><br><span class="line">    <span class="comment">// 之后每次会沿用上一次的值 如果只是作为记数值 那么每次都需要再调用前先初始化一下</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="comment">// 用于反序列化</span></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">dfs2</span><span class="params">(String[] split)</span>&#123;</span><br><span class="line">        <span class="comment">// System.out.println(cur);</span></span><br><span class="line">        <span class="comment">// 为空则直接返回</span></span><br><span class="line">        <span class="comment">// 字符串不能用 &quot;==&quot; 进行比较 否则比较的是地址会出现问题</span></span><br><span class="line">        <span class="keyword">if</span> (cur &gt;= split.length || split[cur].equals(<span class="string">&quot;N&quot;</span>))&#123;</span><br><span class="line">            cur++;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(Integer.parseInt(split[cur]));</span><br><span class="line">        cur++;</span><br><span class="line"></span><br><span class="line">        node.left = dfs2(split);</span><br><span class="line">        node.right = dfs2(split);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">deserialize</span><span class="params">(String data)</span> &#123;</span><br><span class="line">        <span class="comment">// 根据, 进行拆分</span></span><br><span class="line">        cur = <span class="number">0</span>;</span><br><span class="line">        String[] split = data.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> dfs2(split);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Your Codec object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">// Codec ser = new Codec();</span></span><br><span class="line"><span class="comment">// Codec deser = new Codec();</span></span><br><span class="line"><span class="comment">// TreeNode ans = deser.deserialize(ser.serialize(root));</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>写法2 直接使用list 会比较简洁一些 也不容易出错</p><h2><span id="法2-bfs">法2 BFS</span></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Codec</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">serialize</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;null&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">            <span class="type">var</span>  <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (node == <span class="literal">null</span>)&#123;</span><br><span class="line">                res.append(<span class="string">&quot;null,&quot;</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            res.append(node.val + <span class="string">&quot;,&quot;</span>);</span><br><span class="line">            queue.offer(node.left);</span><br><span class="line">            queue.offer(node.right);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">deserialize</span><span class="params">(String data)</span> &#123;</span><br><span class="line">        String[] split = data.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> x : split)&#123;</span><br><span class="line">            System.out.println(x);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(split[<span class="number">0</span>] == <span class="string">&quot;null&quot;</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(Integer.parseInt(split[<span class="number">0</span>]));</span><br><span class="line">        queue.offer(root);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 作为指针</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> split.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">            <span class="type">var</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (cur &lt; n &amp;&amp; !split[cur].equals(<span class="string">&quot;null&quot;</span>))&#123;</span><br><span class="line">                node.left = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(Integer.parseInt(split[cur]));</span><br><span class="line">                queue.offer(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">            cur++;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(cur &lt; n &amp;&amp; !split[cur].equals(<span class="string">&quot;null&quot;</span>))&#123;</span><br><span class="line">                node.right = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(Integer.parseInt(split[cur]));</span><br><span class="line">                queue.offer(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            cur++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Your Codec object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">// Codec ser = new Codec();</span></span><br><span class="line"><span class="comment">// Codec deser = new Codec();</span></span><br><span class="line"><span class="comment">// TreeNode ans = deser.deserialize(ser.serialize(root));</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试真题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
            <tag> 字节校招 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java集合</title>
      <link href="/2023/11/07/interview/java%E9%9B%86%E5%90%88/"/>
      <url>/2023/11/07/interview/java%E9%9B%86%E5%90%88/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1><span id="集合基本使用">集合基本使用</span></h1><p>集合与数组<br><img src="/2023/11/07/interview/java%E9%9B%86%E5%90%88/img1.png" style="zoom:100%"></p><h2><span id="arraylist">ArrayList</span></h2><p>ArrayList成员方法<br><img src="/2023/11/07/interview/java%E9%9B%86%E5%90%88/img2.png" style="zoom:100%"></p><p>代码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 创建集合的对象</span></span><br><span class="line">        <span class="comment">// 泛型 限定集合中存储数据的类型</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// JDK7 之前的写法</span></span><br><span class="line"><span class="comment">//        ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// JDK7 后的写法</span></span><br><span class="line">        <span class="comment">// 此时我们创建的是Arraylist的对象 而对象ArrayList是java已经写好的一个类</span></span><br><span class="line">        <span class="comment">// 这个类在底层做了一些处理</span></span><br><span class="line">        <span class="comment">// 打印对象不是地址值 而是集合中存储数据内容</span></span><br><span class="line">        <span class="comment">// 在展示会拿[]把所有的数据进行包裹</span></span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加元素</span></span><br><span class="line">        list.add(<span class="string">&quot;aa&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;bb&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;cc&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除元素</span></span><br><span class="line">        <span class="comment">// 根据对象删除 返回是否删除成功</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">aa</span> <span class="operator">=</span> list.remove(<span class="string">&quot;aa&quot;</span>);</span><br><span class="line">        <span class="comment">// 根据索引删除 返回被删除的数</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">remove</span> <span class="operator">=</span> list.remove(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 修改元素</span></span><br><span class="line">        <span class="comment">// 会返回被覆盖的元素值</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">ccc</span> <span class="operator">=</span> list.set(<span class="number">1</span>, <span class="string">&quot;ccc&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查询元素</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> list.get(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">            System.out.println(list.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> interview </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>算法模板BFS</title>
      <link href="/2023/11/07/algoSummary/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF-BFS/"/>
      <url>/2023/11/07/algoSummary/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF-BFS/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>基础知识：<br>常见的BFS用来解决什么问题？(1) 简单图（有向无向皆可）的最短路径长度，注意是长度而不是具体的路径（2）拓扑排序 （3） 遍历一个图（或者树）<br>BFS基本模板（需要记录层数或者不需要记录层数）<br>多数情况下时间复杂度空间复杂度都是O（N+M），N为节点个数，M为边的个数</p><h1><span id="面试推荐题单">面试推荐题单</span></h1><p><a href="https://zhuanlan.zhihu.com/p/349940945">https://zhuanlan.zhihu.com/p/349940945</a></p><h2><span id="基于树的bfs不需要专门一个set来记录访问过的节点">基于树的BFS：不需要专门一个set来记录访问过的节点</span></h2><h3><span id="leetcode-102-二叉树的层序遍历">leetcode 102 二叉树的层序遍历</span></h3><p>原题链接:<br><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">https://leetcode.cn/problems/binary-tree-level-order-traversal/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 队列</span></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span> (queue.isEmpty() == <span class="literal">false</span>)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            <span class="type">var</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="keyword">new</span>  <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; s ; i++)&#123;</span><br><span class="line">                <span class="type">var</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                cur.add(node.val);</span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                    queue.offer(node.left);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                    queue.offer(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ans.add(cur);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3><span id="leetcode-103-二叉树的锯齿形层序遍历">leetcode 103. 二叉树的锯齿形层序遍历</span></h3><p>题目思路简单 但要实现很绕</p><h4><span id="法1-用下一层的层数来判断当前的存储顺序">法1 用下一层的层数来判断当前的存储顺序</span></h4><p>非常绕 效率也不高 我第一次自己的时候的解法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">zigzagLevelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt;ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Deque&lt;TreeNode&gt;  deque = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        deque.offer(root);</span><br><span class="line">        <span class="type">int</span> <span class="variable">level</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (deque.isEmpty() == <span class="literal">false</span>)&#123;</span><br><span class="line">            ArrayList&lt;TreeNode&gt; cur = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(deque);</span><br><span class="line">            ArrayList&lt;Integer&gt; tmp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(deque.size());</span><br><span class="line">            deque.clear();</span><br><span class="line">            cur.stream().forEach(s -&gt; tmp.add(s.val));</span><br><span class="line">            ans.add(tmp);</span><br><span class="line">            deque.clear();</span><br><span class="line"></span><br><span class="line">            level++;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果下一层是奇数 那么从左到右加入</span></span><br><span class="line">            <span class="keyword">if</span> (level % <span class="number">2</span> == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="comment">// 下一层是奇数 那么当前层是偶数 </span></span><br><span class="line">                <span class="comment">// 所以当前层 应该后往前遍历</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> cur.size() - <span class="number">1</span> ; i &gt;= <span class="number">0</span> ; i--)&#123;</span><br><span class="line">                    <span class="type">var</span> <span class="variable">node</span> <span class="operator">=</span> cur.get(i);</span><br><span class="line">                    <span class="keyword">if</span>(node.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                        deque.add(node.left);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (node.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                        deque.add(node.right);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 下一层 是偶数 那么当前层是奇数</span></span><br><span class="line">                <span class="comment">// 也应该倒着来 但是加入顺序不一样</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> cur.size() - <span class="number">1</span> ; i &gt;= <span class="number">0</span>  ; i-- )&#123;</span><br><span class="line">                    <span class="type">var</span> <span class="variable">node</span> <span class="operator">=</span> cur.get(i);</span><br><span class="line">                    <span class="keyword">if</span> (node.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                        deque.add(node.right);</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">if</span> (node.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                        deque.add(node.left);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4><span id="法2-符号标记直接判断-该层是否应该顺序输出">法2 符号标记直接判断 该层是否应该顺序输出</span></h4><p>内核与法1相同但 优雅很多</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">zigzagLevelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isOrder</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        Deque&lt;TreeNode&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        q.offer(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (q.isEmpty() == <span class="literal">false</span>)&#123;</span><br><span class="line">            ArrayList&lt;Integer&gt; tmp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            ArrayList&lt;TreeNode&gt; cur = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(q);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!isOrder)&#123;</span><br><span class="line">                Collections.reverse(cur);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; cur.size() ; i++)&#123;</span><br><span class="line">                tmp.add(cur.get(i).val);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ans.add(tmp);</span><br><span class="line"></span><br><span class="line">            isOrder = !isOrder;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> q.size();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; m ; i++)&#123;</span><br><span class="line">                <span class="type">var</span> <span class="variable">t</span> <span class="operator">=</span> q.poll();</span><br><span class="line">                <span class="keyword">if</span> (t.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                    q.offer(t.left);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (t.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                    q.offer(t.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2><span id="基于图的bfs一般需要一个set来记录访问过的节点">基于图的BFS：（一般需要一个set来记录访问过的节点）</span></h2><h3><span id="leetcode133克隆图">leetcode133.克隆图</span></h3><p>原题链接: <a href="https://leetcode.cn/problems/clone-graph/description/">https://leetcode.cn/problems/clone-graph/description/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">    public int val;</span></span><br><span class="line"><span class="comment">    public List&lt;Node&gt; neighbors;</span></span><br><span class="line"><span class="comment">    public Node() &#123;</span></span><br><span class="line"><span class="comment">        val = 0;</span></span><br><span class="line"><span class="comment">        neighbors = new ArrayList&lt;Node&gt;();</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    public Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        neighbors = new ArrayList&lt;Node&gt;();</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    public Node(int _val, ArrayList&lt;Node&gt; _neighbors) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        neighbors = _neighbors;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * BFS 不断遍历点 进行建图</span></span><br><span class="line"><span class="comment"> * Hash存储遍历过的点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">cloneGraph</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 用于存储 已经访问过的节点 </span></span><br><span class="line">        <span class="comment">// 不用set 是因为要进行重构图 </span></span><br><span class="line">        <span class="comment">// 所以第一个位置原节点的索引 记录了地址hash值 用于标记</span></span><br><span class="line">        <span class="comment">// 而第二个位置 用于新的该节点的引用 用于后续的重建 </span></span><br><span class="line">        HashMap&lt;Node,Node&gt; visited = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 用于BFS</span></span><br><span class="line">        Queue&lt;Node&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        queue.add(node);</span><br><span class="line">        visited.put(node,<span class="keyword">new</span> <span class="title class_">Node</span>(node.val,<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;()));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">            <span class="type">var</span> <span class="variable">t</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 遍历所有邻接节点</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> neighbor : t.neighbors)&#123;</span><br><span class="line">                <span class="keyword">if</span> (!visited.containsKey(neighbor))&#123;</span><br><span class="line">                    <span class="comment">// 先进行标记 </span></span><br><span class="line">                    visited.put(neighbor,<span class="keyword">new</span> <span class="title class_">Node</span>(neighbor.val,<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;()));</span><br><span class="line">                    queue.offer(neighbor);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 进行拷贝 将原节点的链接关系 复制到新的节点 </span></span><br><span class="line">                <span class="comment">// 链接的节点 也一定要从visited中拿 才是新的节建立的节点关系 否则不是深拷贝</span></span><br><span class="line">                visited.get(t).neighbors.add(visited.get(neighbor));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 返回的时 原node  对应的新的节点</span></span><br><span class="line">        <span class="keyword">return</span> visited.get(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3><span id="leetcode-127-单词接龙">leetcode 127 单词接龙</span></h3><p>原题链接:<br><a href="https://leetcode.cn/problems/word-ladder/description/">https://leetcode.cn/problems/word-ladder/description/</a></p><h4><span id="法1-基础bfs">法1 基础BFS</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    String s;</span><br><span class="line">    <span class="type">int</span> step;</span><br><span class="line">    Node(String s,<span class="type">int</span> step)&#123;</span><br><span class="line">        <span class="built_in">this</span>.s = s;</span><br><span class="line">        <span class="built_in">this</span>.step = step;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">cmp</span><span class="params">(String a,String b)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; a.length() ; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a.charAt(i) != b.charAt(i))&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">ladderLength</span><span class="params">(String beginWord, String endWord, List&lt;String&gt; wordList)</span> &#123;  </span><br><span class="line">        <span class="keyword">if</span>(beginWord.equals(endWord))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Queue&lt;Node&gt;q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(); </span><br><span class="line">        q.offer(<span class="keyword">new</span> <span class="title class_">Node</span>(beginWord,<span class="number">1</span>));</span><br><span class="line">        HashSet&lt;String&gt;set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        set.add(beginWord);</span><br><span class="line">        <span class="keyword">while</span>(!q.isEmpty())&#123;</span><br><span class="line">            <span class="type">var</span> <span class="variable">node</span> <span class="operator">=</span> q.poll();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(node.s.equals(endWord))&#123;</span><br><span class="line">                <span class="keyword">return</span> node.step;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">var</span> w:wordList)&#123;</span><br><span class="line">                <span class="keyword">if</span>(set.contains(w))&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(cmp(w,node.s))&#123;</span><br><span class="line">                    set.add(w);</span><br><span class="line">                    q.offer(<span class="keyword">new</span> <span class="title class_">Node</span>(w,node.step + <span class="number">1</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><span id="法2-双向bfs">法2 双向BFS</span></h4><h3><span id="leetcode-130-被围绕的区域">leetcode 130 被围绕的区域</span></h3><p>原题链接:<br><a href="https://leetcode.cn/problems/surrounded-regions/">https://leetcode.cn/problems/surrounded-regions/</a></p><h4><span id="法1-染色">法1: 染色</span></h4><p>先处理完边界  然后按照题意遍历一次进行处理即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> [] dx = <span class="keyword">new</span> <span class="title class_">int</span> [] &#123;-<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> [] dy = <span class="keyword">new</span> <span class="title class_">int</span> [] &#123;<span class="number">0</span>,-<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">char</span> [][] g; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> n,m;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">solve</span><span class="params">(<span class="type">char</span>[][] board)</span> &#123;</span><br><span class="line">        g = board;</span><br><span class="line">        n = board.length;</span><br><span class="line">        m = board[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先把边界上的&#x27;O&#x27; 都先做处理</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; n  ; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(g[i][<span class="number">0</span>] == <span class="string">&#x27;O&#x27;</span>)&#123;</span><br><span class="line">                dfs1(i,<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(g[i][m - <span class="number">1</span>] == <span class="string">&#x27;O&#x27;</span>)&#123;</span><br><span class="line">                dfs1(i,m - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; m ; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(g[<span class="number">0</span>][i] == <span class="string">&#x27;O&#x27;</span>)&#123;</span><br><span class="line">                dfs1(<span class="number">0</span>,i);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(g[n - <span class="number">1</span>][i] == <span class="string">&#x27;O&#x27;</span>)&#123;</span><br><span class="line">                dfs1(n - <span class="number">1</span>,i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; n ; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span> ; j &lt; m ; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(g[i][j] == <span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                    g[i][j] = <span class="string">&#x27;O&#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(g[i][j] == <span class="string">&#x27;O&#x27;</span>)&#123;</span><br><span class="line">                    g[i][j] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        board = g;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs1</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span>&#123;</span><br><span class="line">        g[x][y] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; <span class="number">4</span> ; i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">tx</span> <span class="operator">=</span> x + dx[i];</span><br><span class="line">            <span class="type">int</span> <span class="variable">ty</span> <span class="operator">=</span> y + dy[i];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(tx &lt; <span class="number">0</span> || tx &gt;= n || ty &lt; <span class="number">0</span> || ty &gt;= m || g[tx][ty] != <span class="string">&#x27;O&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            dfs1(tx,ty);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3><span id="leetcode-752-打开转盘锁">leetcode 752 打开转盘锁</span></h3><p>原题链接:<br><a href="https://leetcode.cn/problems/open-the-lock/description/">https://leetcode.cn/problems/open-the-lock/description/</a></p><p>双向BFS</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 全局目标 方便后续在update中的判定</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String tg;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> HashSet&lt;String&gt; dead;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">openLock</span><span class="params">(String[] deadends, String target)</span> &#123;</span><br><span class="line">        <span class="type">var</span> <span class="variable">start</span> <span class="operator">=</span> <span class="string">&quot;0000&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span>(start.equals(target))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        tg = target;</span><br><span class="line"></span><br><span class="line">        dead = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(Arrays.asList(deadends));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(dead.contains(start))&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        HashMap&lt;String,Integer&gt; h1 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        HashMap&lt;String,Integer&gt; h2 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        Queue&lt;String&gt; d1 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        Queue&lt;String&gt; d2 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        d1.offer(start);</span><br><span class="line">        h1.put(start,<span class="number">0</span>);</span><br><span class="line">        d2.offer(target);</span><br><span class="line">        h2.put(target,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!d1.isEmpty() &amp;&amp; !d2.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (d1.size() &lt;= d2.size())&#123;</span><br><span class="line">                t = update(d1,h1,h2);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                t = update(d2,h2,h1);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (t != -<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span>  t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">update</span><span class="params">(Queue&lt;String&gt; queue, HashMap&lt;String,Integer&gt; cur, HashMap&lt;String,Integer&gt;other)</span>&#123;</span><br><span class="line">        <span class="comment">// 双端BFS 要求 每次扩展按层进行扩展</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> queue.size();</span><br><span class="line">        <span class="keyword">while</span> (n-- &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">var</span> <span class="variable">t</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            <span class="type">var</span> <span class="variable">tca</span> <span class="operator">=</span> t.toCharArray();</span><br><span class="line">            <span class="type">int</span> <span class="variable">step</span> <span class="operator">=</span> cur.get(t);</span><br><span class="line">            <span class="comment">// 一共4位 遍历每一位</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; <span class="number">4</span> ; i++)&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> - <span class="number">1</span> ; j &lt; <span class="number">2</span> ; j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span> (j == <span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">ori</span> <span class="operator">=</span> tca[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> (ori + j) % <span class="number">10</span>;</span><br><span class="line">                    <span class="keyword">if</span> (next == -<span class="number">1</span>)&#123;</span><br><span class="line">                        next = <span class="number">9</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="type">var</span> <span class="variable">clone</span> <span class="operator">=</span> tca.clone();</span><br><span class="line">                    clone[i] = (<span class="type">char</span>) (next + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                    <span class="type">var</span> <span class="variable">ct</span> <span class="operator">=</span> String.valueOf(clone);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (dead.contains(ct) || cur.containsKey(ct))&#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 如果再另一方向上找到 说明找到了 最短路径</span></span><br><span class="line">                    <span class="keyword">if</span> (other.containsKey(ct))&#123;</span><br><span class="line">                        <span class="keyword">return</span>  step + <span class="number">1</span> + other.get(ct);</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        cur.put(ct,step + <span class="number">1</span>);</span><br><span class="line">                        queue.offer(ct);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2><span id="多源bfs">多源BFS</span></h2><h3><span id="leetcode-541-01-矩阵">leetcode 541 01 矩阵</span></h3><p>原题链接:<br><a href="https://leetcode.cn/problems/01-matrix/description/">https://leetcode.cn/problems/01-matrix/description/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> [] dx = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;-<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> [] dy = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">0</span>,-<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 多源BFS</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] updateMatrix(<span class="type">int</span>[][] mat) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> mat.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> mat[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span> [][] res = <span class="keyword">new</span> <span class="title class_">int</span>[n][m];</span><br><span class="line">        Queue&lt;<span class="type">int</span> []&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将所有0 入队 </span></span><br><span class="line">        <span class="comment">// 是将要访问的点 标记为-1 记录为未访问过 </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; n ; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span> ; j &lt; m; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (mat[i][j] == <span class="number">0</span>)&#123;</span><br><span class="line">                    q.offer(<span class="keyword">new</span> <span class="title class_">int</span>[] &#123;i,j&#125;);</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    res[i][j] = -<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!q.isEmpty())&#123;</span><br><span class="line">            <span class="type">var</span> <span class="variable">t</span> <span class="operator">=</span> q.poll();</span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> t[<span class="number">0</span>] , y = t[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; <span class="number">4</span> ; i++)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">tx</span> <span class="operator">=</span> x + dx[i];</span><br><span class="line">                <span class="type">int</span> <span class="variable">ty</span> <span class="operator">=</span> y + dy[i];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (tx &lt; <span class="number">0</span> || tx &gt;= n || ty &lt; <span class="number">0</span> || ty &gt;= m || res[tx][ty] != -<span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                res[tx][ty] = res[x][y] + <span class="number">1</span>;</span><br><span class="line">                q.offer(<span class="keyword">new</span> <span class="title class_">int</span>[] &#123;tx , ty&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3><span id="leetcode-1162-地图分析">leetcode 1162  地图分析</span></h3><p>原题链接:<br><a href="https://leetcode.cn/problems/as-far-from-land-as-possible/description/">https://leetcode.cn/problems/as-far-from-land-as-possible/description/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> [] dx = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;-<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> [] dy = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;<span class="number">0</span>,-<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 0 是海洋 1是陆地</span></span><br><span class="line">    <span class="comment">// 要找的是海洋</span></span><br><span class="line">    <span class="comment">// 多源BFS 把所有陆地入队 找到距离陆地最远的海洋</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDistance</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> grid.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span> [][] res = <span class="keyword">new</span> <span class="title class_">int</span>[n][m];</span><br><span class="line"></span><br><span class="line">        Queue&lt;<span class="type">int</span> []&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; n ; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span> ; j &lt; m ; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>)&#123;</span><br><span class="line">                    q.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;i,j&#125;);</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    res[i][j] = -<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!q.isEmpty())&#123;</span><br><span class="line">            <span class="type">var</span> <span class="variable">t</span> <span class="operator">=</span> q.poll();</span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> t[<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> t[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; <span class="number">4</span> ;i++)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">tx</span> <span class="operator">=</span> x + dx[i];</span><br><span class="line">                <span class="type">int</span> <span class="variable">ty</span> <span class="operator">=</span> y + dy[i];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (tx &lt; <span class="number">0</span> || tx &gt;= n || ty &lt; <span class="number">0</span> || ty &gt;= m || res[tx][ty] != -<span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                res[tx][ty] = res[x][y] + <span class="number">1</span>;</span><br><span class="line">                ans = Math.max(ans,res[tx][ty]);</span><br><span class="line">                q.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;tx,ty&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>  ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3><span id="leetcode-1293-网格中的最短路径">leetcode 1293 网格中的最短路径</span></h3><p>原题链接:<br><a href="https://leetcode.cn/problems/shortest-path-in-a-grid-with-obstacles-elimination/">https://leetcode.cn/problems/shortest-path-in-a-grid-with-obstacles-elimination/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> [] dx = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;-<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> [] dy = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">0</span>,-<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">shortestPath</span><span class="params">(<span class="type">int</span>[][] grid, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> grid.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> grid[<span class="number">0</span>].length;</span><br><span class="line">        Queue&lt;<span class="type">int</span> []&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">var</span> <span class="variable">start</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">int</span> [] &#123;<span class="number">0</span>,<span class="number">0</span>,grid[<span class="number">0</span>][<span class="number">0</span>],<span class="number">0</span>&#125;;</span><br><span class="line">        q.offer(start);</span><br><span class="line">        <span class="type">var</span> <span class="variable">visited</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">boolean</span> [n][m][k + <span class="number">1</span>];</span><br><span class="line">        visited[<span class="number">0</span>][<span class="number">0</span>][grid[<span class="number">0</span>][<span class="number">0</span>]] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!q.isEmpty())&#123;</span><br><span class="line">            <span class="type">var</span> <span class="variable">t</span> <span class="operator">=</span> q.poll();</span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> t[<span class="number">0</span>] , y = t[<span class="number">1</span>] , curk = t[<span class="number">2</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">step</span> <span class="operator">=</span> t[<span class="number">3</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; <span class="number">4</span> ; i++)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">tx</span> <span class="operator">=</span> x + dx[i];</span><br><span class="line">                <span class="type">int</span> <span class="variable">ty</span> <span class="operator">=</span> y + dy[i];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (tx &lt; <span class="number">0</span> || tx &gt;= n || ty &lt; <span class="number">0</span> || ty &gt;= m )&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (grid[tx][ty] == <span class="number">1</span> &amp;&amp; curk == k)&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (tx == n - <span class="number">1</span> &amp;&amp; ty == m - <span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> step + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="type">int</span> <span class="variable">tk</span> <span class="operator">=</span> curk + grid[tx][ty];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (visited[tx][ty][tk])&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                visited[tx][ty][tk] = <span class="literal">true</span>;</span><br><span class="line">                q.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;tx,ty,tk,step + <span class="number">1</span>&#125;);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>  -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3><span id="leetcode-417-太平洋大西洋水流问题">leetcode 417 太平洋大西洋水流问题</span></h3><p>原题链接:<br><a href="https://leetcode.cn/problems/pacific-atlantic-water-flow/">https://leetcode.cn/problems/pacific-atlantic-water-flow/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> [] dx = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;-<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> [] dy = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;<span class="number">0</span>,-<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> [][] g;</span><br><span class="line">    <span class="keyword">public</span>  <span class="type">int</span> n,m;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">pacificAtlantic</span><span class="params">(<span class="type">int</span>[][] heights)</span> &#123;</span><br><span class="line">        g = heights;</span><br><span class="line">        n = heights.length;</span><br><span class="line">        m = heights[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">boolean</span> [][] res1 = <span class="keyword">new</span> <span class="title class_">boolean</span>[n][m];</span><br><span class="line">        <span class="type">boolean</span> [][] res2 = <span class="keyword">new</span> <span class="title class_">boolean</span>[n][m];</span><br><span class="line">        <span class="comment">// 太平洋</span></span><br><span class="line">        Queue&lt;<span class="type">int</span>[]&gt; q1 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 大西洋</span></span><br><span class="line">        Queue&lt;<span class="type">int</span>[]&gt; q2 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n ; i++)&#123;</span><br><span class="line">            q1.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;i,<span class="number">0</span>&#125;);</span><br><span class="line">            res1[i][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            q2.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;i,m - <span class="number">1</span>&#125;);</span><br><span class="line">            res2[i][m - <span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m ; i++)&#123;</span><br><span class="line">            q1.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">0</span>,i&#125;);</span><br><span class="line">            res1[<span class="number">0</span>][i] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            q2.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;n - <span class="number">1</span>,i&#125;);</span><br><span class="line">            res2[n - <span class="number">1</span>][i] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        bfs(q1,res1);</span><br><span class="line">        bfs(q2,res2);</span><br><span class="line"></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n ; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; m ; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(res1[i][j] &amp;&amp; res2[i][j])&#123;</span><br><span class="line">                    ans.add(Arrays.asList(i,j));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bfs</span><span class="params">(Queue&lt;<span class="type">int</span>[]&gt;q, <span class="type">boolean</span> [][] res)</span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!q.isEmpty())&#123;</span><br><span class="line">            <span class="type">var</span> <span class="variable">t</span> <span class="operator">=</span> q.poll();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span> ; i++)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> t[<span class="number">0</span>] + dx[i];</span><br><span class="line">                <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> t[<span class="number">1</span>] + dy[i];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt;= n || y &lt; <span class="number">0</span> || y &gt;= m)&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (g[x][y] &lt;  g[t[<span class="number">0</span>]][t[<span class="number">1</span>]] || res[x][y])&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                res[x][y] = <span class="literal">true</span>;</span><br><span class="line">                q.offer(<span class="keyword">new</span> <span class="title class_">int</span>[] &#123;x,y&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2><span id="拓扑排序">拓扑排序</span></h2><p>原题链接:<br><a href="https://leetcode.cn/problems/course-schedule/">https://leetcode.cn/problems/course-schedule/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canFinish</span><span class="params">(<span class="type">int</span> numCourses, <span class="type">int</span>[][] prerequisites)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> prerequisites.length;</span><br><span class="line">        <span class="comment">// 存图</span></span><br><span class="line">        HashMap&lt;Integer,ArrayList&lt;Integer&gt;&gt; g = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 存度</span></span><br><span class="line">        <span class="type">int</span> [] in = <span class="keyword">new</span> <span class="title class_">int</span>[numCourses];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] prerequisite : prerequisites) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> prerequisite[<span class="number">0</span>], b = prerequisite[<span class="number">1</span>];</span><br><span class="line">            <span class="type">var</span> <span class="variable">arr</span> <span class="operator">=</span> g.getOrDefault(b, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">            arr.add(a);</span><br><span class="line">            in[a]++;</span><br><span class="line">            g.put(b, arr);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Queue&lt;Integer&gt;  q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numCourses ; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (in[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                q.offer(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!q.isEmpty())&#123;</span><br><span class="line">            <span class="type">var</span> <span class="variable">t</span> <span class="operator">=</span> q.poll();</span><br><span class="line">            ans++;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (g.get(t) == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> next : g.get(t))&#123;</span><br><span class="line">                in[next]--;</span><br><span class="line">                <span class="keyword">if</span> (in[next] == <span class="number">0</span>)&#123;</span><br><span class="line">                    q.offer(next);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans == numCourses;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>leetcode318最长长度乘积</title>
      <link href="/2023/11/06/leetcode/leetcode318%E6%9C%80%E9%95%BF%E5%8D%95%E8%AF%8D%E9%95%BF%E5%BA%A6%E4%B9%98%E7%A7%AF/"/>
      <url>/2023/11/06/leetcode/leetcode318%E6%9C%80%E9%95%BF%E5%8D%95%E8%AF%8D%E9%95%BF%E5%BA%A6%E4%B9%98%E7%A7%AF/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>原题链接:<br><a href="https://leetcode.cn/problems/maximum-product-of-word-lengths/description/">https://leetcode.cn/problems/maximum-product-of-word-lengths/description/</a></p><h2><span id="解法1-简单位运算模拟">解法1: 简单位运算模拟</span></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProduct</span><span class="params">(String[] words)</span> &#123;</span><br><span class="line">        HashMap&lt;Integer,Integer&gt; hash = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> ss : words)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; ss.length() ; i++)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> ss.charAt(i) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                t |= (<span class="number">1</span> &lt;&lt; u);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> hash.getOrDefault(t,<span class="number">0</span>);</span><br><span class="line">            hash.put(t,Math.max(l,ss.length()));</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> a : hash.keySet())&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> b: hash.keySet())&#123;</span><br><span class="line">                <span class="keyword">if</span>((a &amp; b) == <span class="number">0</span>)&#123;</span><br><span class="line">                    ans = Math.max(ans,hash.get(a) * hash.get(b));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>code通过删除字母匹配到字典序里最长单词(高频华为出现多次!!!)</title>
      <link href="/2023/11/03/%E9%9D%A2%E8%AF%95%E7%9C%9F%E9%A2%98/code%E9%80%9A%E8%BF%87%E5%88%A0%E9%99%A4%E5%AD%97%E6%AF%8D%E5%8C%B9%E9%85%8D%E5%88%B0%E5%AD%97%E5%85%B8%E9%87%8C%E6%9C%80%E9%95%BF%E5%8D%95%E8%AF%8D/"/>
      <url>/2023/11/03/%E9%9D%A2%E8%AF%95%E7%9C%9F%E9%A2%98/code%E9%80%9A%E8%BF%87%E5%88%A0%E9%99%A4%E5%AD%97%E6%AF%8D%E5%8C%B9%E9%85%8D%E5%88%B0%E5%AD%97%E5%85%B8%E9%87%8C%E6%9C%80%E9%95%BF%E5%8D%95%E8%AF%8D/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>华为一面\华为主管面 手撕代码题目</p><p>原题链接:<br><a href="https://leetcode.cn/problems/longest-word-in-dictionary-through-deleting/description/">https://leetcode.cn/problems/longest-word-in-dictionary-through-deleting/description/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 贪心 + 双指针</span></span><br><span class="line"><span class="comment"> 删除某些字母得到 = 该单词为字符串s的子序列 且 是有序的</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> 按照长度排序 那么最先匹配完成的就是就是符合答案的</span></span><br><span class="line"><span class="comment"> 题目又要求字典序最小 那就再按照字典序进行排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">findLongestWord</span><span class="params">(String s, List&lt;String&gt; dictionary)</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * compareTo 相等返回 0</span></span><br><span class="line"><span class="comment">        *           小于返回 -1</span></span><br><span class="line"><span class="comment">        *           大于返回 1</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line">        Collections.sort(dictionary,(o1,o2)-&gt;&#123;</span><br><span class="line">            <span class="keyword">if</span>(o1.length() == o2.length())&#123;</span><br><span class="line">                <span class="keyword">return</span> o1.compareTo(o2);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> o2.length() - o1.length();</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> ss: dictionary)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> ss.length();</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; n &amp;&amp; j &lt; m)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s.charAt(i) == ss.charAt(j))&#123;</span><br><span class="line">                    j++;</span><br><span class="line">                &#125;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j == m)&#123;</span><br><span class="line">                <span class="keyword">return</span> ss;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试真题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
            <tag> 贪心 </tag>
            
            <tag> 华为校招 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>code最长上升子序列</title>
      <link href="/2023/11/03/%E9%9D%A2%E8%AF%95%E7%9C%9F%E9%A2%98/code%E6%9C%80%E9%95%BF%E4%B8%8A%E5%AD%90%E5%BA%8F%E5%88%97/"/>
      <url>/2023/11/03/%E9%9D%A2%E8%AF%95%E7%9C%9F%E9%A2%98/code%E6%9C%80%E9%95%BF%E4%B8%8A%E5%AD%90%E5%BA%8F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>字节校招面试 手撕代码题</p><p>原题链接<br><a href="https://www.acwing.com/problem/content/897/">https://www.acwing.com/problem/content/897/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 动态规划 f[i] 表示 结尾为i 数值严格单调递增的子序列的最长度值为f[i]</span></span><br><span class="line"><span class="comment">* f[i] = max(f[j] + 1, f[i])</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> [] q = <span class="keyword">new</span> <span class="title class_">int</span>[N];</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        n = sc.nextInt();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; n ; i++)&#123;</span><br><span class="line">            q[i] = sc.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// f[i] 仅仅代表以i结尾的子序列的最长长度 并不代表全局的最大值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> [] f = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; n ; i++)&#123;</span><br><span class="line">            <span class="comment">// 最小长度就是 自己自身</span></span><br><span class="line">            f[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span> ; j &lt; i ; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(q[i] &gt; q[j])&#123;</span><br><span class="line">                    f[i] = Math.max(f[i],f[j] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                ans = Math.max(ans,f[i]);    </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试真题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字节校招 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javaIO</title>
      <link href="/2023/11/03/interview/javaIO/"/>
      <url>/2023/11/03/interview/javaIO/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1><span id="io-概述">IO 概述</span></h1><p>I: input O:Output 流: 像水流一样传输数据</p><p>内存不能永久化存储 程序停止  数据丢失  </p><p>IO流: 存储和读取数据的解决方案</p><p>File : 表示系统中的文件或者文件夹的路径 (获取文件信息 判断文件的类型 创建文件&#x2F;文件夹 删除文件&#x2F;文件夹 … )<br>注意: File类只能对文件本身进行操作  <strong>不能读写文件里面存储的数据</strong></p><p>IO流 用于读写文件中的数据(可以读写文件 或 网络中的数据)</p><p>问: IO流中 谁在读 谁在写？ 以谁为参照物看读写的方向呢？<br>答: 以程序为参照物 是程序在读 程序在写</p><h1><span id="io的分类">IO的分类</span></h1><img src="/2023/11/03/interview/javaIO/img1.png" style="zoom:100%"><p>纯文本文件： windows自带记事本能打开且能读懂的就是纯文本</p><h1><span id="io流的体系">IO流的体系</span></h1><img src="/2023/11/03/interview/javaIO/img2.png" style="zoom:100%"><img src="/2023/11/03/interview/javaIO/img3.png" style="zoom:100%"><h1><span id="字节流">字节流</span></h1><h2><span id="fileoutputstream">FileOutputStream</span></h2><p>操作本地文件的字节输出流体 可以把程序中的数据写到本地文件中</p><p>代码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 字节输出流 FileOutputStream</span></span><br><span class="line"><span class="comment">         *  实现步骤:</span></span><br><span class="line"><span class="comment">         *      创建对象</span></span><br><span class="line"><span class="comment">         *          细节1: 参数是字符串表示的路径或者是File对象都是可以的</span></span><br><span class="line"><span class="comment">         *          细节2: 如果文件不存在会创建一个新的文件 但是要保证父级路径是存在的</span></span><br><span class="line"><span class="comment">         *          细节3: 如果文件已经存在 则会清空文件</span></span><br><span class="line"><span class="comment">         *      写出数据</span></span><br><span class="line"><span class="comment">         *          细节: write 方法参数是整数 但是实际上写到本地文件中的是整数在ASCII上对应的字符</span></span><br><span class="line"><span class="comment">         *          97 --&gt; a</span></span><br><span class="line"><span class="comment">         *      释放资源</span></span><br><span class="line"><span class="comment">         *          每次使用完流之后都要释放资源</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 创建对象</span></span><br><span class="line">        <span class="comment">// 写出 输出流 OutputStream</span></span><br><span class="line">        <span class="comment">// 本地文件 File</span></span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fileOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;notes_IO\\a.txt&quot;</span>); <span class="comment">// 指定文件的路径</span></span><br><span class="line">        <span class="comment">// 写出数据</span></span><br><span class="line">        fileOutputStream.write(<span class="number">97</span>);     <span class="comment">// 这里写入的是a</span></span><br><span class="line">        <span class="comment">// 释放资源</span></span><br><span class="line">        fileOutputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3><span id="fileoutputstream写数据的3种方式">FileOutputStream写数据的3种方式</span></h3><img src="/2023/11/03/interview/javaIO/img4.png" style="zoom:100%"><p>代码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ByteStreamDemo3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fileOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;notes_IO\\a.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 一次写一个字节数据</span></span><br><span class="line">        fileOutputStream.write(<span class="number">97</span>);</span><br><span class="line">        fileOutputStream.write(<span class="number">98</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 一次写一个字符数据数据</span></span><br><span class="line">        <span class="type">byte</span> [] bytes = &#123;<span class="number">97</span>,<span class="number">98</span>,<span class="number">99</span>,<span class="number">101</span>&#125;;</span><br><span class="line">        fileOutputStream.write(bytes);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 一次写一个字节数组的部分数据</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 参数一: 数组</span></span><br><span class="line"><span class="comment">        * 参数二: 起始索引</span></span><br><span class="line"><span class="comment">        * 参数三: 个数</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line">        fileOutputStream.write(bytes,<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        fileOutputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3><span id="fileoutputstream-换行与续写">FileOutputStream 换行与续写</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.UnsupportedEncodingException;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ByteStreamDemo4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 换行写:</span></span><br><span class="line"><span class="comment">        *   再次写出一个换行符就可以了</span></span><br><span class="line"><span class="comment">        *   windows: \r\n</span></span><br><span class="line"><span class="comment">        *   Linux: \n</span></span><br><span class="line"><span class="comment">        *   Mac: \r</span></span><br><span class="line"><span class="comment">        * 细节:</span></span><br><span class="line"><span class="comment">        *   在windows操作系统当中 java对回车换行进行了优化</span></span><br><span class="line"><span class="comment">        *   虽然完整的\r\n 但是我们写其中一个\r 或者 \n</span></span><br><span class="line"><span class="comment">        *   java也可以实现换行 因为java在底层会补全</span></span><br><span class="line"><span class="comment">        * 建议:</span></span><br><span class="line"><span class="comment">        *   不要省略 还是要写全</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * 续写:</span></span><br><span class="line"><span class="comment">        *   如果想要续写 打开续写开关即可</span></span><br><span class="line"><span class="comment">        *   开关位置: 创建对象的第二个参数</span></span><br><span class="line"><span class="comment">        *   默认: false 此时创建对象会清空文件 手动传递true 表示打开续写 此时创建对象不会清空文件</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 创建对象</span></span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fileOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;notes_IO\\a.txt&quot;</span>,<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">// 2. 写出数据</span></span><br><span class="line">        <span class="comment">// kankelaoyezuishui</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;kankelaoyezuishui&quot;</span>;</span><br><span class="line">        <span class="type">byte</span>[] bytes = str.getBytes();</span><br><span class="line">        fileOutputStream.write(bytes);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 换行</span></span><br><span class="line">        <span class="comment">// 再次写出一个换行符实现换行</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">wrap</span> <span class="operator">=</span> <span class="string">&quot;\r\n&quot;</span>;</span><br><span class="line">        <span class="type">byte</span>[] wrapBytes = wrap.getBytes();</span><br><span class="line">        fileOutputStream.write(wrapBytes);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;666&quot;</span>;</span><br><span class="line">        <span class="type">byte</span>[] bytes2 = str2.getBytes();</span><br><span class="line">        fileOutputStream.write(bytes2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 释放资源</span></span><br><span class="line">        fileOutputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2><span id="fileinputstream">FileInputStream</span></h2><p>操作本地文件的字节输入流 可以把本地文件中的数据读取到程序中来</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ByteStreamDemo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 字节输入流 FileInputStream</span></span><br><span class="line"><span class="comment">         * 实现需求 读取文件中的数据</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 实现步骤:</span></span><br><span class="line"><span class="comment">         *  创建对象</span></span><br><span class="line"><span class="comment">         *      1. 如果文件不存在直接报错</span></span><br><span class="line"><span class="comment">         *      Java为什么这么设计?</span></span><br><span class="line"><span class="comment">         *      输出流: 不存在 创建</span></span><br><span class="line"><span class="comment">         *          把数据写到文件当中 (数据是程序中存在的)</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         *      输入流: 不存在 而是报错呢?</span></span><br><span class="line"><span class="comment">         *      因为创建出来的文件是没有数据的 这样的文件没有任何意义</span></span><br><span class="line"><span class="comment">         *      所以Java就没有设计这种无意义的逻辑 文件不存在直接报错</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         *      程序中最重要的是 数据</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         *  读取数据</span></span><br><span class="line"><span class="comment">         *      1. 一次读一个字节 读出来的数据实在ASCII上对应的数字</span></span><br><span class="line"><span class="comment">         *      2. 读到文件末尾了 read方法返回-1</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         *  释放资源</span></span><br><span class="line"><span class="comment">         *      每次使用完流 必须要释放资源</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建对象</span></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;notes_IO\\a.txt&quot;</span>);</span><br><span class="line">        <span class="comment">// 读取数据</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">b1</span> <span class="operator">=</span> fileInputStream.read();</span><br><span class="line">        System.out.println((<span class="type">char</span>) b1);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">b2</span> <span class="operator">=</span> fileInputStream.read();</span><br><span class="line">        System.out.println((<span class="type">char</span>) b2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放资源</span></span><br><span class="line">        fileInputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="fileinputstream循环读取">FileInputStream循环读取</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ByteStreamDemo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        *   字节循环流读取</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 创建对象</span></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;notes_IO\\a.txt&quot;</span>);</span><br><span class="line">        <span class="comment">// 2. 循环读取</span></span><br><span class="line">        <span class="type">int</span> b;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * read: 表示读取数据 而且是读取一个数据就移动一次指针</span></span><br><span class="line"><span class="comment">         * 书写时一定要定义第三方变量 b</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">while</span> ((b = fis.read()) != -<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println((<span class="type">char</span>) b);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放资源</span></span><br><span class="line">        fis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1><span id="为什么会有乱码">为什么会有乱码?</span></h1><p>原因1: 读取时未读完整个汉字<br>原因2: 编码和解码时的方式不统一 -&gt; 统一 UTF-8</p><h1><span id="字符流">字符流</span></h1><p>字符流的底层其实就是字节流<br>字符流 &#x3D; 字节流 + 字符集</p><p>特点:<br>输入流: 一次读一个字节 遇到中文 一次读多个字节<br>输出流: 底层会把数据按照指定的编码形式进行编码 变成字节再写到文件中</p><p>使用场景:<br>对于纯文本文件进行读写操作</p><h2><span id="filereader">FileReader</span></h2><img src="/2023/11/03/interview/javaIO/img5.png" style="zoom:100%"><img src="/2023/11/03/interview/javaIO/img6.png" style="zoom:100%"><h3><span id="空参-read">空参 read</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CharStreamDemo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        *   创建对象</span></span><br><span class="line"><span class="comment">        *   读取数据</span></span><br><span class="line"><span class="comment">        *   释放资源</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.创建对象 关联本地文件</span></span><br><span class="line">        <span class="type">FileReader</span> <span class="variable">fileReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;notes_IO\\a.txt&quot;</span>);</span><br><span class="line">        <span class="comment">// 2.读取资源 read()</span></span><br><span class="line">        <span class="comment">// 字符流的底层也是字节流 默认也是一个字节一个的读取的</span></span><br><span class="line">        <span class="comment">// 如果遇到中文就会一次读取多个 GBK一次读两个字节 UTF-8一次读三个字节</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 1. read(): 默认也是一个字节一个字节的读取 如果遇到中文就会一次读取多个</span></span><br><span class="line"><span class="comment">         * 2. 在读取之后 方法的底层还会进行解码并转成十进制</span></span><br><span class="line"><span class="comment">         * 最终把这个十进制作为返回值</span></span><br><span class="line"><span class="comment">         * 这个十进制的数据也表示在字符集上的数字</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 英文: 在文件里面二进制数据 0110 0001</span></span><br><span class="line"><span class="comment">         * read 方法进行读取 解码并转成十进制97</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 中文: 文件里的二进制数据 11100110 10110001 10001001</span></span><br><span class="line"><span class="comment">         * read方法进行读取 解码并转换成是继子女hi 27721</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 十进制强转 -&gt; 汉字</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ch;</span><br><span class="line">        <span class="keyword">while</span> ((ch = fileReader.read()) != -<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println((<span class="type">char</span>) ch);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放资源</span></span><br><span class="line">        fileReader.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3><span id="带参-read">带参 read</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CharStreamDemo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">FileReader</span> <span class="variable">fileReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;notes_IO\\a.txt&quot;</span>);</span><br><span class="line">        <span class="comment">// 长度为2 表示一次读两个</span></span><br><span class="line">        <span class="type">char</span>[] chars = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="comment">// read(chars): 读取数据 解码 强转 三步合并了 把强转之后的字符放到数组当中</span></span><br><span class="line">        <span class="comment">// 空参的read + 强制类型转换</span></span><br><span class="line">        <span class="keyword">while</span> ((len = fileReader.read(chars))!= -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">// 把数组中的数据变成字符串再进行打印</span></span><br><span class="line">            System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(chars,<span class="number">0</span>,len));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fileReader.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2><span id="filewriter">FileWriter</span></h2><img src="/2023/11/03/interview/javaIO/img8.png" style="zoom:100%"><img src="/2023/11/03/interview/javaIO/img9.png" style="zoom:100%"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CharStreamDemo3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// true表示续写开关 每次写的时候不会清空 而是接着下去</span></span><br><span class="line">        <span class="type">FileWriter</span> <span class="variable">fileReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;notes_IO\\a.txt&quot;</span>,<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 写出一个字符</span></span><br><span class="line">        <span class="comment">// 根据字符集的编码方式进行编码</span></span><br><span class="line">        <span class="comment">// 把编码之后的数据写到文件中取 UTF-8</span></span><br><span class="line">        <span class="comment">// &#x27;我&#x27; -&gt; 25105</span></span><br><span class="line">        fileReader.write(<span class="number">25105</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 写出一个字符串</span></span><br><span class="line">        fileReader.write(<span class="string">&quot;你好啊！！！&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 写出一个字符数组</span></span><br><span class="line">        <span class="type">char</span> [] chars = &#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;v&#x27;</span>,<span class="string">&#x27;k&#x27;</span>,<span class="string">&#x27;元&#x27;</span>&#125;;</span><br><span class="line">        fileReader.write(chars);</span><br><span class="line"></span><br><span class="line">        fileReader.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2><span id="字符流原理解析">字符流原理解析</span></h2><h3><span id="字符输入流的底层原理">字符输入流的底层原理</span></h3><img src="/2023/11/03/interview/javaIO/img10.png" style="zoom:100%"><h3><span id="字符输出流的底层原理">字符输出流的底层原理</span></h3>]]></content>
      
      
      <categories>
          
          <category> interview </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode74搜索二分矩阵</title>
      <link href="/2023/11/01/leetcode/leetcode74%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5/"/>
      <url>/2023/11/01/leetcode/leetcode74%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>原题链接:<br><a href="https://leetcode.cn/problems/search-a-2d-matrix/description/">https://leetcode.cn/problems/search-a-2d-matrix/description/</a></p><h2><span id="解法1-二次二分">解法1: 二次二分</span></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    两次二分</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">searchMatrix</span><span class="params">(<span class="type">int</span>[][] matrix, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="comment">// 二分合适的行</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> -<span class="number">1</span> , r = matrix.length;</span><br><span class="line">        <span class="keyword">while</span>(l + <span class="number">1</span> &lt; r)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// l target mid r</span></span><br><span class="line">            <span class="keyword">if</span>(matrix[mid][<span class="number">0</span>] &gt;= target)&#123;</span><br><span class="line">                r = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                l = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> r;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( row &gt;= matrix.length ||  row &gt; <span class="number">0</span> &amp;&amp; matrix[row][<span class="number">0</span>] &gt; target )&#123;</span><br><span class="line">            row--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// System.out.println(row);</span></span><br><span class="line">        l = - <span class="number">1</span> ;</span><br><span class="line">        r = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">while</span>(l + <span class="number">1</span> &lt; r)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(matrix[row][mid] &gt;= target)&#123;</span><br><span class="line">                r = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                l = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(r &gt;= matrix[<span class="number">0</span>].length)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> matrix[row][r] == target; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2><span id="解法2-一次二分">解法2: 一次二分</span></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> m;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">searchMatrix</span><span class="params">(<span class="type">int</span>[][] matrix, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        n = matrix.length;</span><br><span class="line">        m = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> -<span class="number">1</span> , r = n * m;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(l + <span class="number">1</span> &lt; r)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> get(mid)[<span class="number">0</span>], y = get(mid)[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(matrix[x][y] &gt;= target)&#123;</span><br><span class="line">                r = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                l = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(r &gt;= n * m)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> matrix[get(r)[<span class="number">0</span>]][get(r)[<span class="number">1</span>]] == target; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将一维 坐标转化为 二维</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> [] get(<span class="type">int</span> x)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span> []&#123;x / m , x % m&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2><span id="解法3-抽象bst">解法3: 抽象BST</span></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> n,m;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">searchMatrix</span><span class="params">(<span class="type">int</span>[][] matrix, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="comment">// 右上角作为BST的根 其实也是二分的思想</span></span><br><span class="line">        n = matrix.length;</span><br><span class="line">        m = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span> , y = m - <span class="number">1</span>;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">while</span>(x &lt; n &amp;&amp; y &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[x][y] == target)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(matrix[x][y] &gt; target)&#123;</span><br><span class="line">                y--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                x++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode895最大频率栈</title>
      <link href="/2023/10/30/leetcode/leetcode895%E6%9C%80%E5%A4%A7%E9%A2%91%E7%8E%87%E6%A0%88/"/>
      <url>/2023/10/30/leetcode/leetcode895%E6%9C%80%E5%A4%A7%E9%A2%91%E7%8E%87%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>原题链接:<br><a href="https://leetcode.cn/problems/maximum-frequency-stack/description/">https://leetcode.cn/problems/maximum-frequency-stack/description/</a></p><h2><span id="解法1-双哈希">解法1: 双哈希</span></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    双哈希 </span></span><br><span class="line"><span class="comment">    一个hash记录值 及其 对应的出现次数</span></span><br><span class="line"><span class="comment">    另一个hash 记录 次数出现相同的数 的集合 </span></span><br><span class="line"><span class="comment">    max 记录当前出现的最大频率 即根据题意需要返回的数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FreqStack</span> &#123;</span><br><span class="line">    <span class="comment">// 出现次数 以及 对应的数</span></span><br><span class="line">    HashMap&lt;Integer,List&lt;Integer&gt;&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 记录每个数出现的次数</span></span><br><span class="line">    HashMap&lt;Integer,Integer&gt; cnts = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> max;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FreqStack</span><span class="params">()</span> &#123;</span><br><span class="line">        map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        cnts = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        max = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">freq</span> <span class="operator">=</span> cnts.getOrDefault(val,<span class="number">0</span>);</span><br><span class="line">        freq++;</span><br><span class="line">        <span class="comment">// 更新出现的次数</span></span><br><span class="line">        cnts.put(val,freq);</span><br><span class="line">        <span class="comment">// 得到出现 相对应的数的集合</span></span><br><span class="line">        <span class="type">var</span> <span class="variable">arr</span> <span class="operator">=</span> map.getOrDefault(freq,<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">        arr.add(val);</span><br><span class="line">        <span class="comment">// 更新map</span></span><br><span class="line">        map.put(freq,arr);</span><br><span class="line">        <span class="comment">// 更新最大出现频率</span></span><br><span class="line">        max = Math.max(max,freq);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 得到当前最大元素 对应出现的数</span></span><br><span class="line">        <span class="type">var</span> <span class="variable">arr</span> <span class="operator">=</span> map.get(max); </span><br><span class="line">        <span class="comment">// 移除 最新加入 最大出现频率集合的数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> arr.remove(arr.size() - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 更新该数出现的次数</span></span><br><span class="line">        cnts.put(ans,cnts.get(ans) - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 如果当前最大频率对应的出现的数集合 长度为0 更新最大长度</span></span><br><span class="line">        <span class="keyword">if</span>(arr.size() == <span class="number">0</span>)&#123;</span><br><span class="line">            max--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your FreqStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * FreqStack obj = new FreqStack();</span></span><br><span class="line"><span class="comment"> * obj.push(val);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj.pop();</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双哈希 </tag>
            
            <tag> 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java多线程基础</title>
      <link href="/2023/10/30/interview/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
      <url>/2023/10/30/interview/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2><span id="什么是多线程">什么是多线程</span></h2><p>线程<br>进程</p><h2><span id="为什么要有多线程">为什么要有多线程</span></h2><p>应用场景</p><h2><span id="多线程的两个概念">多线程的两个概念</span></h2><p>并发 在同一时刻 有多个指令在单个CPU上交替执行<br>并行 在同一时刻 有多个指令在多个CPU上同时执行</p><h2><span id="多线程的实现方式">多线程的实现方式</span></h2><ol><li>继承Thread类的方式进行实现</li><li>实现Runnable接口的方式进行实现</li><li>利用Callable接口和Future接口方式实现</li></ol><h3><span id="继承thread类的方式进行实现">继承Thread类的方式进行实现</span></h3><p>代码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread1</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 书写线程要执行的代码</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(getName() + <span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *  多线程的第一种启动方式:</span></span><br><span class="line"><span class="comment">         * 1. 定义一个类继承Thread</span></span><br><span class="line"><span class="comment">         * 2. 重写run方法</span></span><br><span class="line"><span class="comment">         * 3. 创建子类的对象 并启动线程</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="type">MyThread1</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread1</span>();</span><br><span class="line">        <span class="type">MyThread1</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread1</span>();</span><br><span class="line">        t1.setName(<span class="string">&quot;线程1&quot;</span>);</span><br><span class="line">        t2.setName(<span class="string">&quot;线程2&quot;</span>);</span><br><span class="line">        <span class="comment">// 开启线程  </span></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3><span id="实现runnable接口的方式进行实现">实现Runnable接口的方式进行实现</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRun</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 书写线程要执行的代码</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 获取到当前线程的对象</span></span><br><span class="line">            <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">            System.out.println(thread.getName() + <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 多线程的第二种启动方式:</span></span><br><span class="line"><span class="comment">         * 1. 自己定义一个类实现Runnable接口</span></span><br><span class="line"><span class="comment">         * 2，重写里面的run方法</span></span><br><span class="line"><span class="comment">         * 3. 创建自己的类的对象</span></span><br><span class="line"><span class="comment">         * 4. 创建一个Thread类的对象 并开启线程</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建MyRun对象</span></span><br><span class="line">        <span class="type">MyRun</span> <span class="variable">myRun</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRun</span>();</span><br><span class="line">        <span class="comment">// 表示多线程要执行的任务</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(myRun);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(myRun);</span><br><span class="line">        t3.setName(<span class="string">&quot;线程3&quot;</span>);</span><br><span class="line">        t4.setName(<span class="string">&quot;线程4&quot;</span>);</span><br><span class="line">        <span class="comment">// 开启线程</span></span><br><span class="line">        t3.start();</span><br><span class="line">        t4.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3><span id="实现callable接口">实现Callable接口</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCallable</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;Integer&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 求1~100之间的和</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 多线程的第三种实现方式</span></span><br><span class="line"><span class="comment">         * 特点: 可以获取到多线程运行的结果</span></span><br><span class="line"><span class="comment">         * 1. 创建一个类MyCallable 实现Callable接口</span></span><br><span class="line"><span class="comment">         * 2. 重写call (是有返回值的, 表示多线程运行的结果)</span></span><br><span class="line"><span class="comment">         * 3. 创建MyCallable的对象(表示多线程要执行的任务)</span></span><br><span class="line"><span class="comment">         * 4，创建FutureTask的对象(作用管理多线程运行的结果)</span></span><br><span class="line"><span class="comment">         * 5.创建Thread类的对象 并启动(表示线程)</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="type">MyCallable</span> <span class="variable">myCallable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyCallable</span>();</span><br><span class="line">        FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(myCallable);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask);</span><br><span class="line">        t5.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取多线程运行的结果</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">ans</span> <span class="operator">=</span> futureTask.get();</span><br><span class="line">        System.out.println(ans);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2><span id="常见的成员方法">常见的成员方法</span></h2><img src="/2023/10/30/interview/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/img1.png" style="zoom:100%"><p>基础方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread2</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyThread2</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyThread2</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(getName() + <span class="string">&quot;@&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * String getName()</span></span><br><span class="line"><span class="comment">         * void setName(String name)</span></span><br><span class="line"><span class="comment">         * 细节:</span></span><br><span class="line"><span class="comment">         *  如果没有给线程设置名字 线程也是有默认的名字</span></span><br><span class="line"><span class="comment">         *      格式: Thread-X (X序号 , 从0开始)</span></span><br><span class="line"><span class="comment">         *   如果要给线程设置名字 可以用set方法 也可以构造方法设置</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         *  static Thread currentThread() 获取当前线程对象</span></span><br><span class="line"><span class="comment">         *  细节:</span></span><br><span class="line"><span class="comment">         *      当JVM虚拟机启动之后 会自动的启动多条线程</span></span><br><span class="line"><span class="comment">         *      其中有一条就叫main方法 并执行里面的代码</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         *  static void sleep(long time) 让线程休眠指定的时间 单位毫秒</span></span><br><span class="line"><span class="comment">         *  细节:</span></span><br><span class="line"><span class="comment">         *      哪条线程执行到这个方法 那么哪条线程就会在这里停留对应的时间</span></span><br><span class="line"><span class="comment">         *      时间到了之后 线程会自动醒来 继续执行下面的其他代码</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="type">MyThread2</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread2</span>(<span class="string">&quot;aa&quot;</span>);</span><br><span class="line">        <span class="type">MyThread2</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread2</span>(<span class="string">&quot;bb&quot;</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 哪条线程执行到这个方法 此时获取的就是哪条线程的对象</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> t.getName();</span><br><span class="line">        System.out.println(name); <span class="comment">// main</span></span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3><span id="线程优先级">线程优先级</span></h3><p>java采取的线程调度 是抢占式调度</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * setPriority(int newPriority) 设置线程的优先级</span></span><br><span class="line"><span class="comment">        * final int getPriority()  获取线程的优先级</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line"></span><br><span class="line">        <span class="type">MyRunnable</span> <span class="variable">myRunnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="string">&quot;aa&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="string">&quot;bb&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 默认为5 最小为1 最大为10</span></span><br><span class="line">        t1.setPriority(<span class="number">1</span>);</span><br><span class="line">        t2.setPriority(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3><span id="守护线程">守护线程</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * public final void setDaemon(boolean on) 设置为守护线程</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * 细节:</span></span><br><span class="line"><span class="comment">        *   当其他的非守护线程执行完毕后  守护线程会陆续结束(不是马上结束)</span></span><br><span class="line"><span class="comment">        * 即 当非守护线程结束后 那么守护线程也没有存在的必要了</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line"></span><br><span class="line">        <span class="type">MyThread1</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread1</span>();</span><br><span class="line">        <span class="type">MyThread2</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread2</span>();</span><br><span class="line"></span><br><span class="line">        t1.setName(<span class="string">&quot;aa&quot;</span>);</span><br><span class="line">        t2.setName(<span class="string">&quot;bb&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把第二个线程设置为守护线程</span></span><br><span class="line">        t2.setDaemon(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3><span id="礼让线程">礼让线程</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * public static void yield()  出让线程/礼让线程</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 尽可能让结果均匀一点 但不是绝对的 用的比较少</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">MyThread1</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread1</span>();</span><br><span class="line">        <span class="type">MyThread1</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread1</span>();</span><br><span class="line"></span><br><span class="line">        t1.setName(<span class="string">&quot;aa&quot;</span>);</span><br><span class="line">        t2.setName(<span class="string">&quot;bb&quot;</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="插入线程">插入线程</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * public static void yield()  出让线程/礼让线程</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 尽可能让结果均匀一点 但不是绝对的 用的比较少</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">MyThread1</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread1</span>();</span><br><span class="line">        t1.setName(<span class="string">&quot;土豆&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 表示把t这个线程 插入到当前线程之前</span></span><br><span class="line">        <span class="comment">// t: 土豆</span></span><br><span class="line">        <span class="comment">// 当前线程 main线程</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;main线程&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2><span id="线程的生命周期">线程的生命周期</span></h2><img src="/2023/10/30/interview/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/img2.png" style="zoom:100%"><p>问: sleep方法会让线程睡眠 睡眠时间到了之后 立马就会执行下面的代码吗？<br>不会因为线程在进入就绪状态后还要有CPU资源才行</p><h2><span id="线程安全">线程安全</span></h2><p>示例：<br>买票引发的安全问题:</p><ol><li>相同的票出现了多次</li><li>出现了超出范围的票</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="comment">// 表示这个类所有的对象 都共享ticket数据</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ticket &lt; <span class="number">100</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                ticket++;</span><br><span class="line">                System.out.println(getName() + <span class="string">&quot;正在卖第&quot;</span> + ticket );</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>原因:<br>线程执行的随机性</p><h3><span id="同步代码块">同步代码块</span></h3><p>把操作共享数据的代码锁起来</p><p>格式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (锁)&#123;</span><br><span class="line">    操作共享数据的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>特点1: 锁默认打开 有一个线程进去了 锁自动关闭<br>特点2: 里面的代码全部执行完毕 线程出来 锁自动打开 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="comment">// 表示这个类所有的对象 都共享ticket数据</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 锁对象 一定要是唯一的</span></span><br><span class="line"><span class="comment">//    static Object obj = new Object();</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="comment">// synchronized 要写在循环的内部</span></span><br><span class="line">            <span class="comment">// 通常会使用当前类的字节码文件 作为锁 (字节码文件符合唯一的特性)</span></span><br><span class="line">            <span class="keyword">synchronized</span> (MyThread.class)&#123;</span><br><span class="line">                <span class="comment">// 同步代码块</span></span><br><span class="line">                <span class="keyword">if</span>(ticket &lt; <span class="number">100</span>)&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    ticket++;</span><br><span class="line">                    System.out.println(getName() + <span class="string">&quot;正在卖第&quot;</span> + ticket );</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3><span id="同步方法">同步方法</span></h3><p>就是把synchronized 关键字加到方法上</p><p>格式:<br>修饰符就是把synchronized 返回值类型 方法名(方法参数){…}</p><p>特点1: 同步方法是锁住方法里面所有的代码<br>特点2: 锁对象不能自己指定<br>    非静态: this (当前方法的调用者)<br>    静态: 当前类的字节码文件对象 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="comment">// 共享数据 使用了同步方法的方法 没有必要加static</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">       * 1.循环</span></span><br><span class="line"><span class="comment">       * 2.同步代码块(同步方法)</span></span><br><span class="line"><span class="comment">       * 3.判断共享数据是否到了末尾 如果到了末尾</span></span><br><span class="line"><span class="comment">       * 4.判断共享数据是否到了末尾 如果到了末尾</span></span><br><span class="line"><span class="comment">       * */</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (method())&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ticket == <span class="number">100</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ticket++;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; &quot;</span> + ticket);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>  <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3><span id="lock锁">lock锁</span></h3><img src="/2023/10/30/interview/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/img3.png" style="zoom:100%"><p>代码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="comment">// 表示这个类所有的对象 都共享ticket数据</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            lock.lock();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(ticket == <span class="number">100</span>)&#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                    ticket++;</span><br><span class="line">                    System.out.println(getName() + <span class="string">&quot;在卖第&quot;</span> + ticket);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3><span id="死锁">死锁</span></h3><h2><span id="等待唤醒机制">等待唤醒机制</span></h2><p>生产者和消费者(等待唤醒机制)</p><h3><span id="等待唤醒机制-基础实现">等待唤醒机制 基础实现</span></h3><p>代码示例</p><p>消费者:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 消费者</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Foodie</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 1. 循环</span></span><br><span class="line"><span class="comment">         * 2. 同步代码块</span></span><br><span class="line"><span class="comment">         * 3. 判断共享数据是否到了末尾(到了末尾)</span></span><br><span class="line"><span class="comment">         * 4. 判断共享数据是否到了末尾(没有到末尾 执行核心逻辑)</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Desk.lock)&#123;</span><br><span class="line">                <span class="keyword">if</span>(Desk.count == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 先判断桌子上是否有面条</span></span><br><span class="line">                    <span class="keyword">if</span>(Desk.foodFlag == <span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            Desk.lock.wait();   <span class="comment">// 让当前线程与锁进行绑定</span></span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="comment">// 把吃的总数 -1</span></span><br><span class="line">                        Desk.count--;</span><br><span class="line">                        <span class="comment">// 如果有 就开吃</span></span><br><span class="line">                        System.out.println(<span class="string">&quot;正在吃 还能吃&quot;</span>  + Desk.count + <span class="string">&quot;碗！&quot;</span> );</span><br><span class="line">                        <span class="comment">// 吃完后 唤醒厨师继续做</span></span><br><span class="line">                        Desk.lock.notifyAll();</span><br><span class="line">                        <span class="comment">// 修改桌子的状态</span></span><br><span class="line">                        Desk.foodFlag = <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>生产者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cook</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Desk.lock)&#123;</span><br><span class="line">                <span class="keyword">if</span> (Desk.count == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 判断桌子上是否有食物</span></span><br><span class="line">                    <span class="keyword">if</span> (Desk.foodFlag == <span class="number">1</span>)&#123;</span><br><span class="line">                        <span class="comment">// 如果有 就等待</span></span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            Desk.lock.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 如果没有 就制作食物</span></span><br><span class="line">                        System.out.println(<span class="string">&quot;厨房做了一碗面条&quot;</span>);</span><br><span class="line">                        <span class="comment">// 修改桌子上的食物状态</span></span><br><span class="line">                        Desk.foodFlag = <span class="number">1</span>;</span><br><span class="line">                        <span class="comment">// 唤醒等待的消费者开吃</span></span><br><span class="line">                        Desk.lock.notifyAll();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Demo</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         *  需求: 完成生产者和消费者(等待唤醒机制)的代码</span></span><br><span class="line"><span class="comment">         *  实现线程轮流交替执行的效果</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Cook</span> <span class="variable">cook</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cook</span>();</span><br><span class="line">        <span class="type">Foodie</span> <span class="variable">foodie</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Foodie</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 线程设置名字</span></span><br><span class="line">        cook.setName(<span class="string">&quot;厨师&quot;</span>);</span><br><span class="line">        foodie.setName(<span class="string">&quot;吃货&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开启线程</span></span><br><span class="line">        cook.start();</span><br><span class="line">        foodie.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3><span id="等待唤醒机制-阻塞队列实现">等待唤醒机制 阻塞队列实现</span></h3><p>消费者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Foodie</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line"></span><br><span class="line">    ArrayBlockingQueue&lt;String&gt;queue;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Foodie</span><span class="params">(ArrayBlockingQueue&lt;String&gt; queue)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.queue = queue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="comment">// 不断从阻塞队列中获取面条</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">food</span> <span class="operator">=</span>  queue.take();</span><br><span class="line">                <span class="comment">// 输出语句在锁的外面 但不会影响数据的安全性</span></span><br><span class="line">                System.out.println(food);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>生产者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cook</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line"></span><br><span class="line">    ArrayBlockingQueue&lt;String&gt;queue;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Cook</span><span class="params">(ArrayBlockingQueue&lt;String&gt; queue)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.queue = queue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="comment">// 不断的把面放到阻塞队列当中</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                queue.put(<span class="string">&quot;面条&quot;</span>);</span><br><span class="line">                <span class="comment">// 输出语句在锁的外面 但不会影响数据的安全性</span></span><br><span class="line">                System.out.println(<span class="string">&quot;厨师放了一碗面条&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>测试代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 需求: 利用阻塞队列完成生产者和消费者(等待唤醒机制)的代码</span></span><br><span class="line"><span class="comment">         * 细节:</span></span><br><span class="line"><span class="comment">         *  生产者和消费者必须使用同一个阻塞队列</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1，创建阻塞队列</span></span><br><span class="line">        <span class="comment">// 有界阻塞队列</span></span><br><span class="line">        ArrayBlockingQueue&lt;String&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 创建线程的对象 并把阻塞队列传递过去</span></span><br><span class="line">        <span class="type">Cook</span> <span class="variable">cook</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cook</span>(queue);</span><br><span class="line">        <span class="type">Foodie</span> <span class="variable">foodie</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Foodie</span>(queue);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 开启线程</span></span><br><span class="line">        cook.start();</span><br><span class="line">        foodie.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2><span id="线程的状态">线程的状态</span></h2><img src="/2023/10/30/interview/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/img4.png" style="zoom:100%"><h2><span id="线程池">线程池</span></h2><img src="/2023/10/30/interview/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/img5.png" style="zoom:100%"><p>代码实现<br><img src="/2023/10/30/interview/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/img6.png" style="zoom:100%"></p><p>代码示例 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个没有上限的线程池</span></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">pool1</span>  <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法2</span></span><br><span class="line"><span class="comment">// 创建一个有上限的线程池</span></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">pool2</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3><span id="自定义线程池">自定义线程池</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThreadPoolDemo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ThreadPoolExecutor</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">                <span class="number">3</span>, <span class="comment">//核心线程数量</span></span><br><span class="line">                <span class="number">6</span>, <span class="comment">//最大线程数量 不能小于0 且 最大数量 &gt;= 核心线程数量</span></span><br><span class="line">                <span class="number">60</span>, <span class="comment">// 空闲线程最大存活时间</span></span><br><span class="line">                TimeUnit.SECONDS,<span class="comment">// 时间单位</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">3</span>), <span class="comment">// 任务队列</span></span><br><span class="line">                Executors.defaultThreadFactory(), <span class="comment">// 创建线程工厂</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy() <span class="comment">// 任务的拒绝策略</span></span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>线程池多大合适呢?<br><img src="/2023/10/30/interview/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/img7.png" style="zoom:100%"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThreadPoolDemo3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 向Java虚拟机返回可用处理器的数目</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> Runtime.getRuntime().availableProcessors();</span><br><span class="line">        System.out.println(count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><img src="/2023/10/30/interview/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/img8.png" style="zoom:100%">]]></content>
      
      
      <categories>
          
          <category> interview </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode1438绝对差不超过限制的最长连续子数组</title>
      <link href="/2023/10/30/leetcode/leetcode1438%E7%BB%9D%E5%AF%B9%E5%B7%AE%E4%B8%8D%E8%B6%85%E8%BF%87%E9%99%90%E5%88%B6%E7%9A%84%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84/"/>
      <url>/2023/10/30/leetcode/leetcode1438%E7%BB%9D%E5%AF%B9%E5%B7%AE%E4%B8%8D%E8%B6%85%E8%BF%87%E9%99%90%E5%88%B6%E7%9A%84%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>原题链接:<br><a href="https://leetcode.cn/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/description/">https://leetcode.cn/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/description/</a></p><h2><span id="解法1-滑动窗口-单调队列">解法1: 滑动窗口 + 单调队列</span></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    *  滑动窗口</span></span><br><span class="line"><span class="comment">    *  使用left和right两个指针 分别指向滑动窗口的左右边界 使用TreeMap保存滑动窗口的所有元素</span></span><br><span class="line"><span class="comment">    *  right 主动右移 right每移动一步  把A[right] 放入滑动窗口</span></span><br><span class="line"><span class="comment">    *  left 被动右移 判断此时窗口内最大值和最小值的差 如果大于limit 则left指针被迫右移 left右移之前需要把A[left]从TreeMap中减去一次</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestSubarray</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> limit)</span> &#123;</span><br><span class="line">        <span class="comment">// 维护的就是滑动窗口 其排序规则 就是窗口的最大最小值</span></span><br><span class="line">        <span class="comment">// 数 以及 出现的次数</span></span><br><span class="line">        TreeMap&lt;Integer,Integer&gt; mq = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;(((o1, o2) -&gt; o1 - o2));</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span> , right = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">while</span> (right &lt; n)&#123;</span><br><span class="line">            <span class="comment">// right 主动右移</span></span><br><span class="line">            <span class="comment">// 出现一次 则记为1</span></span><br><span class="line">            mq.put(nums[right], mq.getOrDefault(nums[right],<span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 如果最大值 - 减小值 &gt; limit 即意味着 left应该左移</span></span><br><span class="line">            <span class="keyword">while</span> (mq.lastKey() - mq.firstKey() &gt; limit)&#123;</span><br><span class="line">                mq.put(nums[left],mq.get(nums[left]) - <span class="number">1</span>);</span><br><span class="line">                <span class="comment">// 如当前 nums[left] 已经不存在 则移除键值</span></span><br><span class="line">                <span class="keyword">if</span>(mq.get(nums[left]) == <span class="number">0</span>)&#123;</span><br><span class="line">                    mq.remove(nums[left]);</span><br><span class="line">                &#125;</span><br><span class="line">                left++;</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 先更新答案</span></span><br><span class="line">            ans = Math.max(ans, right - left + <span class="number">1</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// right 每次都主动右移</span></span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分 </tag>
            
            <tag> 滑动窗口 </tag>
            
            <tag> 单调队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode767重构字符串</title>
      <link href="/2023/10/29/leetcode/leetcode767%E9%87%8D%E6%9E%84%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2023/10/29/leetcode/leetcode767%E9%87%8D%E6%9E%84%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>原题链接:<br><a href="https://leetcode.cn/problems/reorganize-string/">https://leetcode.cn/problems/reorganize-string/</a></p><h2><span id="解法1-贪心-堆">解法1: 贪心 + 堆</span></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reorganizeString</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> [] count = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="type">var</span> <span class="variable">ss</span> <span class="operator">=</span> s.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span>  ss.length;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> c:ss)&#123;</span><br><span class="line">            count[c - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">            <span class="keyword">if</span>(count[c - <span class="string">&#x27;a&#x27;</span>] &gt; (n + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 大根堆 根据字符的出现次数排序</span></span><br><span class="line">        PriorityQueue&lt;Character&gt;pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(((o1, o2) -&gt; count[o2.charValue() - <span class="string">&#x27;a&#x27;</span>] - count[o1.charValue() - <span class="string">&#x27;a&#x27;</span>]));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">var</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span> ; c &lt;= <span class="string">&#x27;z&#x27;</span> ; c++)&#123;</span><br><span class="line">            <span class="comment">// 只将 出现次数大于0 入队 提高效率</span></span><br><span class="line">            <span class="keyword">if</span>(count[c - <span class="string">&#x27;a&#x27;</span>] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                pq.add(c);   </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(pq.size() &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="type">var</span> <span class="variable">letter1</span> <span class="operator">=</span> pq.poll();</span><br><span class="line">            <span class="type">var</span> <span class="variable">letter2</span> <span class="operator">=</span> pq.poll();</span><br><span class="line">            sb.append(letter1);</span><br><span class="line">            sb.append(letter2);</span><br><span class="line">            count[letter1 - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">            count[letter2 - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">            <span class="keyword">if</span>(count[letter1 - <span class="string">&#x27;a&#x27;</span>] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                pq.add(letter1);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(count[letter2 - <span class="string">&#x27;a&#x27;</span>] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                pq.add(letter2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(pq.size() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            sb.append(pq.poll());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2><span id="解法2-贪心-计数">解法2: 贪心 + 计数</span></h2>]]></content>
      
      
      <categories>
          
          <category> algo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心 </tag>
            
            <tag> 堆 </tag>
            
            <tag> 计数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode88合并两个有序数组</title>
      <link href="/2023/10/27/leetcode/leetcode88%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/"/>
      <url>/2023/10/27/leetcode/leetcode88%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>原题链接:<br><a href="https://leetcode.cn/problems/merge-sorted-array/">https://leetcode.cn/problems/merge-sorted-array/</a></p><h2><span id="解法1-双指针">解法1: 双指针</span></h2><p>最优解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">    双指针</span></span><br><span class="line"><span class="comment">    初始化三个指针</span></span><br><span class="line"><span class="comment">    p1 = m - 1 , p2 = n - 1</span></span><br><span class="line"><span class="comment">    p = m + n - 1</span></span><br><span class="line"><span class="comment">    核心思想就是从后往前进行合并 </span></span><br><span class="line"><span class="comment">    因为nums1后面的位置是空的 一个极端的情况 如果nums1中所有元素都比nums2大</span></span><br><span class="line"><span class="comment">    那么就是将nums1中所有元素都移动到后面 而此时相当于nums1前面的位置都空出来了 直接填入nums2即可 不需要考虑覆盖问题</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span> m, <span class="type">int</span>[] nums2, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> m + n - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> m - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">p2</span> <span class="operator">=</span> n - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果p2还有要合并元素则参加循环</span></span><br><span class="line">        <span class="keyword">while</span>(p2 &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p1 &gt;= <span class="number">0</span> &amp;&amp; nums1[p1] &gt; nums2[p2])&#123;</span><br><span class="line">                nums1[p--] = nums1[p1--];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 如果p1 &lt; 0 证明所有nums1中元素都已经挪到了后面 </span></span><br><span class="line">                <span class="comment">// 剩下就是移动nums2内的元素就完事了</span></span><br><span class="line">                nums1[p--] = nums2[p2--];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2><span id="解法2-堆">解法2: 堆</span></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span> m, <span class="type">int</span>[] nums2, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        PriorityQueue&lt;Integer&gt;pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((o1,o2)-&gt;o1 - o2);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; m ; i++)&#123;</span><br><span class="line">            pq.add(nums1[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; n ; i++)&#123;</span><br><span class="line">            pq.add(nums2[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; m + n ; i++)&#123;</span><br><span class="line">            nums1[i] = pq.poll();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>leetcode1465切割后面积最大的蛋糕</title>
      <link href="/2023/10/27/leetcode/leetcode1465%E5%88%87%E5%89%B2%E5%90%8E%E9%9D%A2%E7%A7%AF%E6%9C%80%E5%A4%A7%E7%9A%84%E8%9B%8B%E7%B3%95/"/>
      <url>/2023/10/27/leetcode/leetcode1465%E5%88%87%E5%89%B2%E5%90%8E%E9%9D%A2%E7%A7%AF%E6%9C%80%E5%A4%A7%E7%9A%84%E8%9B%8B%E7%B3%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>原题链接:<br><a href="https://leetcode.cn/problems/maximum-area-of-a-piece-of-cake-after-horizontal-and-vertical-cuts/">https://leetcode.cn/problems/maximum-area-of-a-piece-of-cake-after-horizontal-and-vertical-cuts/</a></p><h2><span id="解法1-贪心">解法1: 贪心</span></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">        贪心</span></span><br><span class="line"><span class="comment">        因为窗口都是由两条横切 和 两条纵切直接确定</span></span><br><span class="line"><span class="comment">        所以先确定横切 然后求出纵切最大那么最后得到的就是答案</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MOD</span> <span class="operator">=</span> (<span class="type">int</span>)(<span class="number">1e9</span> + <span class="number">7</span>);</span><br><span class="line">    <span class="comment">// 他这里面 horizontalCuts verticalCuts 里面给都不是排序好的 还是有些坑的</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxArea</span><span class="params">(<span class="type">int</span> h, <span class="type">int</span> w, <span class="type">int</span>[] horizontalCuts, <span class="type">int</span>[] verticalCuts)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>)((getMax(horizontalCuts,h) * getMax(verticalCuts,w)) % MOD);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">getMax</span><span class="params">(<span class="type">int</span> [] arr ,<span class="type">int</span> x)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length;</span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span>  Math.max(arr[<span class="number">0</span>],x - arr[n - <span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n ; i++ )&#123;</span><br><span class="line">            res = Math.max(arr[i] - arr[i - <span class="number">1</span>],res);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (<span class="type">long</span>)res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;       </span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode丑数-合集</title>
      <link href="/2023/10/26/leetcode/leetcode%E4%B8%91%E6%95%B0-%E5%90%88%E9%9B%86/"/>
      <url>/2023/10/26/leetcode/leetcode%E4%B8%91%E6%95%B0-%E5%90%88%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1><span id="丑数i">丑数Ⅰ</span></h1><h1><span id="丑数ii">丑数Ⅱ</span></h1><p>原题链接:<br><a href="https://leetcode.cn/problems/ugly-number-ii/">https://leetcode.cn/problems/ugly-number-ii/</a></p><h2><span id="解法1-优先队列">解法1 优先队列</span></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 打表</span></span><br><span class="line"><span class="comment"> 对于任意一个丑数 x，其与任意的质因数 (2、3、5)相乘，结果 (2x、3x、5x) 仍为丑数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> <span class="number">1690</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> [] ans = <span class="keyword">new</span> <span class="title class_">int</span>[N];</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> [] nums = <span class="keyword">new</span> <span class="title class_">long</span>[]&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// 最小堆</span></span><br><span class="line">        <span class="comment">// 这个点非常的坑 </span></span><br><span class="line">        <span class="comment">// Long 这里排序 不能用 o1 - o2 因为会存在溢出问题 一定要统一使用 o1.compareTo(o2)</span></span><br><span class="line">        PriorityQueue&lt;Long&gt;pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((o1, o2) -&gt; o1.compareTo(o2));</span><br><span class="line">        <span class="comment">// 存储出现过的元素 防止再次入堆</span></span><br><span class="line">        HashSet&lt;Long&gt; hash = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        pq.offer(<span class="number">1L</span>);</span><br><span class="line">        hash.add(<span class="number">1L</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; N ; i++)&#123;</span><br><span class="line">            <span class="type">var</span> <span class="variable">x</span> <span class="operator">=</span> pq.poll();</span><br><span class="line">            ans[i] = x.intValue();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">var</span> num : nums)&#123;</span><br><span class="line">                <span class="type">long</span> <span class="variable">t</span> <span class="operator">=</span> num * x;</span><br><span class="line">                <span class="keyword">if</span>(!hash.contains(t))&#123;</span><br><span class="line">                    pq.offer(t);</span><br><span class="line">                    hash.add(t);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">nthUglyNumber</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ans[n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2><span id="解法2-三指针">解法2: 三指针</span></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> [] ans = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">1690</span> + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        ans[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i2</span> <span class="operator">=</span> <span class="number">1</span>,i3 = <span class="number">1</span>,i5 = <span class="number">1</span>,idx = <span class="number">2</span>  ; idx &lt;= <span class="number">1690</span> ;idx++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> ans[i2] * <span class="number">2</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> ans[i3] * <span class="number">3</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ans[i5] * <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Math.min(a,Math.min(b,c));</span><br><span class="line">            ans[idx] = min;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2 质因子 已经可以作为小数 进行相乘 该为就可以跳过 不需要再相乘</span></span><br><span class="line">            <span class="keyword">if</span>(a == min)&#123;</span><br><span class="line">                i2++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(b == min)&#123;</span><br><span class="line">                i3++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(c == min)&#123;</span><br><span class="line">                i5++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">nthUglyNumber</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ans[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>leetcode23合并k个升序链表</title>
      <link href="/2023/10/26/leetcode/leetcode23%E5%90%88%E5%B9%B6k%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
      <url>/2023/10/26/leetcode/leetcode23%E5%90%88%E5%B9%B6k%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>原题链接:<br><a href="https://leetcode.cn/problems/merge-k-sorted-lists/">https://leetcode.cn/problems/merge-k-sorted-lists/</a></p><h2><span id="解法1-堆">解法1: 堆</span></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeKLists</span><span class="params">(ListNode[] lists)</span> &#123;</span><br><span class="line">        <span class="comment">// 最小堆 根据当前节点进行排序</span></span><br><span class="line">        PriorityQueue&lt;ListNode&gt;heap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((o1,o2) -&gt;&#123;</span><br><span class="line">            <span class="keyword">return</span> o1.val - o2.val;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> node : lists)&#123;</span><br><span class="line">            <span class="keyword">if</span>(node != <span class="literal">null</span>)&#123;</span><br><span class="line">                heap.offer(node);</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> dummy;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!heap.isEmpty())&#123;</span><br><span class="line">            <span class="type">var</span> <span class="variable">node</span> <span class="operator">=</span> heap.poll();</span><br><span class="line">            cur.next = node;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">            <span class="keyword">if</span>(node.next != <span class="literal">null</span>)&#123;</span><br><span class="line">                heap.offer(cur.next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2><span id="解法2-分治">解法2: 分治</span></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    *  分治</span></span><br><span class="line"><span class="comment">    *  将要排序的链表不断二分 将左右两边都排序完之后再进行拼接</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeKLists</span><span class="params">(ListNode[] lists)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mergeKLists(lists,<span class="number">0</span>, lists.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并 list[i] 到 list[j - 1] 的链表</span></span><br><span class="line">    <span class="keyword">private</span> ListNode <span class="title function_">mergeKLists</span><span class="params">(ListNode[] lists, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="comment">// 计算链表的长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> j - i;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// m = 0 为空直接返回</span></span><br><span class="line">        <span class="keyword">if</span>(m == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 只有一条链表直接返回无需排序</span></span><br><span class="line">        <span class="comment">// 因为是到 j - 1 左闭右开 区间 return i</span></span><br><span class="line">        <span class="keyword">if</span>(m == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>  lists[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 划分</span></span><br><span class="line">        <span class="type">var</span> <span class="variable">left</span> <span class="operator">=</span> mergeKLists(lists,i, i + m / <span class="number">2</span>);</span><br><span class="line">        <span class="type">var</span> <span class="variable">right</span> <span class="operator">=</span> mergeKLists(lists,i + m / <span class="number">2</span> , j);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 合并两条有序链表</span></span><br><span class="line">        <span class="keyword">return</span> mergeTwoLists(left,right);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ListNode <span class="title function_">mergeTwoLists</span><span class="params">(ListNode list1, ListNode list2)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="keyword">while</span>(list1 != <span class="literal">null</span> &amp;&amp; list2!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(list1.val &lt; list2.val)&#123;</span><br><span class="line">                cur.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(list1.val);</span><br><span class="line">                list1 = list1.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cur.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(list2.val);</span><br><span class="line">                list2 = list2.next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        cur.next = list1 != <span class="literal">null</span> ? list1 : list2;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 堆 </tag>
            
            <tag> 链表 </tag>
            
            <tag> 分治 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode2698求一个整数的惩罚数</title>
      <link href="/2023/10/25/leetcode/leetcode2698%E6%B1%82%E4%B8%80%E4%B8%AA%E6%95%B4%E6%95%B0%E7%9A%84%E6%83%A9%E7%BD%9A%E6%95%B0/"/>
      <url>/2023/10/25/leetcode/leetcode2698%E6%B1%82%E4%B8%80%E4%B8%AA%E6%95%B4%E6%95%B0%E7%9A%84%E6%83%A9%E7%BD%9A%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>原题链接:<br><a href="https://leetcode.cn/problems/find-the-punishment-number-of-an-integer/description/">https://leetcode.cn/problems/find-the-punishment-number-of-an-integer/description/</a></p><h2><span id="解法1-递归">解法1: 递归</span></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    *  打表预处理</span></span><br><span class="line"><span class="comment">    *  递归求解</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将[1,1000] 所有符合条件的惩罚数 都储存再 PRE_SUM数组中继续记录</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">static</span> <span class="keyword">final</span> <span class="type">int</span> [] PRE_SUM = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">1001</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态方法 只会运行一次</span></span><br><span class="line">    <span class="type">static</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span> ; i &lt;= <span class="number">1000</span> ; i++)&#123;</span><br><span class="line">            <span class="comment">// 转换为字符串</span></span><br><span class="line">            <span class="type">char</span> [] s = Integer.<span class="built_in">toString</span>(i * i).<span class="built_in">toCharArray</span>();</span><br><span class="line">            <span class="comment">// 这里使用了前缀和处理 后续主函数内直接调用就行 不需要再判断了 算是一种优化</span></span><br><span class="line">            PRE_SUM[i] = PRE_SUM[i - <span class="number">1</span>] +  (<span class="built_in">dfs</span>(s,i,<span class="number">0</span>,<span class="number">0</span>) ? i * i : <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/***</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param s 当前处理的字符串</span></span><br><span class="line"><span class="comment">     * @param i 当前遍历到的数 i</span></span><br><span class="line"><span class="comment">     * @param p dfs枚举分割的起点</span></span><br><span class="line"><span class="comment">     * @param sum i*i 字符串数的和</span></span><br><span class="line"><span class="comment">     * @return</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="type">static</span> boolean <span class="title">dfs</span><span class="params">(<span class="type">char</span> [] s, <span class="type">int</span> i, <span class="type">int</span> p,<span class="type">int</span> sum)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 当前已经分割到了 s的最后的一位 直接返回</span></span><br><span class="line">        <span class="keyword">if</span>(p == s.length)&#123;</span><br><span class="line">            <span class="keyword">return</span>  sum == i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 分割字符串 进行遍历</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = p ; j &lt; s.length ; j++)&#123;</span><br><span class="line">            <span class="comment">// 因为是从前往后开始拆分 那么每拆一位 算出当前值 将到sum进行组合求出结果</span></span><br><span class="line">            x = x * <span class="number">10</span> + s[j] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="comment">// 如果符合条件 直接返回</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">dfs</span>(s,i,j+<span class="number">1</span>,sum + x))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">int</span> <span class="title">punishmentNumber</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> PRE_SUM[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dfs </tag>
            
            <tag> 递归 </tag>
            
            <tag> 字符串处理 </tag>
            
            <tag> 静态方法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javaStream流</title>
      <link href="/2023/10/24/interview/javaStream%E6%B5%81/"/>
      <url>/2023/10/24/interview/javaStream%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1><span id="stream流">Stream流</span></h1><p>Stream流的作用:<br>结合了Lambda表达式 简化集合、数组的操作</p><h2><span id="stream流的使用步骤">Stream流的使用步骤</span></h2><ol><li>先得到一条Stream流 并把数据放上去<ol><li>利用Stream流中的API进行各种操作(如 过滤 转换 统计 打印等等)<ol><li>中间方法: 方法调用完之后,还可以调用其他方法 如:过滤 转换 </li><li>终结方法: 最后一步,调用完毕之后,不能调用其他方法 如:统计 打印</li></ol></li></ol></li><li>使用<strong>中间方法</strong>对流水线上的数据进行操作</li><li>使用<strong>终结方法</strong>对流水线上的数据进行操作</li></ol><h3><span id="先得到一条stream流-并把数据放上去">先得到一条Stream流 并把数据放上去</span></h3><img src="/2023/10/24/interview/javaStream%E6%B5%81/img1.png" style="zoom:100%"><h3><span id="中间方法">中间方法</span></h3><img src="/2023/10/24/interview/javaStream%E6%B5%81/img2.png" style="zoom:100%"><p>代码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">Collections.addAll(list,<span class="string">&quot;a&quot;</span>,<span class="string">&quot;ab&quot;</span>,<span class="string">&quot;bc&quot;</span>);</span><br><span class="line"><span class="comment">// filter 过滤 把a开头的留下 其余数据过滤不要</span></span><br><span class="line">list.stream().filter(<span class="keyword">new</span> <span class="title class_">Predicate</span>&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">test</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果返回值为true 表示当前数据留下</span></span><br><span class="line">        <span class="comment">// 如果返回值为false 表示当前数据舍弃</span></span><br><span class="line">        <span class="keyword">return</span> s.startsWith(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).forEach(s -&gt; System.out.println(s));</span><br><span class="line"><span class="comment">// lambda 表达式简化</span></span><br><span class="line">list.stream().filter(s -&gt; s.startsWith(<span class="string">&quot;a&quot;</span>)).forEach(s-&gt; System.out.printl(s));</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*  limit 获取前几个元素</span></span><br><span class="line"><span class="comment">*  skip 跳过前几个元素</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line">list.stream().limit(<span class="number">3</span>)</span><br><span class="line">        .forEach(s-&gt; System.out.println(s));</span><br><span class="line">list.stream().skip(<span class="number">4</span>)</span><br><span class="line">        .forEach(s-&gt; System.out.println(s));</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* distinct 元素去重 依赖(hashCode和)</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line">list.stream()</span><br><span class="line">        .distinct().forEach(s-&gt; System.out.println(s));</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* concat 合并  a和b两个流为一个流</span></span><br><span class="line"><span class="comment">* 尽量保持数据类型一致 否则会返回ab两个类的父类</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line">Stream.concat(list.stream(),list.stream())</span><br><span class="line">        .forEach(s-&gt; System.out.println(s));</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* map 转换流中的数据类型</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line">ArrayList&lt;String&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">Collections.addAll(list1,<span class="string">&quot;a-1&quot;</span>,<span class="string">&quot;b-2&quot;</span>,<span class="string">&quot;c-3&quot;</span>);</span><br><span class="line"><span class="comment">// 需求: 只打印 数字   String-&gt;int</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 第一个类型: 流中原本的数据类型</span></span><br><span class="line"><span class="comment">* 第二个类型: 要转成之后的类型</span></span><br><span class="line"><span class="comment">* appley 的形参s: 依次表示流里面的每一个数据</span></span><br><span class="line"><span class="comment">* 返回值: 表示转换之后的数据</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="comment">// 当map方法执行完后 流上的数据就变成了整数</span></span><br><span class="line"><span class="comment">// 所以在下面forEach当中 s依次表示流里面的每一个数据 这个数据现在就是整数了</span></span><br><span class="line">list1.stream().map(<span class="keyword">new</span> <span class="title class_">Function</span>&lt;String, Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">apply</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        String[] arr = s.split(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> Integer.parseInt(arr[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).forEach(s-&gt; System.out.println(s));</span><br><span class="line"><span class="comment">// 转换lambda表达式的形式</span></span><br><span class="line">list.stream().map(s-&gt; Integer.parseInt(s.split(<span class="string">&quot;-&quot;</span>)[<span class="number">1</span>]))</span><br><span class="line">        .forEach(s-&gt; System.out.println(s));</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3><span id="终结方法">终结方法</span></h3><img src="/2023/10/24/interview/javaStream%E6%B5%81/img3.png" style="zoom:100%"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">Collections.addAll(list,<span class="string">&quot;a&quot;</span>,<span class="string">&quot;ab&quot;</span>,<span class="string">&quot;bc&quot;</span>);</span><br><span class="line"><span class="comment">// filter 过滤 把a开头的留下 其余数据过滤不要</span></span><br><span class="line">list.stream().filter(<span class="keyword">new</span> <span class="title class_">Predicate</span>&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">test</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果返回值为true 表示当前数据留下</span></span><br><span class="line">        <span class="comment">// 如果返回值为false 表示当前数据舍弃</span></span><br><span class="line">        <span class="keyword">return</span> s.startsWith(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).forEach(s -&gt; System.out.println(s));</span><br><span class="line"><span class="comment">// lambda 表达式简化</span></span><br><span class="line">list.stream().filter(s -&gt; s.startsWith(<span class="string">&quot;a&quot;</span>)).forEach(s-&gt; System.out.printl(s));</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*  limit 获取前几个元素</span></span><br><span class="line"><span class="comment">*  skip 跳过前几个元素</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line">list.stream().limit(<span class="number">3</span>)</span><br><span class="line">        .forEach(s-&gt; System.out.println(s));</span><br><span class="line">list.stream().skip(<span class="number">4</span>)</span><br><span class="line">        .forEach(s-&gt; System.out.println(s));</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* distinct 元素去重 依赖(hashCode和)</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line">list.stream()</span><br><span class="line">        .distinct().forEach(s-&gt; System.out.println(s));</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* concat 合并  a和b两个流为一个流</span></span><br><span class="line"><span class="comment">* 尽量保持数据类型一致 否则会返回ab两个类的父类</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line">Stream.concat(list.stream(),list.stream())</span><br><span class="line">        .forEach(s-&gt; System.out.println(s));</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* map 转换流中的数据类型</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line">ArrayList&lt;String&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">Collections.addAll(list1,<span class="string">&quot;a-1&quot;</span>,<span class="string">&quot;b-2&quot;</span>,<span class="string">&quot;c-3&quot;</span>);</span><br><span class="line"><span class="comment">// 需求: 只打印 数字   String-&gt;int</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 第一个类型: 流中原本的数据类型</span></span><br><span class="line"><span class="comment">* 第二个类型: 要转成之后的类型</span></span><br><span class="line"><span class="comment">* appley 的形参s: 依次表示流里面的每一个数据</span></span><br><span class="line"><span class="comment">* 返回值: 表示转换之后的数据</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="comment">// 当map方法执行完后 流上的数据就变成了整数</span></span><br><span class="line"><span class="comment">// 所以在下面forEach当中 s依次表示流里面的每一个数据 这个数据现在就是整数了</span></span><br><span class="line">list1.stream().map(<span class="keyword">new</span> <span class="title class_">Function</span>&lt;String, Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">apply</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        String[] arr = s.split(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> Integer.parseInt(arr[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).forEach(s-&gt; System.out.println(s));</span><br><span class="line"><span class="comment">// 转换lambda表达式的形式</span></span><br><span class="line">list.stream().map(s-&gt; Integer.parseInt(s.split(<span class="string">&quot;-&quot;</span>)[<span class="number">1</span>]))</span><br><span class="line">        .forEach(s-&gt; System.out.println(s));</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Consumer的泛型 表示流体中数据的类型</span></span><br><span class="line"><span class="comment">* accept方法的形参s 依次表示流里面的每一个数据</span></span><br><span class="line"><span class="comment">* 方法体 对每一个数据的处理操作</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line">list.stream().forEach(<span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 转为lambda</span></span><br><span class="line"><span class="comment">// forEach方法 为 void 故之后不能对forEach()的返回 进行调用</span></span><br><span class="line">list.stream().forEach(s-&gt; System.out.println(s));</span><br><span class="line"><span class="comment">// count</span></span><br><span class="line"><span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> list.stream().count();</span><br><span class="line">System.out.println(count);</span><br><span class="line"><span class="comment">// toArray()</span></span><br><span class="line">Object[] arr1 = list.stream().toArray();</span><br><span class="line">System.out.println(arr1.toString());</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*  IntFunction的泛型 具体类型的数据</span></span><br><span class="line"><span class="comment">* apply的形参: 流中数据的个数 要跟数组的长度保持一致</span></span><br><span class="line"><span class="comment">* apply的返回值: 具体类型的数组</span></span><br><span class="line"><span class="comment">* 方法体: 就是创建数组</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* toArray方法的参数的作用 负责创建一个指定类型的数组</span></span><br><span class="line"><span class="comment">* toArray方法的底层 会依次得到流里面的每一个数据 并把数据放到数组当中</span></span><br><span class="line"><span class="comment">* toArray方法的返回值 是一个装着流里面所有数组的数组</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line">String[] arr2 = list.stream().toArray(<span class="keyword">new</span> <span class="title class_">IntFunction</span>&lt;String[]&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] apply(<span class="type">int</span> value) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[value];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(Arrays.toString(arr2));</span><br><span class="line">String[] arr3 = list.stream().toArray(value -&gt; <span class="keyword">new</span> <span class="title class_">String</span>[value]);</span><br><span class="line">System.out.println(Arrays.toString(arr3));</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* collect(Collector collector)  收集流中的数据 放到集合中(List Set Map)</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 注意点:</span></span><br><span class="line"><span class="comment">*   如果我们要收集到Map集合当中 健不能重复 否则会报错</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line">ArrayList&lt;String&gt; list2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">Collections.addAll(list2,<span class="string">&quot;a-男-1&quot;</span>,<span class="string">&quot;b-女-2&quot;</span>,<span class="string">&quot;c-男-3&quot;</span>);</span><br><span class="line"><span class="comment">// 收集到List集合当中</span></span><br><span class="line"><span class="comment">// 需求: 收集所有男性</span></span><br><span class="line">List&lt;String&gt; collect = list.stream().filter(s -&gt; <span class="string">&quot;男&quot;</span>.equals(s.split(<span class="string">&quot;-&quot;</span>)[<span class="number">1</span>]))</span><br><span class="line">        .collect(Collectors.toList());</span><br><span class="line">System.out.println(collect);</span><br><span class="line"><span class="comment">// 收集到Set集合中</span></span><br><span class="line"><span class="comment">// Set会对收集的数据进行去重</span></span><br><span class="line">Set&lt;String&gt; collect1 = list.stream().filter(s -&gt; <span class="string">&quot;男&quot;</span>.equals(s.split(<span class="string">&quot;-&quot;</span>)[<span class="number">1</span>]))</span><br><span class="line">        .collect(Collectors.toSet());</span><br><span class="line">System.out.println(collect1);</span><br><span class="line"><span class="comment">// 收集到Map中</span></span><br><span class="line"><span class="comment">// 谁作为键 谁作为值</span></span><br><span class="line"><span class="comment">// 键: 姓名  值:年龄</span></span><br><span class="line">Map&lt;String, Integer&gt; collect2 = list.stream()</span><br><span class="line">        .filter(s -&gt; <span class="string">&quot;男&quot;</span>.equals(s.split(<span class="string">&quot;-&quot;</span>)[<span class="number">1</span>]))</span><br><span class="line">        <span class="comment">// toMap(键的规则,值的规则)</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * toMap: 参数一表示键的生成规则</span></span><br><span class="line"><span class="comment">         *        参数二表示值的生成规则</span></span><br><span class="line"><span class="comment">         * 参数一:</span></span><br><span class="line"><span class="comment">         *    Function泛型一: 表示流中每一个数据的类型</span></span><br><span class="line"><span class="comment">         *            泛型二: 表示Map集合中键的数据类型</span></span><br><span class="line"><span class="comment">         *    方法apply形参 值依次表示流里面的每一个数据</span></span><br><span class="line"><span class="comment">         *       方法体: 生成键的代码</span></span><br><span class="line"><span class="comment">         *       返回值: 已经生成的键</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 参数二:</span></span><br><span class="line"><span class="comment">         *   Function泛型一: 表示流中每一个数据的类型</span></span><br><span class="line"><span class="comment">         *           泛型二: 表示Map集合中值的数据类型</span></span><br><span class="line"><span class="comment">         *   方法apply形参; 依次表示流里面的每一个数据</span></span><br><span class="line"><span class="comment">         *       方法体: 生成值的代码</span></span><br><span class="line"><span class="comment">         *       返回值: 已经生成的值</span></span><br><span class="line"><span class="comment">         * */</span></span><br><span class="line">        .collect(Collectors.toMap(<span class="keyword">new</span> <span class="title class_">Function</span>&lt;String, String&gt;() &#123;</span><br><span class="line">                                      <span class="meta">@Override</span></span><br><span class="line">                                      <span class="keyword">public</span> String <span class="title function_">apply</span><span class="params">(String s)</span> &#123;</span><br><span class="line">                                          <span class="keyword">return</span> s.split(<span class="string">&quot;-&quot;</span>)[<span class="number">0</span>];</span><br><span class="line">                                      &#125;</span><br><span class="line">                                  &#125;,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Function</span>&lt;String, Integer&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> Integer <span class="title function_">apply</span><span class="params">(String s)</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> Integer.parseInt(s.split(<span class="string">&quot;-&quot;</span>)[<span class="number">2</span>]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;));</span><br><span class="line"><span class="comment">// 转换为lambda</span></span><br><span class="line">Map&lt;String, Integer&gt; collect3 = list.stream()</span><br><span class="line">        .filter(s -&gt; <span class="string">&quot;男&quot;</span>.equals(s.split(<span class="string">&quot;-&quot;</span>)[<span class="number">1</span>]))</span><br><span class="line">        .collect(Collectors.toMap(</span><br><span class="line">                s -&gt; s.split(<span class="string">&quot;-&quot;</span>)[<span class="number">0</span>],</span><br><span class="line">                s -&gt; Integer.parseInt(s.split(<span class="string">&quot;-&quot;</span>)[<span class="number">2</span>])));</span><br><span class="line">System.out.println(collect3);</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> interview </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Stream流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode350两个数组的交集Ⅱ</title>
      <link href="/2023/10/24/leetcode/leetcode350%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86%E2%85%A1/"/>
      <url>/2023/10/24/leetcode/leetcode350%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86%E2%85%A1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>原题链接:<br><a href="https://leetcode.cn/problems/intersection-of-two-arrays-ii/">https://leetcode.cn/problems/intersection-of-two-arrays-ii/</a></p><h2><span id="哈希集合">哈希集合</span></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] intersect(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2) &#123;</span><br><span class="line">        HashMap&lt;Integer,Integer&gt; hash = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> x : nums1)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> hash.getOrDefault(x,<span class="number">0</span>);</span><br><span class="line">            count++;</span><br><span class="line">            hash.put(x,count);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> [] ans = <span class="keyword">new</span> <span class="title class_">int</span>[Math.min(nums1.length,nums2.length)];</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> x : nums2)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> hash.getOrDefault(x,<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span>(count &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                count--;</span><br><span class="line">                ans[k++] = x;</span><br><span class="line"></span><br><span class="line">                hash.put(x,count);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Arrays.copyOfRange(ans,<span class="number">0</span>,k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2><span id="解法2-排序-双指针-感觉有些问题-如果无序的话-应该不能这么做">解法2: 排序 + 双指针 (感觉有些问题 如果无序的话 应该不能这么做)</span></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    *   排序 + 双指针</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] intersect(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2) &#123;</span><br><span class="line">        Arrays.sort(nums1);</span><br><span class="line">        Arrays.sort(nums2);</span><br><span class="line">        <span class="type">int</span> [] ans = <span class="keyword">new</span> <span class="title class_">int</span>[Math.min(nums1.length,nums2.length)];</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> , j = <span class="number">0</span> ; i &lt; nums1.length &amp;&amp; j &lt; nums2.length;)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums1[i] &lt; nums2[j])&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums1[i] &gt; nums2[j])&#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ans[k] = nums1[i];</span><br><span class="line">                k++;</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// k 后面的多余元素不要直接去除掉</span></span><br><span class="line">        <span class="keyword">return</span> Arrays.copyOfRange(ans,<span class="number">0</span>, k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>java算法题常用函数以及集合</title>
      <link href="/2023/10/24/algoSummary/java%E7%AE%97%E6%B3%95%E9%A2%98%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E4%BB%A5%E5%8F%8A%E9%9B%86%E5%90%88/"/>
      <url>/2023/10/24/algoSummary/java%E7%AE%97%E6%B3%95%E9%A2%98%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E4%BB%A5%E5%8F%8A%E9%9B%86%E5%90%88/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2><span id="heap">Heap</span></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 默认小根堆</span></span><br><span class="line">        PriorityQueue&lt;Integer&gt;heap1 = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();</span><br><span class="line">       Collections.addAll(heap1,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line">       heap1.stream().forEach(s-&gt; System.out.println(s));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过传入比较器 使其成为大根堆</span></span><br><span class="line">        <span class="comment">// 比较器使用lambda 进行简化</span></span><br><span class="line">        PriorityQueue&lt;Integer&gt;heap2 = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((o1,o2) -&gt; o2 - o1);</span><br><span class="line">        Collections.addAll(heap2,<span class="number">9</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line">        heap2.stream().forEach(s-&gt; System.out.println(s));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2><span id="arraylist-初始化">ArrayList 初始化</span></h2><p>最简单的直接初始化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure><p>赋初始值初始化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt;arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>));</span><br></pre></td></tr></table></figure><h2><span id="arrays类相关">Arrays类相关</span></h2><p>这些主要处理 java 中int[] 和 Integer 不好转换的问题<br>比如题目要求返回int[]  但实际算法中需要用到动态数组 ArrayList</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  主要应对场景:</span></span><br><span class="line"><span class="comment"> *  要返回的数组长度 只占算法操作后数组长度部分的情况</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Arrays.copyOfRange(原数组，开始拷贝下标 , 拷贝结束下标); <span class="comment">// 左开右边</span></span><br></pre></td></tr></table></figure><h2><span id="java二分">java二分</span></h2><p><strong>建议手动实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> [] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">10</span>&#125;;</span><br><span class="line">        <span class="type">var</span> <span class="variable">t1</span> <span class="operator">=</span> binary1(<span class="number">3</span>,arr);</span><br><span class="line">        <span class="type">var</span> <span class="variable">t2</span> <span class="operator">=</span> binary2(<span class="number">3</span>,arr);</span><br><span class="line">        <span class="type">var</span> <span class="variable">t3</span> <span class="operator">=</span> binary1(<span class="number">2</span>,arr);</span><br><span class="line">        <span class="type">var</span> <span class="variable">t4</span> <span class="operator">=</span> binary2(<span class="number">2</span>,arr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出 1</span></span><br><span class="line">        System.out.println(t1);</span><br><span class="line">        <span class="comment">// 输出 3</span></span><br><span class="line">        System.out.println(t2);</span><br><span class="line">        <span class="comment">// 输出 1</span></span><br><span class="line">        System.out.println(t3);</span><br><span class="line">        <span class="comment">// 输出 0</span></span><br><span class="line">        System.out.println(t4);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 要查找的数 以及数组</span></span><br><span class="line">    <span class="comment">// 这种写法 相同元素时返回的是 第一个数的索引  即第一个&gt;= x 的数</span></span><br><span class="line">    <span class="comment">// 如果没找到 那么 返回的是第一个大于的这个数的位置 这个相对来说会更符合平常元素的逻辑</span></span><br><span class="line">    <span class="comment">// 这种写法用的最多</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binary1</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> [] arr)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span> , r = arr.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(arr[mid] &gt;= x)&#123;</span><br><span class="line">                r = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这种写法 相同元素时 返回最后一个数的索引 即第一个 &lt; x + 1 的数</span></span><br><span class="line">    <span class="comment">// 如果没找到 返回的是 返回的是第一个小于这个数的位置</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binary2</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> [] arr)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span> , r = arr.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l + r  + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(arr[mid] &lt;= x)&#123;</span><br><span class="line">                l = mid ;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>实在上面的记不住 再用库函数(但也可以直接切c++)</p><h3><span id="二分库函数不推荐使用">二分库函数(不推荐使用)</span></h3><p>基于Array库实现<br>Arrays.binarySearch 返回的是 索引下标</p><p>方法的返回值有几种：<br>1、找到的情况下：如果key在数组中，则返回搜索值的索引。<br>2、找不到的情况下：<br>[1] 搜索值不是数组元素，且在数组范围内，从1开始计数，得 “- 插入点索引值”；</p><ul><li>[2] 搜索值是数组元素，从0开始计数，得搜索值的索引值；</li><li>[3] 搜索值不是数组元素，且大于数组内元素，索引值为 – (length + 1);</li><li>[4] 搜索值不是数组元素，且小于数组内元素，索引值为 – 1。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> [] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>&#125;;</span><br><span class="line"><span class="type">var</span> <span class="variable">t</span> <span class="operator">=</span> Arrays.binarySearch(arr,<span class="number">7</span>);</span><br><span class="line"><span class="type">var</span> <span class="variable">t</span> <span class="operator">=</span> Arrays.binarySearch(arr,<span class="number">8</span>);</span><br><span class="line"><span class="type">var</span> <span class="variable">t</span> <span class="operator">=</span> Arrays.binarySearch(arr,<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>上面这种情况<br>key &#x3D; 7 搜到了直接返回下标3<br>key &#x3D; 8 不是数组元素 且大于数组元素  返回 -(length + 1) 即 -5<br>key &#x3D; 2 返回 -2 (因为从1开始计数) 那么实际插入的位置应该是 -(-2 + 1) &#x3D; 1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> [] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">7</span>&#125;;</span><br><span class="line"><span class="type">var</span> <span class="variable">t</span> <span class="operator">=</span> Arrays.binarySearch(arr,<span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>上面情况 返回3的位置是<strong>随机的</strong></p><p><strong>所以Java的二分库不太好用 也不太推荐用</strong></p>]]></content>
      
      
      <categories>
          
          <category> algo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>java集合进阶(Hash)</title>
      <link href="/2023/10/24/interview/java%E9%9B%86%E5%90%88%E8%BF%9B%E9%98%B6(Hash)/"/>
      <url>/2023/10/24/interview/java%E9%9B%86%E5%90%88%E8%BF%9B%E9%98%B6(Hash)/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2><span id="双列集合">双列集合</span></h2><p>单列集合一次只能添加一个元素<br>双列集合一次可以添加一对元素(键与值一一对应)</p><p>键值对 — Entry 对象</p><p>双列集合的特点<br><img src="/2023/10/24/interview/java%E9%9B%86%E5%90%88%E8%BF%9B%E9%98%B6(Hash)/img1.png" style="zoom:100%"></p><h2><span id="map集合常见api">Map集合常见API</span></h2><img src="/2023/10/24/interview/java%E9%9B%86%E5%90%88%E8%BF%9B%E9%98%B6(Hash)/img2.png" style="zoom:100%"><p>双列集合添加用<strong>put</strong> 而不是<strong>add</strong><br><img src="/2023/10/24/interview/java%E9%9B%86%E5%90%88%E8%BF%9B%E9%98%B6(Hash)/img3.png" style="zoom:100%"></p><p>遍历</p><ol><li>键找值</li><li>键值对</li><li>lambda表达式</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Map&lt;String,String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// 键找值</span></span><br><span class="line"><span class="comment">// 获取所有键 把这些键放到一个单列集合中</span></span><br><span class="line">Set&lt;String&gt; keys = map.keySet();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (String key : keys) &#123;</span><br><span class="line">    System.out.println(key);</span><br><span class="line">    <span class="comment">// 利用map集合中的键获取对应的值 get</span></span><br><span class="line">    map.get(key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过键值对进行遍历</span></span><br><span class="line"><span class="comment">// 通过一个方法获取所有的键值对对象 返回一个Set集合</span></span><br><span class="line">Set&lt;Map.Entry&lt;String, String&gt;&gt; entries = map.entrySet();</span><br><span class="line"><span class="comment">// 遍历Entries这个集合 去得到里面的每一个键值对对象</span></span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry : entries) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">    <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">    System.out.println(key + <span class="string">&quot;=&quot;</span> + value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// lambda 进行遍历</span></span><br><span class="line"><span class="comment">// 底层:</span></span><br><span class="line"><span class="comment">// forEach其实就是利用第二种方式进行遍历 一次得到每一个键值</span></span><br><span class="line"><span class="comment">// 再调用accept方法</span></span><br><span class="line">map.forEach(<span class="keyword">new</span> <span class="title class_">BiConsumer</span>&lt;String, String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(String key, String value)</span> &#123;</span><br><span class="line">        System.out.println(key + <span class="string">&quot;=&quot;</span> + value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 然后使用lambda 进行简化</span></span><br><span class="line">map.forEach((String key ,String value)-&gt;&#123;</span><br><span class="line">    System.out.println(key + <span class="string">&quot;=&quot;</span> + value);</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br><span class="line"><span class="comment">// 最简lambda表达式的形式</span></span><br><span class="line">map.forEach((key,value) -&gt; System.out.println(key + <span class="string">&quot;=&quot;</span> + value));</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2><span id="hashmap的底层原理">HashMap的底层原理</span></h2><p>首先创建长度位16 默认加载因子为0.75的数组<br>put方法先创建Entry对象 -&gt; 利用键 计算哈希值  得到索引插入<br>如果位置已经有元素 调用hashcode() 方法计算键的哈希值<br>如果值是一样的 则覆盖原来索引节点上的Entry对象<br>如果键不一样则会添加新的Entry对象<br>JDK8：后<br><img src="/2023/10/24/interview/java%E9%9B%86%E5%90%88%E8%BF%9B%E9%98%B6(Hash)/img4.png" style="zoom:100%"></p><h3><span id="linkedhashmap">LinkedHashMap</span></h3><p><strong>有序</strong><br><img src="/2023/10/24/interview/java%E9%9B%86%E5%90%88%E8%BF%9B%E9%98%B6(Hash)/img5.png" style="zoom:100%"></p><h3><span id="treemap">TreeMap</span></h3><img src="/2023/10/24/interview/java%E9%9B%86%E5%90%88%E8%BF%9B%E9%98%B6(Hash)/img6.png" style="zoom:100%"><p>TreeMap自定义排序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TreeMap 自定义排序</span></span><br><span class="line"><span class="comment">// Integer Double 默认情况下都是按照升序排列</span></span><br><span class="line"><span class="comment">// String 按照按照字母字典序排序</span></span><br><span class="line">TreeMap&lt;Integer,String&gt; tm = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer o1, Integer o2)</span> &#123;</span><br><span class="line">        <span class="comment">// o1: 当前要添加的元素</span></span><br><span class="line">        <span class="comment">// o2: 表示已经在红黑树中存在的元素</span></span><br><span class="line">        <span class="keyword">return</span> o1 - o2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> interview </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java集合 </tag>
            
            <tag> HashMap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode128最长连续序列</title>
      <link href="/2023/10/23/leetcode/leetcode128%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97/"/>
      <url>/2023/10/23/leetcode/leetcode128%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>原题链接:</p><ul><li><a href="https://leetcode.cn/problems/longest-consecutive-sequence/">https://leetcode.cn/problems/longest-consecutive-sequence/</a></li></ul><h2><span id="解法1-哈希集合-标记数">解法1 哈希集合 标记数</span></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 法1:</span></span><br><span class="line"><span class="comment">     * 哈希集合标记</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestConsecutive</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        HashSet&lt;Integer&gt;hash = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span>  x : nums)&#123;</span><br><span class="line">            hash.add(x);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> x : nums)&#123;</span><br><span class="line">           <span class="comment">// 前一个元素没有在集合中 说明该连续序列没有统计过</span></span><br><span class="line">            <span class="keyword">if</span>(hash.contains(x - <span class="number">1</span>) == <span class="literal">false</span>)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> x;</span><br><span class="line">                <span class="keyword">while</span> (hash.contains(cur))&#123;</span><br><span class="line">                    cur++;</span><br><span class="line">                &#125;</span><br><span class="line">                ans = Math.max(ans,cur - x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2><span id="解法2-哈希集合标记-右边界">解法2 哈希集合标记 右边界</span></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 法2 : 哈希存储右边界</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestConsecutive</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        HashMap&lt;Integer,Integer&gt; hash = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 初始化有边界 指向自己</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> x : nums)&#123;</span><br><span class="line">            hash.put(x,x);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> x : nums)&#123;</span><br><span class="line">            <span class="comment">// 如果当前区间没有被遍历过</span></span><br><span class="line">            <span class="keyword">if</span>(hash.containsKey(x - <span class="number">1</span>) == <span class="literal">false</span>)&#123;</span><br><span class="line">                <span class="comment">// 直接取出右边界 x在之前初始化过是不可能为0的</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> hash.getOrDefault(x,<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">while</span> (hash.containsKey(right))&#123;</span><br><span class="line">                    right++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 更新当数的有边界</span></span><br><span class="line">                hash.put(x,right);</span><br><span class="line">                ans = Math.max(ans,right - x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 哈希 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode2316统计无向图中无法互相达到点对数</title>
      <link href="/2023/10/21/leetcode/leetcode2316%E7%BB%9F%E8%AE%A1%E6%97%A0%E5%90%91%E5%9B%BE%E4%B8%AD%E6%97%A0%E6%B3%95%E4%BA%92%E7%9B%B8%E8%BE%BE%E5%88%B0%E7%82%B9%E5%AF%B9%E6%95%B0/"/>
      <url>/2023/10/21/leetcode/leetcode2316%E7%BB%9F%E8%AE%A1%E6%97%A0%E5%90%91%E5%9B%BE%E4%B8%AD%E6%97%A0%E6%B3%95%E4%BA%92%E7%9B%B8%E8%BE%BE%E5%88%B0%E7%82%B9%E5%AF%B9%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>原题链接:</p><p><a href="https://leetcode.cn/problems/count-unreachable-pairs-of-nodes-in-an-undirected-graph/description/">https://leetcode.cn/problems/count-unreachable-pairs-of-nodes-in-an-undirected-graph/description/</a></p><h2><span id="解法1-并查集">解法1: 并查集</span></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL; </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;p;</span><br><span class="line">    <span class="comment">// 并查集的根 及其 集合内对应点的数量</span></span><br><span class="line">    unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;cnt;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x!=p[x])&#123;</span><br><span class="line">            p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p[x];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并 </span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> a = <span class="built_in">find</span>(x);</span><br><span class="line">        <span class="type">int</span> b = <span class="built_in">find</span>(y);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 无向边采用这种方式 对点进行合并 防止重复 但同时又能确保所有点都合并</span></span><br><span class="line">        <span class="keyword">if</span>(a &lt;= b)&#123;</span><br><span class="line">            p[a] = b;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            p[b] = a;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">countPairs</span><span class="params">(<span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">        p.<span class="built_in">resize</span>(n);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 并查集初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n ; i++)&#123;</span><br><span class="line">            p[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> e: edges)&#123;</span><br><span class="line">            <span class="built_in">merge</span>(e[<span class="number">0</span>],e[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i &lt; n ; i++)&#123;</span><br><span class="line">            <span class="type">int</span> root = <span class="built_in">find</span>(i);</span><br><span class="line">            cnt[root] = cnt[root] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        LL ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            v个点自成一个集合 那么一共有n个点</span></span><br><span class="line"><span class="comment">            那么这个v个点自然与 n - v 个点不能相互抵达</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> [k,v] : cnt)&#123;</span><br><span class="line">            ans += <span class="number">1L</span> * (n - v) * v;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2><span id="解法2-dfs">解法2: DFS</span></h2>]]></content>
      
      
      <categories>
          
          <category> algo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并查集 </tag>
            
            <tag> DFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM_6自动垃圾回收</title>
      <link href="/2023/10/20/interview/JVM_6%E8%87%AA%E5%8A%A8%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
      <url>/2023/10/20/interview/JVM_6%E8%87%AA%E5%8A%A8%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>C&#x2F;C++ 内存管理<br><img src="/2023/10/20/interview/JVM_6%E8%87%AA%E5%8A%A8%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/img1.png" style="zoom:100%"></p><h2><span id="java的内存管理">Java的内存管理</span></h2><p>Java中为了简化对象的释放 引入了自动的<strong>垃圾回收(Garbage Collection简称GC)<strong>机制<br>通过垃圾回收器来对不再使用的对象完成自动的回收 垃圾回收器主要负责对</strong>堆</strong>上的内存进行回收<br>其他很多现代的语言比如C# Python Go都拥有自己的垃圾回收器</p><h3><span id="垃圾回收的对比">垃圾回收的对比</span></h3><img src="/2023/10/20/interview/JVM_6%E8%87%AA%E5%8A%A8%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/img2.png" style="zoom:100%"><h3><span id="垃圾回收应用场景">垃圾回收应用场景</span></h3><ol><li>解决系统僵死的问题: 大厂的系统出现的许多系统僵死问题 都与频繁的垃圾回收 </li><li>性能优化: 对垃圾回收器进行合理的设置可以有效地提升程序的执行性能</li><li>高频面试题<ol><li>常见的垃圾回收器</li><li>常见的垃圾回收算法</li><li>四种引用</li><li>项目中用了哪一种垃圾回收器</li></ol></li></ol><h1><span id="方法区的回收">方法区的回收</span></h1><p>线程不共享的部分 都是伴随着<strong>线程的创建而创建 线程的销毁而销毁</strong><br>而方法的栈帧在执行完方法之后就会自动弹出栈并释放掉对应的内存</p><img src="/2023/10/20/interview/JVM_6%E8%87%AA%E5%8A%A8%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/img3.png" style="zoom:100%"><p>方法区中能回收的内容主要就是不再使用的类<br>判定一个类可以被卸载 需要同时满足以下三个条件</p><ol><li>此类所有实例对象都已经被回收 在堆中不存在任何该类的实例对象以及子类对象</li><li>加载该类的类加载器已经被回收</li><li>该类对应的java.lang.Class 对象没有在任何地方被引用</li></ol><h1><span id="堆回收">堆回收</span></h1><p>Java中对象是否能被回收 是根据对象是否被<strong>引用</strong>来决定的 如果对象被引用了 说明该对象还在使用 不允许被回收</p><img src="/2023/10/20/interview/JVM_6%E8%87%AA%E5%8A%A8%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/img4.png" style="zoom:100%"><p>如果在main方法中最后执行 a1&#x3D;null b1&#x3D;null 是否能回收A和B对象？<br>可以回收 但方法中已经没有办法使用引用去访问A和B对象</p><p><strong>如何判断堆上对象是否被引用?</strong><br>常见的有两种判断方法: 引用计数法 和 可达性分析</p><h2><span id="引用计数法和可达性分析法">引用计数法和可达性分析法</span></h2><h3><span id="引用计数法">引用计数法</span></h3><p>引用计数法会为每一个对象维护一个引用计数器 当对象被引用时+1 取消引用时-1</p><img src="/2023/10/20/interview/JVM_6%E8%87%AA%E5%8A%A8%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/img5.png" style="zoom:100%"> <p>优缺点:<br><img src="/2023/10/20/interview/JVM_6%E8%87%AA%E5%8A%A8%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/img6.png" style="zoom:100%"></p><h3><span id="可达性分析法">可达性分析法</span></h3><img src="/2023/10/20/interview/JVM_6%E8%87%AA%E5%8A%A8%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/img7.png" style="zoom:100%"><img src="/2023/10/20/interview/JVM_6%E8%87%AA%E5%8A%A8%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/img8.png" style="zoom:100%"><p><strong>GC Root对象</strong></p><ol><li>线程Thread对象: 引用线程栈帧中的方法参数 局部参数等</li><li>系统类加载器加载的java.lang.Class对象 , 引用类中的静态变量 <img src="/2023/10/20/interview/JVM_6%E8%87%AA%E5%8A%A8%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/img9.png" style="zoom:100%"></li><li>监视器对象 用来保存同步锁synchronized关键字持有的对象 (即同步锁synchronized关键字所持有的对象是不可以被回收的 )<img src="/2023/10/20/interview/JVM_6%E8%87%AA%E5%8A%A8%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/img10.png" style="zoom:100%"></li><li>本地方法调用时使用的全局对象</li></ol><h2><span id="五种对象引用">五种对象引用</span></h2><p>可达性算法中描述的对象引用 一般指的是强引用 即使GCRoot对象和普通对象有引用关系 只要这层关系存在 普通对象就不会被回收 </p><p>除了强引用外 Java中还设计了 软引用 弱引用 虚引用 终结器引用</p><h3><span id="软引用">软引用</span></h3><img src="/2023/10/20/interview/JVM_6%E8%87%AA%E5%8A%A8%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/img11.png" style="zoom:100%"><p>当GC Root对象与SoftReference对象内的对象A 之间强引用关系删除后 当程序内存不足时 就会将软引用中的数据回收<br>GCRoot 和 SoftReference对象之间应该是强引用关系 否则软引用对象也可能会被回收</p><img src="/2023/10/20/interview/JVM_6%E8%87%AA%E5%8A%A8%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/img12.png" style="zoom:100%"><img src="/2023/10/20/interview/JVM_6%E8%87%AA%E5%8A%A8%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/img13.png" style="zoom:100%"><p>实现案例<br><img src="/2023/10/20/interview/JVM_6%E8%87%AA%E5%8A%A8%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/img14.png" style="zoom:100%"></p><h3><span id="弱引用">弱引用</span></h3><p>弱引用的整体机制和软引用基本一致 区别在于弱引用包含的对象在垃圾回收时 不管内存够不够都会<strong>直接被回收</strong><br><strong>开发中基本不用</strong><br><img src="/2023/10/20/interview/JVM_6%E8%87%AA%E5%8A%A8%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/img15.png" style="zoom:100%"></p><h3><span id="虚引用和终结器引用">虚引用和终结器引用</span></h3><p><strong>这两种引用在常规开发中时不会使用的</strong></p><img src="/2023/10/20/interview/JVM_6%E8%87%AA%E5%8A%A8%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/img16.png" style="zoom:100%"><h2><span id="垃圾回收算法">垃圾回收算法</span></h2><p>核心算法:<br>简单来说i 垃圾回收要做的有两件事:</p><ol><li>找到内存中存活的对象</li><li>释放不再存活对象的内存 使得程序能再次利用这部分空间</li></ol><h3><span id="垃圾回收算法评价标准">垃圾回收算法评价标准</span></h3><p>STW:<br><img src="/2023/10/20/interview/JVM_6%E8%87%AA%E5%8A%A8%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/img17.png" style="zoom:100%"></p><p>评价标准:</p><ol><li><p>吞吐量</p><img src="/2023/10/20/interview/JVM_6%E8%87%AA%E5%8A%A8%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/img18.png" style="zoom:100%"></li><li><p>最大暂停时间</p></li><li><p>堆使用效率</p><img src="/2023/10/20/interview/JVM_6%E8%87%AA%E5%8A%A8%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/img19.png" style="zoom:100%"></li></ol><h3><span id="垃圾回收算法">垃圾回收算法</span></h3><p>标记清除算法<br>复制算法<br>标记整理算法<br><strong>分代GC</strong></p><img src="/2023/10/20/interview/JVM_6%E8%87%AA%E5%8A%A8%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/img20.png" style="zoom:100%"><h3><span id="分代gc">分代GC</span></h3><p>分代垃圾回收将整个内存区域分为年轻代和老年代<br><img src="/2023/10/20/interview/JVM_6%E8%87%AA%E5%8A%A8%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/img21.png" style="zoom:100%"></p><p>分代回收时 创建出来的对象 首先会被放入Eden伊甸园区<br>随着对象在Eden区越来越多 如果Eden区满 新创建的对象依已经无法放入 就会触发年轻代的GC 称为Minor GC或者 Young GC<br>Minor GC会把需要Eden中和From需要回收的对象回收 把没有回收的对象放入To区</p><img src="/2023/10/20/interview/JVM_6%E8%87%AA%E5%8A%A8%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/img22.png" style="zoom:100%"><p>接下来 S0会变成To区 S1变成From区 当Eden区满时再往里放入对象 依然会发生Minor GC<br>此时会回收Eden区和S1(from)中的对象 并把Eden和From区中剩余的对象放入S0<br>注意:每次Minor GC中都会为对象记录他的年龄 初始值为0 每次GC完加1</p><img src="/2023/10/20/interview/JVM_6%E8%87%AA%E5%8A%A8%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/img23.png" style="zoom:100%"><p>如果Minor GC后对象的年龄到达阈值(最大15 默认值和垃圾回收器有关) 对象就会晋升至老年代<br><img src="/2023/10/20/interview/JVM_6%E8%87%AA%E5%8A%A8%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/img24.png" style="zoom:100%"></p><p>当老年代中空间不足 无法放入新的对象时<br>先尝试Minor GC如果还是不足(先尝试Minor GC 是因为当年轻代满时 即使一些对象没有到达最大阈值15 也会被放入老年代)<br>就会触发Full GC m, FUll GC会对整个堆(年轻代 + 老年代)进行垃圾回收 -&gt; Full GC stw长 (长于Minor 的stw)<br>如果Full GC依然无法回收掉老年代的对象 那么当对象继续放入老年代时 就会抛出Out of Memory异常</p><p>问题: 为什么分代GC算法要把堆分成年轻代和老年代<br><img src="/2023/10/20/interview/JVM_6%E8%87%AA%E5%8A%A8%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/img25.png" style="zoom:100%"></p><p>分代GC算法将堆分成年轻代和老年代主要原因有：</p><ol><li>可以通过调整年轻代和老年代的比例来适应不同类型的应用程序 提高的内存的利用率和性能</li><li>新生代和老年代使用不同的垃圾回收算法 新生代一般选择复制算法 老年代可以选择标记-清除和标记整理算法 由程序员来选择灵活度高的</li><li>分代的设计中允许只回收新生代(minor gc) 如果能满足对象分配的要求就不需要堆整个堆进行回收(full gc) stw的时间就会减少</li></ol><h2><span id="垃圾回收器">垃圾回收器</span></h2><p>垃圾回收器的组合关系:<br><img src="/2023/10/20/interview/JVM_6%E8%87%AA%E5%8A%A8%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/img26.png" style="zoom:100%"></p><p>年轻代-Serial垃圾回收器</p><img src="/2023/10/20/interview/JVM_6%E8%87%AA%E5%8A%A8%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/img27.png" style="zoom:100%"><p>老年代-SerialOld垃圾回收器</p><img src="/2023/10/20/interview/JVM_6%E8%87%AA%E5%8A%A8%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/img28.png" style="zoom:100%"><p>年轻代-ParNew垃圾回收器(JDK9 以后不建议使用)</p><img src="/2023/10/20/interview/JVM_6%E8%87%AA%E5%8A%A8%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/img29.png" style="zoom:100%"><p>老年代-CMS 垃圾回收器</p><img src="/2023/10/20/interview/JVM_6%E8%87%AA%E5%8A%A8%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/img30.png" style="zoom:100%"><p>执行步骤</p><img src="/2023/10/20/interview/JVM_6%E8%87%AA%E5%8A%A8%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/img31.png" style="zoom:100%"><p>缺点:<br><img src="/2023/10/20/interview/JVM_6%E8%87%AA%E5%8A%A8%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/img32.png" style="zoom:100%"></p><p>CMS垃圾回收器关注的是系统的暂停时间 允许用户线程和垃圾回收线程在某些步骤中同时执行<br>减少了用户线程的等待时间</p>]]></content>
      
      
      <categories>
          
          <category> interview </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> 垃圾回收机制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java异常</title>
      <link href="/2023/10/20/interview/java%E5%BC%82%E5%B8%B8/"/>
      <url>/2023/10/20/interview/java%E5%BC%82%E5%B8%B8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2><span id="异常类">异常类</span></h2><h3><span id="javalangthrowable">java.lang.Throwable</span></h3><p>在Java中 所有异常都有一个共同的祖先java.lang包中的<strong>Throwable类</strong></p><p>Throwbale 包含两个重要子类 Exception(异常) Error(错误)</p><h3><span id="error">Error</span></h3><p>Error 是程序无法处理的错误信息 表示代码运行时<strong>JVM</strong>(Java虚拟机)出现的问题 如: OutOfMemoryError<br>这些异常发生时 JVM一般会选择<strong>线程终止</strong></p><h3><span id="exception">Exception</span></h3><p>运行时异常(RuntimeException)<br>编译时异常<br><strong>编译时异常 需要保证在运行之前给出一个处理方案</strong></p><h2><span id="异常处理">异常处理</span></h2><p>异常默认处理流程</p><img src="/2023/10/20/interview/java%E5%BC%82%E5%B8%B8/img1.png" style="zoom:100%"><h3><span id="try-catch">try-catch</span></h3><p>好处: 异常对象可以被捕获 后续的代码可以继续执行</p><p>格式:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    可能会出异常的代码</span><br><span class="line">&#125; <span class="keyword">catch</span>(异常名称 对象名)&#123;</span><br><span class="line">    异常的处理方案</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行流程:</p><ol><li>执行try{} 中的代码 看是否有异常对象产生</li><li>没有: catch就不会捕获 后续代码继续执行</li><li>有: catch捕获异常<strong>对象</strong> 执行catch{} 中的处理方案 后续代码继续执行部</li></ol><p><strong>如果要捕获多个异常那么最大的异常一定要最后 否则编译器会报错</strong> 例如:Exception要放在最后一个catch中</p><h3><span id="抛出处理">抛出处理</span></h3><img src="/2023/10/20/interview/java%E5%BC%82%E5%B8%B8/img3.png" style="zoom:100%"><ol><li>throws: 写在方法定义处 表示声明一个异常 告诉调用者 使用本方法可能会存在哪些异常</li><li>throw: 写在方法内 结束方法 手动抛出异常对象 交给调用者 方法中下面的代码不再执行了</li></ol><p><strong>编译时异常必须用throws声明</strong><br>throws 抛出异常但不处理异常</p><h3><span id="两种异常处理方式比较">两种异常处理方式比较</span></h3><p>根据正在面临的异常 是否需要暴露出来</p><ul><li>不需要暴露: try … catch 捕获   (通常对于用户)</li><li>需要暴露: 抛出异常        (通常对于使用者)</li></ul><h2><span id="问题">问题</span></h2><h3><span id="如果try中没有遇到问题-怎么执行">如果try中没有遇到问题 怎么执行</span></h3><p>会把try里面所有的代码全部执行完毕 不会执行catch里面的代码<br>注意:<br>    只有当出现了异常才会执行catch</p><h3><span id="如果try中可能会遇到多个问题-怎么执行">如果try中可能会遇到多个问题 怎么执行</span></h3><p>会写多个catch与之对应<br>细节:<br>    如果我们要捕获多个异常 这些异常如果存在父子关系的话 那么父类一定要写在下面<br>了解性:<br>    在JDK7之后 我们可以在catch中同时捕获多个异常 中间用 | 进行隔开<br>    如果出现 A异常 | B异常的话 采取同一种处理方案 </p><h3><span id="如果try中遇到的问题没有被捕获-怎么执行">如果try中遇到的问题没有被捕获 怎么执行</span></h3><p>相当于try…catch的代码白写了 最终还是会交给虚拟机进行处理</p><h3><span id="如果try中遇到了问题-那么try下面的其他代码还会执行吗">如果try中遇到了问题 那么try下面的其他代码还会执行吗</span></h3><p>下面的代码就不会执行了 直接跳转到对应的catch当中 执行catch里面的语句体<br>但是如果没有对应catch与之匹配 那么最终还是会交给虚拟机进行处理 </p><h3><span id="总结">总结</span></h3><img src="/2023/10/20/interview/java%E5%BC%82%E5%B8%B8/img2.png" style="zoom:100%"><h2><span id="常见异常方法">常见异常方法</span></h2><ol><li>public String getMessage() 返回次throwable() 的详细消息字符串</li><li>public String toString() 返回此可抛出的简短描述</li><li>public void printStackTrace() <ol><li>在底层是利用System.err.println进行输出  </li><li>把异常的错误信息以红色字体输出在控制台</li><li>细节 仅仅是打印西悉尼 <strong>不会停止程序运行</strong></li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> interview </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 异常 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode1726同积元组</title>
      <link href="/2023/10/19/leetcode/leetcode1726%E5%90%8C%E7%A7%AF%E5%85%83%E7%BB%84/"/>
      <url>/2023/10/19/leetcode/leetcode1726%E5%90%8C%E7%A7%AF%E5%85%83%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>原题链接:<br><a href="https://leetcode.cn/problems/tuple-with-same-product/">https://leetcode.cn/problems/tuple-with-same-product/</a></p><h2><span id="解法1">解法1:</span></h2><p>哈希表记数 + 排列组合求解</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    哈希 + 排列组合</span></span><br><span class="line"><span class="comment">    hash记录乘积出现的次数 -&gt; 乘积由两个数相乘构成 -&gt; 出现两次相同的乘积证明有四个数符合题目要求</span></span><br><span class="line"><span class="comment">    -&gt; 出现n次 则只需从n对中任意选两对进行组合即可C(2,n) -&gt; 又因为根据题意四元组内的数顺序不同也是可以算是一种组合 A(2,4) </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">tupleSameProduct</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 乘积 -&gt; 乘积出现的次数</span></span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;hash;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i &lt; n ; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = i + <span class="number">1</span> ; j &lt; n ; j++)&#123;</span><br><span class="line">                hash[nums[i] * nums[j]]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; [k,v] : hash)&#123;</span><br><span class="line">            <span class="keyword">if</span>(v &lt;= <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// v  dsa</span></span><br><span class="line">            ans += v*(v - <span class="number">1</span>) / <span class="number">2</span>  * <span class="number">8</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排列组合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM_5运行时数据区</title>
      <link href="/2023/10/18/interview/JVM_5%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/"/>
      <url>/2023/10/18/interview/JVM_5%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>总览<br><img src="/2023/10/18/interview/JVM_5%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/img1.png" style="zoom:100%"></p><p>面试相关难题</p><ol><li>Java的内存分成哪几部分 详细介绍一下</li><li>Java内存中哪些部分会溢出？</li><li>JDK7和8在内存结构上的区别是什么？</li></ol><p>内存调优:<br><img src="/2023/10/18/interview/JVM_5%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/img2.png" style="zoom:100%"></p><h2><span id="程序计数器">程序计数器</span></h2><p>程序计数器(Program Conter Register) 也叫PC寄存器 每个线程会通过程序计数器记录当前要执行的字节码指令的地址</p><ol><li>在加载阶段 虚拟机将字节码文件中的指令读取到内存之后 会将原文件中的偏移量转换成内存地址 每一条字节码指令都会拥有一个内存地址</li><li>在代码执行过程中 程序计数器会记录下一行字节码指令的地址 执行完当前指令之后 虚拟机的执行引擎根据程序计数器执行下一行指令</li><li>程序计数器可以控制程序指令的进行，实现分支、跳转、异常等逻辑</li><li>在多线程执行情况下 Java虚拟机需要通过程序计数器记录CPU切换前解释执行到哪一句指令并继续解释运行</li></ol><p><strong>问题: 程序计数器在运行中会出现内存溢出吗?</strong><br>内存溢出:指的是程序在使用某一块内存区域时，存放的数据需要占用的内存大小超过了虚拟机能提供的内存上限<br>不会<br>因为每个线程只存储一个固定长度的内存地址 程序计数器是不会发生内存溢出的(程序员无需对程序计数器做任何处理 程序计数器完全由java虚拟机控制)</p><h2><span id="栈">栈</span></h2><p>Java虚拟机栈  本地方法栈</p><h3><span id="java虚拟机栈">Java虚拟机栈</span></h3><ol><li>Java虚拟机栈 采用栈的数据结构来管理方法调用中的基本数据 每一个方法的调用使用一个栈帧来保存</li><li>Java虚拟机栈随着线程的创建而创建 而回收则会在线程的销毁时进行 由于方法可能会在不同线程中执行 每个线程都会包含一个自己的虚拟机栈</li></ol><p><strong>栈帧的组成</strong><br><img src="/2023/10/18/interview/JVM_5%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/img3.png" style="zoom:100%"></p><h4><span id="局部变量表">局部变量表</span></h4><p>作用是在运行过程中存放所有的局部变量 -&gt; 编译成字节码文件时就可以确定局部变量表的内容</p><ol><li>栈帧中的局部变量表是一个数组 数组每一个位置称之为槽(slot)  long和double类型占用两个槽 其他类型占一个槽</li><li>实例方法中的序号为0的位置存放的是this(<strong>即当前实例对象的引用</strong>) 指的是当前调用方法的对象 运行时会在内存中存放实例对象的地址</li><li>方法参数也会保存在局部变量表中 其顺序与方法中参数定义的顺序一致</li><li>局部变量表保存的内容由：实例方法的this对象 方法的参数 方法体中声明的局部变量</li></ol><p>问题:<br><img src="/2023/10/18/interview/JVM_5%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/img4.png" style="zoom:100%"><br>(答案并不是9 (9 的算法: this 1个 6个int 1个long))</p><p>为了节省空间 局部变量表中的槽是可以<strong>复用</strong>的 一旦某个局部变量不再生效 当前槽就可以再次被使用</p><h4><span id="操作数栈">操作数栈</span></h4><p>是栈帧中虚拟机在执行指令过程中用来存放临时数据的一块区域<br>操作数栈是栈帧中虚拟机在执行指令过程中用来存放中间数据的一块区域 他是一种栈式的数据结构 如果一条指令将一个值压入操作数栈 则后面的指令可以弹出并使用改值<br>在<em>编译器</em>就可以确定操作数栈的最大深度 从而执行时正确的分配内存大小</p><h4><span id="帧数据">帧数据</span></h4><p>帧数据主要包含动态链接、方法出口、异常表的引用</p><ol><li><p>动态链接<br>当前类的字节码指令引用了其他类的属性或者方法时 需要将符号引用(编号) 转换成对应的运行时常量池中的内存地址 动态链接就保存了编号到运行时常量池的内存地址的映射关系</p><img src="/2023/10/18/interview/JVM_5%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/img5.png" style="zoom:100%"></li><li><p>方法出口<br>方法出口指的是方法在正确或异常结束时 当前栈帧会被弹出 同时程序计数器应该指向上一个栈帧中的下一条指令的地址 所以在当前栈中 需要存储此方法出口的地址</p></li><li><p>异常表<br>异常表存放的是异常的处理信息 包含了try代码块和catch代码块执行后跳转到的字节码指令位置</p></li></ol><h3><span id="栈-内存溢出">栈-内存溢出</span></h3><p>Java虚拟机栈如果栈帧过多 占用内存超过栈内存可以分配的最大大小就会出现内存溢出<br>Java虚拟机栈内存溢出时会出现StackOverflowError的错误</p><p>Java虚拟机栈 注意事项<br><img src="/2023/10/18/interview/JVM_5%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/img6.png" style="zoom:100%"></p><h3><span id="本地方法栈">本地方法栈</span></h3><p>Java虚拟机栈存储了Java方法调用时的栈帧 而本地方法存储的是native本地方法(用C++来写)的栈帧<br>在Hotspot虚拟机中 Java虚拟机栈和本地方法栈实现上使用了同一个栈空间 本地方法栈会在栈内存上生成一个栈帧 临时保存方法的参数同时方便出现异常时也把本地方法的栈信息打印出来</p><h2><span id="堆内存">堆内存</span></h2><p>堆内存存储<strong>对象</strong><br><img src="/2023/10/18/interview/JVM_5%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/img7.png" style="zoom:100%"></p><p>堆内存也会发生内存溢出 -&gt; OutofMemory错误</p><p>堆内存的三个值 used total max<br>max默认为系统的1&#x2F;4 total默认为系统的1&#x2F;64</p><img src="/2023/10/18/interview/JVM_5%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/img8.png" style="zoom:100%"><p>随着堆中的对象增多 当total可以使用的内存<strong>即将</strong>不足时 java虚拟机会继续分配内存给堆<br>total值会变大 total最多只能与max相等</p><p>问题:<br><img src="/2023/10/18/interview/JVM_5%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/img9.png" style="zoom:100%"></p><h2><span id="方法区">方法区</span></h2><p>方法区是存放基础信息的位置 线程共享 主要包含:</p><img src="/2023/10/18/interview/JVM_5%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/img10.png" style="zoom:100%"><ol><li>方法区是用来存储每个类的基本信息(元信息) 一般称之为InstanceKlass对象 在类的<strong>加载阶段</strong>完成</li><li><img src="/2023/10/18/interview/JVM_5%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/img11.png" style="zoom:100%"></li></ol><p>方法区属于&lt;&lt;JAVA虚拟机规范&gt;&gt;中设计的虚拟概念<br>JDK7中使用永久代来实现<br>JDK8中使用元空间来实现<br><img src="/2023/10/18/interview/JVM_5%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/img12.png" style="zoom:100%"></p><p>方法区溢出<br><img src="/2023/10/18/interview/JVM_5%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/img13.png" style="zoom:100%"><br>为元空间分配最大内存大小 防止内存占用率过高</p><h3><span id="字符串常量池">字符串常量池</span></h3><p>字符串中常量池存储在代码中定义的常量字符串内容 比如”123” 这个”123”就会被放入字符串常量池<br><img src="/2023/10/18/interview/JVM_5%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/img14.png" style="zoom:100%"><br>s1 通过new 关键字创建对象 最终会放在堆内存中 (s1是栈中的局部变量 用于表示字符串”123”在堆内存中的地址)<br>s2 并没有通过new关键字创建对象 s2存放的是字符串常量池中”abc”的地址</p><img src="/2023/10/18/interview/JVM_5%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/img15.png" style="zoom:100%">即JDK8以后 运行时常量池和字符串常量池就已经不是一个东西了<p>问题1:<br><img src="/2023/10/18/interview/JVM_5%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/img16.png" style="zoom:100%"><br>分析:<br><img src="/2023/10/18/interview/JVM_5%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/img17.png" style="zoom:100%"></p><p>如上图所示显然是不相等 a b c 中存放的字符串常量池中的地址<br>但是根据底层代码(字节码指令)所示 d &#x3D; a + b 在底层实际是使用了new方法进行创建<br>即<strong>变量 连接使用的是StringBuilder</strong><br>因此d中存放的堆内存中的地址 c与d显然是不相等</p><p>问题2:<br><img src="/2023/10/18/interview/JVM_5%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/img18.png" style="zoom:100%"></p><p>d为<strong>常量 编译阶段直接连接</strong></p><h2><span id="直接内存">直接内存</span></h2><img src="/2023/10/18/interview/JVM_5%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/img19.png" style="zoom:100%"><h1><span id="总结">总结</span></h1>]]></content>
      
      
      <categories>
          
          <category> interview </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode2530执行k次操作后的最大分数</title>
      <link href="/2023/10/18/leetcode/leetcode2530%E6%89%A7%E8%A1%8Ck%E6%AC%A1%E6%93%8D%E4%BD%9C%E5%90%8E%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%86%E6%95%B0/"/>
      <url>/2023/10/18/leetcode/leetcode2530%E6%89%A7%E8%A1%8Ck%E6%AC%A1%E6%93%8D%E4%BD%9C%E5%90%8E%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%86%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>原题链接:<br><a href="https://leetcode.cn/problems/maximal-score-after-applying-k-operations/">https://leetcode.cn/problems/maximal-score-after-applying-k-operations/</a></p><h2><span id="解法1-堆">解法1 堆</span></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    贪心 每次选最大的执行即可</span></span><br><span class="line"><span class="comment">    heap</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">maxKelements</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// c++ 堆默认 大根堆</span></span><br><span class="line">        <span class="comment">// 值 以及 下标</span></span><br><span class="line">        priority_queue&lt;pair&lt;LL,<span class="type">int</span>&gt;&gt;heap;       </span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i &lt; nums.<span class="built_in">size</span>() ; i++)&#123;</span><br><span class="line">            heap.<span class="built_in">push</span>(<span class="built_in">pair</span>&lt;LL,<span class="type">int</span>&gt;(nums[i],i));</span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        LL ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(k)&#123;</span><br><span class="line">            k--;</span><br><span class="line">            <span class="keyword">auto</span> x = heap.<span class="built_in">top</span>();</span><br><span class="line">            ans += x.first;</span><br><span class="line">            heap.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="comment">// ceil c++上取整函数</span></span><br><span class="line">            heap.<span class="built_in">push</span>(<span class="built_in">pair</span>&lt;LL,<span class="type">int</span>&gt;(<span class="built_in">ceil</span>(x.first/<span class="number">3.0</span>), x.second));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JVM_4类加载器</title>
      <link href="/2023/10/16/interview/JVM_4%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/"/>
      <url>/2023/10/16/interview/JVM_4%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ol><li><p>类加载器<br>类加载器是Java虚拟机提供给应用程序取获取类和接口字节码数据的技术</p><img src="/2023/10/16/interview/JVM_4%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/img1.png" style="zoom:100%"></li><li><p>类加载器应用场景</p><img src="/2023/10/16/interview/JVM_4%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/img2.png" style="zoom:100%"></li></ol><h2><span id="类加载器的分类">类加载器的分类</span></h2><img src="/2023/10/16/interview/JVM_4%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/img3.png" style="zoom:100%"><h3><span id="启动类加载器">启动类加载器</span></h3><p>启动类加载器(Bootstrap ClassLoader) 是有Hotspot虚拟机提供的 使用c++编写的类加载器<br>默认加载Java安装目录&#x2F;jre&#x2F;lib下的类文件 比如rt.jar,tools.jar, resources.jar等</p><p>通过启动类加载器去加载用户jar包(不推荐)<br>使用参数进行扩展</p><h2><span id="双亲委派机制">双亲委派机制</span></h2><p>使用应用类加载器去加载类 却发现是扩展类加载器对类进行加载<br><img src="/2023/10/16/interview/JVM_4%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/img4.png" style="zoom:100%"></p><img src="/2023/10/16/interview/JVM_4%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/img5.png" style="zoom:100%"><p><strong>在类加载器的过程中 每个类加载器都会先检查是否已经加载了该类 如果已经加载了则直接返回 否则会加载请求委派给父类加载器</strong><br><strong>在双亲委派机制中 如果parent为null 则会提交给启动类加载器处理</strong><br>如果所有的父类都无法加载该类 则由当前类加载器自己尝试加载 所以看上去自顶向下尝试<br>第二次再去加载相同的类 仍然会向上进行委派 如果某个类加载器加载过就会直接返回</p><img src="/2023/10/16/interview/JVM_4%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/img6.png" style="zoom:100%"><p>双亲委派机制例题:<br><img src="/2023/10/16/interview/JVM_4%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/img7.png" style="zoom:100%"></p><p>双亲委派机制的作用：</p><ol><li>保证类加载的安全性<ol><li>通过双亲委派机制 让顶层的类加载器去加载核心类 避免恶意代码替换JDK中的核心类库</li></ol></li><li>避免重复加载<ol><li>双亲委派机制可以避免同一个类被多次加载 上层的类加载器如果加载过类 就会直接返回该类 避免了重复加载</li></ol></li></ol><h2><span id="打破双亲委派机制">打破双亲委派机制</span></h2><p>打破双亲委派机制的3种方式<br><img src="/2023/10/16/interview/JVM_4%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/img8.png" style="zoom:100%"></p><p>1.自定义类加载器<br>示例: Tomcat<br><img src="/2023/10/16/interview/JVM_4%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/img9.png" style="zoom:100%"></p><img src="/2023/10/16/interview/JVM_4%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/img10.png" style="zoom:100%"><p>正确的去实现一个自定义类加载器的方式是重写findClass方法 这样不会破坏双亲委派机制</p><ol start="2"><li><p>线程上下文类加载器</p></li><li><p>Osgi框架的类加载器</p></li></ol><h2><span id="jdk9">JDK9</span></h2>]]></content>
      
      
      <categories>
          
          <category> interview </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JV, </tag>
            
            <tag> 类加载器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode260只出现一次的数字Ⅲ</title>
      <link href="/2023/10/16/leetcode/leetcode260%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97%E2%85%A2/"/>
      <url>/2023/10/16/leetcode/leetcode260%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97%E2%85%A2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>原题链接:<br><a href="https://leetcode.cn/problems/single-number-iii/description/">https://leetcode.cn/problems/single-number-iii/description/</a></p><h2><span id="解法1-位运算-分组异或">解法1: 位运算 分组异或</span></h2><p>要求是线性时间复杂度的算法且仅使用常量额外空间来解决此问题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    分组异或</span></span><br><span class="line"><span class="comment">    先对nums中所有数进行异或得到sum  根据题意以及异或运算的性质 sum两个不同数的异或值(其他两个相同的数直接被抵消了)</span></span><br><span class="line"><span class="comment">    然后取sum二进制位的任意为1 的一位  根据异或运算性质该位为1 说明 对于两个不同的数在第k位的二进制为的表示不同</span></span><br><span class="line"><span class="comment">    然后对原nums中的数 第k位为0或1的分别进行异或运算 这样相同的数仍然会消去(反证法 思想如果k位不相同那么数必定不同 就一定不可能在同一个组内进行运算)</span></span><br><span class="line"><span class="comment">     最后得到就是两个不同的数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">singleNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 先进一次异或运算 得到sum</span></span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x: nums)&#123;</span><br><span class="line">            sum ^= x;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 找到任意的第k位</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">31</span> ; i &gt;= <span class="number">0</span> ; i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>((sum &gt;&gt; i) &amp; <span class="number">1</span> == <span class="number">1</span>)&#123;</span><br><span class="line">                k = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;<span class="built_in">ans</span>(<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x : nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>((x &gt;&gt; k) &amp; <span class="number">1</span>)&#123;</span><br><span class="line">                ans[<span class="number">1</span>] ^= x;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ans[<span class="number">0</span>] ^= x;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 位运算 </tag>
            
            <tag> 异或 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM_3类的生命周期</title>
      <link href="/2023/10/15/interview/JVM_3%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
      <url>/2023/10/15/interview/JVM_3%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>应用场景</p><ol><li>运行时常量池</li><li>多态的原理</li><li>类加载器的作用</li><li>类的加密和解密</li></ol><h2><span id="生命周期概述">生命周期概述</span></h2><p>加载-&gt;连接-&gt;初始化-&gt;使用-&gt;卸载<br><img src="/2023/10/15/interview/JVM_3%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/img1.png" style="zoom:100%"></p><h2><span id="加载阶段">加载阶段</span></h2><ol><li><p>加载(Loading)阶段第一步时类加载器根据类的全限定名通过不同的渠道(本地文件、动态代理生成、通过网络传输的类)以二进制流的方式来获取字节码信息<br>可以使用java代码扩展不同的渠道</p></li><li><p>类加载器在加载完类之后，Java虚拟机会将字节码中的信息保存到方法区中<br>生成一个InstanceKlass对象 把保存类的所有信息 里面还包含实现特定功能比如多态的信息</p></li><li><p>同时Java虚拟机还会在堆中生成一份与方法区中数据类似的java.lang.Class对象<br> 作用是在Java代码中去获取类的信息以及存储静态字段的数据(JDK8及以后)</p></li><li><p>对于开发者来说只需要访问堆中的Class对象而不需要访问方法区中所有信息。<br>这样Java虚拟机就能很好地控制开发者访问数据的范围</p></li></ol><h2><span id="连接阶段">连接阶段</span></h2><h3><span id="验证">验证</span></h3><p>验证内容是否满足&lt;Java虚拟机规范&gt;<br><img src="/2023/10/15/interview/JVM_3%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/img2.png" style="zoom:100%"></p><h3><span id="准备">准备</span></h3><p>给静态变量赋初值<br>准备阶段赋的是初始值 与 变量真正在代码中赋的值是不同的(真正赋值的这个步骤在初始化阶段完成)<br><img src="/2023/10/15/interview/JVM_3%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/img3.png" style="zoom:100%"></p><p>但如果是<strong>final</strong>修饰的基本数据类型的静态变量 准备阶段直接会将代码中的值进行赋值</p><h3><span id="解析">解析</span></h3><p>将常量池中的符号引用替换成指向内存的直接引用<br><strong>直接引用不再使用编号 二是使用内存地址中地址 进行访问具体的数据</strong></p><h2><span id="初始化阶段">初始化阶段</span></h2><p>初始化阶段会执行<strong>静态代码块中的代码</strong> 并为静态变量赋值<br>初始化阶段会执行字节码文件中<strong>clinit</strong>部分的字节码指令<br><img src="/2023/10/15/interview/JVM_3%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/img4.png" style="zoom:100%"></p><p>题目示例:<br><img src="/2023/10/15/interview/JVM_3%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/img5.png" style="zoom:100%"></p><p>直接访问父类的静态变量 不会触发子类的初始化<br>子类的初始化clinit调用之前 会先调用父类的clinit初始化方法<br><img src="/2023/10/15/interview/JVM_3%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/img6.png" style="zoom:100%"></p><h2><span id="笔记总结">笔记总结</span></h2><img src="/2023/10/15/interview/JVM_3%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/img7.png" style="zoom:100%"><img src="/2023/10/15/interview/JVM_3%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/img8.png" style="zoom:100%"><img src="/2023/10/15/interview/JVM_3%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/img9.png" style="zoom:100%">]]></content>
      
      
      <categories>
          
          <category> interview </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> 类的生命周期 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++STL</title>
      <link href="/2023/10/15/algoSummary/c++STL/"/>
      <url>/2023/10/15/algoSummary/c++STL/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2><span id="哈希集合基本操作">哈希集合基本操作</span></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;h1;</span><br><span class="line">unordered_set&lt;<span class="type">int</span>&gt;h2;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在容器中查找以 key 键的键值对的个数。</span></span><br><span class="line">h1.<span class="built_in">count</span>(键值)</span><br><span class="line">h2.<span class="built_in">count</span>(键值)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找以 key 为键的键值对，如果找到，则返回一个指向该键值对的正向迭代器；反之，则返回一个指向容器中最后一个键值对之后位置的迭代器（如果 end() 方法返回的迭代器）。</span></span><br><span class="line"><span class="comment">// 所以对find 进行判断 要根据迭代器进行判断</span></span><br><span class="line">h1.<span class="built_in">find</span>(键值) == h1.<span class="built_in">end</span>() <span class="comment">// 没找到</span></span><br><span class="line">h1.<span class="built_in">find</span>(键值) != h1.<span class="built_in">end</span>() <span class="comment">// 找到</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2><span id="遍历map">遍历map</span></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;hash;</span><br><span class="line"><span class="comment">// 遍历值</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> &amp; v : hash)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历键值对</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> it = hash.<span class="built_in">begin</span>() ; it != hash.<span class="built_in">end</span>() ; it++)&#123;</span><br><span class="line">    cout &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="切片">切片</span></h2><p>以vector为例子</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;q;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回前k个的话</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(q.<span class="built_in">begin</span>(),q.<span class="built_in">begin</span>() + k);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2><span id="c-自定义排序">c++ 自定义排序</span></h2><p>自定义排序 在算法题中运用的非常多 尤其是贪心之类的题目 </p><ol><li>cmp<br>自定义cmp函数 传入 sort中  相对来说比较麻烦 但比较清晰吧 记不起lambda的时候 可以用这个</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Data</span>&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 升序 </span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp1</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &lt; b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 降序</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp2</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结构体排序</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmps1</span><span class="params">(Data &amp;d1,Data &amp;d2)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 按照 a 升序</span></span><br><span class="line">    <span class="keyword">return</span> d1.a &lt; d2.a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmps2</span><span class="params">(Data &amp;d1,Data &amp;d2)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 按照 b 降序</span></span><br><span class="line">    <span class="keyword">return</span> d1.b &gt; d2.b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> *q = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">5</span>]&#123;<span class="number">3</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">9</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="built_in">sort</span>(q,q + <span class="number">5</span>,cmp2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">5</span> ; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,q[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Data</span> *qd = <span class="keyword">new</span> <span class="keyword">struct</span> Data[<span class="number">4</span>]&#123;&#123;<span class="number">4</span>,<span class="number">7</span>&#125;,&#123;<span class="number">3</span>,<span class="number">1</span>&#125;,&#123;<span class="number">8</span>,<span class="number">6</span>&#125;,&#123;<span class="number">2</span>,<span class="number">5</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(qd,qd + <span class="number">4</span>, cmps2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">4</span> ; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,qd[i].a,qd[i].b);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="2"><li>lambda 就是在sort里面直接定义函数 把过程简化</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 升序 </span></span><br><span class="line"><span class="built_in">sort</span>(q,q + <span class="number">5</span>,[&amp;](<span class="type">int</span> a,<span class="type">int</span> b) -&gt; <span class="type">bool</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a &lt; b;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结构体排序</span></span><br><span class="line"><span class="comment">// 按a升序</span></span><br><span class="line"><span class="built_in">sort</span>(qd,qd + <span class="number">4</span>, [&amp;](Data &amp;d1,Data &amp;d2)-&gt;<span class="type">bool</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> d1.a &lt; d2.a;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 按b降序</span></span><br><span class="line"><span class="built_in">sort</span>(qd,qd + <span class="number">4</span>,[&amp;](Data &amp;d1,Data &amp;d2)-&gt;<span class="type">bool</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> d1.b &gt; d2.b;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// vector 排序 以二维为例子</span></span><br><span class="line"><span class="comment">// 贪心题 如合并区间中 常用</span></span><br><span class="line"><span class="built_in">sort</span>(q.<span class="built_in">begin</span>(),q.<span class="built_in">end</span>(),[&amp;](vector&lt;<span class="type">int</span>&gt; &amp;a,vector&lt;<span class="type">int</span>&gt; &amp;b)-&gt;<span class="type">bool</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a[<span class="number">0</span>] &lt; b[<span class="number">0</span>];</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode137只出现一次的数字Ⅱ</title>
      <link href="/2023/10/15/leetcode/leetcode137%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97%E2%85%A1/"/>
      <url>/2023/10/15/leetcode/leetcode137%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97%E2%85%A1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>原题链接:<br><a href="https://leetcode.cn/problems/single-number-ii/description">https://leetcode.cn/problems/single-number-ii/description</a></p><p>要求线性时间复杂度 常数级空间</p><h2><span id="解法1-哈希">解法1: 哈希</span></h2><p>可以通过但不符合常数级空间</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">singleNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 数字 -&gt; 出现次数</span></span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;hash;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp; e : nums)&#123;</span><br><span class="line">            hash[e]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it = hash.<span class="built_in">begin</span>() ; it != hash.<span class="built_in">end</span>() ; it++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(it-&gt;second == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> it-&gt;first;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2><span id="解法2-位数统计位运算">解法2: 位数统计(位运算)</span></h2><p>位数统计</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    位数统计 </span></span><br><span class="line"><span class="comment">    使用一个长度为32 的数组cnt[] 记录下所有数值的每一位共出现了多少次1</span></span><br><span class="line"><span class="comment">    再对cnt[] 数组的每一位进行mod 3操作 重新拼凑出只出现一次的的数值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">singleNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;<span class="built_in">cnt</span>(<span class="number">32</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp; x : nums)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">31</span> ; i &gt;= <span class="number">0</span> ; i--)&#123;</span><br><span class="line">                cnt[i] += (x &gt;&gt; i) &amp; <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">32</span> ; i++)&#123;</span><br><span class="line">            ans += (cnt[i] % <span class="number">3</span>) &lt;&lt; i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2><span id="解法3-有限状态自动机">解法3: 有限状态自动机</span></h2><p>这个题状态表示后 还要结合数电的知识对状态转移化简 个人认为不是一个好的方法 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    有限状态自动机:</span></span><br><span class="line"><span class="comment">    对于所有数字中的某二进制位1的个数 存在3种状态 即对3余数位0,1,2</span></span><br><span class="line"><span class="comment">    用00 表示余数为0的状态 01表示余数为1的状 10表示余数为2的状态</span></span><br><span class="line"><span class="comment">    通过卡诺图化简可得状态转移图</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">singleNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ones = <span class="number">0</span>, twos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num : nums)&#123;</span><br><span class="line">            ones = ones ^ num &amp; ~twos;</span><br><span class="line">            twos = twos ^ num &amp; ~ones;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ones;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM_2字节码文件详解</title>
      <link href="/2023/10/14/interview/JVM_2%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"/>
      <url>/2023/10/14/interview/JVM_2%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2><span id="java虚拟机的组成">Java虚拟机的组成</span></h2><img src="/2023/10/14/interview/JVM_2%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/img1.png" style="zoom:100%"><h2><span id="字节码文件的组成">字节码文件的组成</span></h2><img src="/2023/10/14/interview/JVM_2%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/img2.png" style="zoom:100%"><ol start="2"><li>常量池:<ol><li>常量池的作用: 避免相同的内容重复定义，节省空间</li><li>常量池中的数据都有一个编号 编号从1开始 在字段或者字节码指令中通过编号可以快速的找到对应的数据</li><li>字节码指令中通过编号引用到常量池的过程称之为<strong>符号引用</strong></li></ol></li><li>方法<ol><li>字节码中的方法区域是存放<strong>字节码指令</strong>的核心位置，字节码指令的内容存放在方法的Code属性中</li><li>操作数栈是临时存放数据的地方，局部变量表是存放方法中的局部变量的位置</li><li>举例: <img src="/2023/10/14/interview/JVM_2%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/img3.png" style="zoom:100%"></li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> interview </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM_1初识</title>
      <link href="/2023/10/14/interview/JVM_1%E5%88%9D%E8%AF%86/"/>
      <url>/2023/10/14/interview/JVM_1%E5%88%9D%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>JVM是运行Java字节码</strong>的虚拟机 JVM有针对不同的系统的特定实现 <strong>目的是使用相同的字节码 它们都会给出相同结果</strong></p><p>字节码: 扩展名为 .class 的代码</p><img src="/2023/10/14/interview/JVM_1%E5%88%9D%E8%AF%86/img4.png" style="zoom:100%"><p>在.class-&gt;机器码 这一步 JVM类加载器先加载字节码 然后通过解释器逐行解释执行 -&gt; 这种方式执行速度较慢<br>而后引入JIT 运行时编译 -&gt; 当JIT编译器完成第一次编译后 其会将字节码对应的机器码保存下来下一次可以直接使用(机器码运行效率 高于 Java解释器)</p><ol><li>什么是JVM<br>JVM 全称 Java Virtual Machine 中文译名Java虚拟机<img src="/2023/10/14/interview/JVM_1%E5%88%9D%E8%AF%86/img1.png" style="zoom:100%"></li><li>JVM功能<img src="/2023/10/14/interview/JVM_1%E5%88%9D%E8%AF%86/img2.png" style="zoom:100%"></li></ol><img src="/2023/10/14/interview/JVM_1%E5%88%9D%E8%AF%86/img3.png" style="zoom:100%">]]></content>
      
      
      <categories>
          
          <category> interview </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode136只出现一次的数字</title>
      <link href="/2023/10/14/leetcode/leetcode136%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/"/>
      <url>/2023/10/14/leetcode/leetcode136%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>原题链接:<br><a href="https://leetcode.cn/problems/single-number/">https://leetcode.cn/problems/single-number/</a></p><h2><span id="解法1">解法1:</span></h2><p>异或运算</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    异或运算的性质： 相同数异或运算为0 由于只有一个出现一次的数 所以异或后只出现一次的数就是剩下的数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">singleNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i &lt; nums.<span class="built_in">size</span>() - <span class="number">1</span>; i++)&#123;</span><br><span class="line">            nums[i + <span class="number">1</span>] = nums[i] ^ nums[i + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> nums[nums.<span class="built_in">size</span>() - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 异或运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java泛型</title>
      <link href="/2023/10/13/interview/java%E6%B3%9B%E5%9E%8B/"/>
      <url>/2023/10/13/interview/java%E6%B3%9B%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ol><li><p>泛型概述</p><ol><li>泛型: 是JDK5中引入的特性，可以在编译阶段约束操作的数据类型，并进行检查</li><li>泛型的格式：&lt;数据类型&gt;</li><li>注意：泛型只能支持引用数据类型</li></ol></li><li><p>泛型的好处:</p><ol><li>统一数据类型</li><li>把运行时期的问题提前到了编译期间，避免了强制类型转换可能出现的异常，因为在编译阶段类型就能确定下来。</li><li>扩展知识点：Java中的泛型是伪泛型 <img src="/2023/10/13/interview/java%E6%B3%9B%E5%9E%8B/img1.png" style="zoom:100%"></li></ol></li><li><p>泛型的细节</p><ol><li>泛型中不能写<strong>基本数据类型</strong><ol><li>因为基本数据类型在集合中没有办法转换为Object类 只有写包装类才能转成Object</li></ol></li><li>指定泛型的具体类型后，传递数据时，可以传入该类类型或者其子类类型<ol><li>但大多数是要求 传入类型与泛型类型一致</li></ol></li><li>如果不写泛型，类型默认Object</li></ol></li><li><p>泛型可以在很多地方可以定义</p><img src="/2023/10/13/interview/java%E6%B3%9B%E5%9E%8B/img2.png" style="zoom:100%"> 1. 泛型方法     <img src="/2023/10/13/interview/java%E6%B3%9B%E5%9E%8B/img3.png" style="zoom:100%"> 代码示例: <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListUtil</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">ListUtil</span><span class="params">()</span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类中定义一个静态方法addAll 用来添加多个集合的元素</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// E也可以加在类后面</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 参数1: 集合</span></span><br><span class="line"><span class="comment">     * 参数2: 最后要添加的元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;E&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="keyword">void</span> <span class="title function_">addAll</span><span class="params">(ArrayList&lt;E&gt; list,E e1,E e2,E e3)</span>&#123;</span><br><span class="line">        list.add(e1);</span><br><span class="line">        list.add(e2);</span><br><span class="line">        list.add(e3);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// E..e 可变参数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="keyword">void</span> <span class="title function_">addAll</span><span class="params">(ArrayList&lt;E&gt; list,E...e)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(E element : e)&#123;</span><br><span class="line">            list.add(element);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 测试方法:</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义一个工具类: ListUtil</span></span><br><span class="line"><span class="comment"> * 类中定义一个静态方法addAll 用来添加多个集合的元素</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericsDemo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;String&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        ListUtil.addAll(list1,<span class="string">&quot;aaa&quot;</span>,<span class="string">&quot;bbb&quot;</span>,<span class="string">&quot;ccc&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(list1);</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;Integer&gt; list2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        ListUtil.addAll(list2,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">        System.out.println(list2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>泛型接口 <img src="/2023/10/13/interview/java%E6%B3%9B%E5%9E%8B/img4.png" style="zoom:100%"></li></ol></li><li><p>泛型的继承和通配符</p><ol><li>泛型不具备继承性 但是数据具备继承性</li></ol></li></ol><p>代码示例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.time.ZonedDateTime;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericsDemo3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 泛型不具备继承性 但是数据具备继承性</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 创建集合的对象</span></span><br><span class="line">        method(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Ye&gt;());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 下面两条会报错  泛型不具备继承性</span></span><br><span class="line">        <span class="comment">//method(new ArrayList&lt;Fu&gt;());</span></span><br><span class="line">        <span class="comment">//method(new ArrayList&lt;Zi&gt;())</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        method3(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Fu&gt;());</span><br><span class="line">        method3(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Zi&gt;());</span><br><span class="line">        <span class="comment">// 下面会报错 因为Student并不继承Ye</span></span><br><span class="line">        <span class="comment">// method3(new ArrayList&lt;Student&gt;());</span></span><br><span class="line"></span><br><span class="line">        method4(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Fu&gt;());</span><br><span class="line">        <span class="comment">// 下面会报错 Zi并非Fu的父类</span></span><br><span class="line">        <span class="comment">//method4(new ArrayList&lt;Zi&gt;());</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(ArrayList&lt;Ye&gt; list)</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 此时泛型里面写的是什么类型 那么就只能传递什么类型的数据 (method2)</span></span><br><span class="line"><span class="comment">     * 弊端:</span></span><br><span class="line"><span class="comment">     *  利用泛型方法有一个 此时他可以接受任意的数据类型 (Ye Fu Zi Student)</span></span><br><span class="line"><span class="comment">     * 希望:</span></span><br><span class="line"><span class="comment">     *  本方法虽然不确定类型 但是以后希望只能传递(Ye Fu Zi)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *  此时我们就可以使用泛型的通配符:  (method3)</span></span><br><span class="line"><span class="comment">     *      ? 也表示不确定的类型</span></span><br><span class="line"><span class="comment">     *      他可以进行类型的限定</span></span><br><span class="line"><span class="comment">     *      ? extends E: 表示可以传递E或者E所有的子类类型</span></span><br><span class="line"><span class="comment">     *      ? super E: 表示可以传递E或者E所有的父类类型</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *  应用场景:</span></span><br><span class="line"><span class="comment">     *      1. 如果我们在定义类、方法、接口的时候，如果类型不确定，就可以泛型类、泛型方法、泛型接口</span></span><br><span class="line"><span class="comment">     *      2. 如果类型不确定，但是能知道以后只能传递某个继承体系中 就可以使用泛型的通配符</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *  泛型的通配符:</span></span><br><span class="line"><span class="comment">     *      关键点: 可以限定类型的范围</span></span><br><span class="line"><span class="comment">     *      </span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">(ArrayList&lt;E&gt; list)</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以传递任意类型但一定要是 Ye 或是 Ye的子类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method3</span><span class="params">(ArrayList&lt;? extends Ye&gt; list)</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以传递任意类型 但一定要是 Fu 或者是 Fu的父类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method4</span><span class="params">(ArrayList&lt;? <span class="built_in">super</span> Fu&gt; list)</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Ye</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Fu</span> <span class="keyword">extends</span> <span class="title class_">Ye</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Zi</span> <span class="keyword">extends</span> <span class="title class_">Fu</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="6"><li>笔记总结<img src="/2023/10/13/interview/java%E6%B3%9B%E5%9E%8B/img5.png" style="zoom:100%"><img src="/2023/10/13/interview/java%E6%B3%9B%E5%9E%8B/img6.png" style="zoom:100%"></li></ol>]]></content>
      
      
      <categories>
          
          <category> interview </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java泛型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode1488避免洪水泛滥</title>
      <link href="/2023/10/13/leetcode/leetcode1488%E9%81%BF%E5%85%8D%E6%B4%AA%E6%B0%B4%E6%B3%9B%E6%BB%A5/"/>
      <url>/2023/10/13/leetcode/leetcode1488%E9%81%BF%E5%85%8D%E6%B4%AA%E6%B0%B4%E6%B3%9B%E6%BB%A5/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>原题链接:<br><a href="https://leetcode.cn/problems/avoid-flood-in-the-city/description">https://leetcode.cn/problems/avoid-flood-in-the-city/description</a></p><h2><span id="解法1-贪心-二分">解法1： 贪心 + 二分</span></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    贪心 + 二分</span></span><br><span class="line"><span class="comment">    晴天日期全部记录到set&lt;int&gt; zero</span></span><br><span class="line"><span class="comment">    hash 记录每个湖泊上一次下雨的日期 (这里注意是只用记录上一次下雨的日期即可 操作的时候按顺序遍历 如果多于一次无法制止那么直接返回&#123;&#125; 即可)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">avoidFlood</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; rains)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 记录上一次降水的日期</span></span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;water;</span><br><span class="line">        <span class="comment">// 记录晴天</span></span><br><span class="line">        set&lt;<span class="type">int</span>&gt;zero;</span><br><span class="line">        </span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;<span class="built_in">ans</span>(rains.<span class="built_in">size</span>(),<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i &lt; rains.<span class="built_in">size</span>() ; i++)&#123;</span><br><span class="line">            <span class="comment">// 当天将要降水的湖泊</span></span><br><span class="line">            <span class="type">int</span> r = rains[i];</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 晴天 -&gt; 不降水</span></span><br><span class="line">            <span class="keyword">if</span>(r == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">// 记录当前晴天日期</span></span><br><span class="line">                zero.<span class="built_in">insert</span>(i);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 雨天</span></span><br><span class="line">            <span class="comment">// 如果该湖泊之前降过水 则需要进行排水处理 否则会引发洪水 </span></span><br><span class="line">            <span class="keyword">if</span>(water.<span class="built_in">count</span>(r) != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">// 上一次降水的时间</span></span><br><span class="line">                <span class="type">int</span> pre = water[r];</span><br><span class="line">                <span class="comment">// 通过二分 在之前出现过的晴天 看是否有出现在pre之后的晴天</span></span><br><span class="line">                <span class="keyword">auto</span> it = zero.<span class="built_in">lower_bound</span>(pre);</span><br><span class="line">                <span class="comment">// 没找到 那么只能是洪水</span></span><br><span class="line">                <span class="keyword">if</span>(it == zero.<span class="built_in">end</span>())&#123;</span><br><span class="line">                    <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 在找到的第一天晴天 处理当前湖泊</span></span><br><span class="line">                ans[*it] = r;</span><br><span class="line">                <span class="comment">// 删除当前处理湖泊</span></span><br><span class="line">                zero.<span class="built_in">erase</span>(it);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 记录该湖泊上一次降水的时间</span></span><br><span class="line">            water[r] = i;</span><br><span class="line">            <span class="comment">// 当前天降水 不做任何操作记为-1</span></span><br><span class="line">            ans[i] = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algo </category>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分 </tag>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java内部类</title>
      <link href="/2023/10/12/interview/java%E5%86%85%E9%83%A8%E7%B1%BB/"/>
      <url>/2023/10/12/interview/java%E5%86%85%E9%83%A8%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>参考视频:<br><a href="https://www.bilibili.com/video/BV1Cv411372m?p=111&amp;vd_source=c0cc92a482393bb63596629a72e3fc71">https://www.bilibili.com/video/BV1Cv411372m?p=111&amp;vd_source=c0cc92a482393bb63596629a72e3fc71</a></p><ol><li><p>什么是内部类</p><img src="/2023/10/12/interview/java%E5%86%85%E9%83%A8%E7%B1%BB/img1.png" style="zoom:100%"></li><li><p>内部类四种形式:</p><ol><li>成员内部类</li><li>静态内部类</li><li>局部内部类</li><li><strong>匿名内部类</strong></li></ol></li><li><p>成员内部类</p><img src="/2023/10/12/interview/java%E5%86%85%E9%83%A8%E7%B1%BB/img2.png" style="zoom:100%"></li></ol><p>代码示例: 成员内部类的定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//外部类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">99</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String a;</span><br><span class="line">    <span class="comment">// 成员内部类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Inner</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">88</span>;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> String schoolName; <span class="comment">//JDK16版本以后支持定义静态成员</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 成员内部类 相当于类内的方法 可以访问外部类中的实例和静态变量</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">            System.out.println(age);</span><br><span class="line">            System.out.println(a);</span><br><span class="line">            <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">66</span>;</span><br><span class="line">            System.out.println(age); <span class="comment">// 66</span></span><br><span class="line">            System.out.println(<span class="built_in">this</span>.age); <span class="comment">// 88</span></span><br><span class="line">            System.out.println(Outer.<span class="built_in">this</span>.age); <span class="comment">// 99</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getSchoolName</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> schoolName;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setSchoolName</span><span class="params">(String schoolName)</span> &#123;</span><br><span class="line">            Inner.schoolName = schoolName;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>测试代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 要先创建外部类对象才能创建内部类对象</span></span><br><span class="line">        <span class="comment">// 内部类对象依赖于外部类</span></span><br><span class="line">        Outer.<span class="type">Inner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>().<span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">        in.getName();</span><br><span class="line">        in.setName(<span class="string">&quot;xxx&quot;</span>);</span><br><span class="line">        in.test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>笔记总结:<br><img src="/2023/10/12/interview/java%E5%86%85%E9%83%A8%E7%B1%BB/img3.png" style="zoom:100%"></p><ol start="4"><li>静态内部类<img src="/2023/10/12/interview/java%E5%86%85%E9%83%A8%E7%B1%BB/img4.png" style="zoom:100%"></li></ol><p>代码示例: 静态内部类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer2</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String schoolName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态内部类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Inner</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> a;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">            System.out.println(schoolName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">            System.out.println(schoolName);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 无法直接访问外部的实例对象</span></span><br><span class="line">            <span class="comment">//System.out.println(age);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>测试代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 直接创建即可 无需通过外部类</span></span><br><span class="line">        Outer2.<span class="type">Inner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer2</span>.Inner();</span><br><span class="line">        in.test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>笔记总结:<br><img src="/2023/10/12/interview/java%E5%86%85%E9%83%A8%E7%B1%BB/img5.png" style="zoom:100%"></p><p>5.局部内部类<br>了解即可</p><ol start="6"><li><strong>匿名内部类</strong><img src="/2023/10/12/interview/java%E5%86%85%E9%83%A8%E7%B1%BB/img6.png" style="zoom:100%"></li></ol><p>匿名内部类在开发中的使用场景:<br>通常作为一个参数传输给方法<br>代码示例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 把这个匿名内部类编译成一个子类 然后会立即创建一个子类对象出来</span></span><br><span class="line">        <span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Animal</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cry</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;mmm&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 匿名内部类的常见使用场景</span></span><br><span class="line">        go(<span class="keyword">new</span> <span class="title class_">Swimming</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;狗游的快&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设计一个方法 可以接受swimming接口的一切实现类对象进来参加游泳比赛</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">go</span><span class="params">(Swimming s)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;开始-------&quot;</span>);</span><br><span class="line">        s.swim();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Swimming</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">cry</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>笔记总结<br><img src="/2023/10/12/interview/java%E5%86%85%E9%83%A8%E7%B1%BB/img7.png" style="zoom:100%"></p>]]></content>
      
      
      <categories>
          
          <category> interview </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java内部类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcodeLCR041数据流中的移动平均值</title>
      <link href="/2023/10/11/leetcode/leetcodeLCR041%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E7%A7%BB%E5%8A%A8%E5%B9%B3%E5%9D%87%E5%80%BC/"/>
      <url>/2023/10/11/leetcode/leetcodeLCR041%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E7%A7%BB%E5%8A%A8%E5%B9%B3%E5%9D%87%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>原题链接:<br><a href="https://leetcode.cn/problems/qIsx9U/">https://leetcode.cn/problems/qIsx9U/</a></p><h2><span id="解法1">解法1:</span></h2><p>队列 按照题意模拟即可</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MovingAverage</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt;q;</span><br><span class="line">    <span class="type">int</span> s;</span><br><span class="line">    <span class="type">double</span> cur = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="built_in">MovingAverage</span>(<span class="type">int</span> size) &#123;</span><br><span class="line">        s = size;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">next</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        q.<span class="built_in">push</span>(val);</span><br><span class="line">        cur += val;</span><br><span class="line">        <span class="keyword">if</span>(q.<span class="built_in">size</span>() &gt; s)&#123;</span><br><span class="line">            cur -= q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cur / q.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MovingAverage object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MovingAverage* obj = new MovingAverage(size);</span></span><br><span class="line"><span class="comment"> * double param_1 = obj-&gt;next(val);</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模拟 </tag>
            
            <tag> 队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode2512将最顶尖的k名学生</title>
      <link href="/2023/10/11/leetcode/leetcode2512%E5%A5%96%E5%8A%B1%E6%9C%80%E9%A1%B6%E5%B0%96%E7%9A%84k%E5%90%8D%E5%AD%A6%E7%94%9F/"/>
      <url>/2023/10/11/leetcode/leetcode2512%E5%A5%96%E5%8A%B1%E6%9C%80%E9%A1%B6%E5%B0%96%E7%9A%84k%E5%90%8D%E5%AD%A6%E7%94%9F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>原题链接:<br><a href="https://leetcode.cn/problems/reward-top-k-students/">https://leetcode.cn/problems/reward-top-k-students/</a></p><p>比较适合用于练习 语言基础语法的一道题</p><h2><span id="解法1">解法1:</span></h2><p>模拟</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    模拟</span></span><br><span class="line"><span class="comment">    哈希表记录feed_back的分数 然后遍历report直接计算分数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">topStudents</span><span class="params">(vector&lt;string&gt;&amp; positive_feedback, vector&lt;string&gt;&amp; negative_feedback, vector&lt;string&gt;&amp; report, vector&lt;<span class="type">int</span>&gt;&amp; student_id, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;string,<span class="type">int</span>&gt;score;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; positive_feedback.<span class="built_in">size</span>() ; i++ )&#123;</span><br><span class="line">            score[positive_feedback[i]] = <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; negative_feedback.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            score[negative_feedback[i]] = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">       </span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;<span class="built_in">s</span>(report.<span class="built_in">size</span>(),<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i &lt; report.<span class="built_in">size</span>() ; i++)&#123;</span><br><span class="line">            <span class="type">int</span> m = report[i].<span class="built_in">size</span>();</span><br><span class="line">            <span class="comment">// cout &lt;&lt; report[i] &lt;&lt; endl;</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; m ; )&#123;</span><br><span class="line">                <span class="type">int</span> k = j + <span class="number">1</span>;</span><br><span class="line">            </span><br><span class="line">                <span class="keyword">while</span>(k &lt; m &amp;&amp; report[i][k] != <span class="string">&#x27; &#x27;</span> )&#123;</span><br><span class="line">                    k++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// cout &lt;&lt; report[i].substr(j,k - j) &lt;&lt; endl;</span></span><br><span class="line">                <span class="comment">// c++ unordered_map 不存在键值 直接默认值为0</span></span><br><span class="line">                s[i] += score[report[i].<span class="built_in">substr</span>(j,k - j)];</span><br><span class="line">                j = k + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;<span class="built_in">p</span>(report.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i &lt; report.<span class="built_in">size</span>() ; i++)&#123;</span><br><span class="line">            p[i].first = s[i];</span><br><span class="line">            p[i].second = student_id[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">sort</span>(p.<span class="built_in">begin</span>(),p.<span class="built_in">end</span>(),[&amp;](pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;a,pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;b)-&gt;<span class="type">bool</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(a.first == b.first)&#123;</span><br><span class="line">                <span class="keyword">return</span> a.second &lt; b.second;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> a.first &gt; b.first;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;ans;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i &lt; k ; i++)&#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(p[i].second);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 哈希 </tag>
            
            <tag> 模拟 </tag>
            
            <tag> 语法题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java反射机制</title>
      <link href="/2023/10/10/interview/java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/"/>
      <url>/2023/10/10/interview/java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>参考视频:<br><a href="https://www.bilibili.com/video/BV1ke4y1w7yn/?p=7&amp;spm_id_from=pageDriver&amp;vd_source=c0cc92a482393bb63596629a72e3fc71">https://www.bilibili.com/video/BV1ke4y1w7yn/?p=7&amp;spm_id_from=pageDriver&amp;vd_source=c0cc92a482393bb63596629a72e3fc71</a></p><h2><span id="动态代理">动态代理</span></h2><ol><li>为什么需要代理<br>代理可以无侵入式的给对象增强其他的功能<br>调用者 -&gt; 代理 -&gt; 对象</li><li>代理长什么样？<br>代理里面就是对象要被代理的方法</li><li>Java通过什么来保证代理的样子？<br>通过<strong>接口</strong>保证 后面的对象和代理需要实现同一个接口<br>接口中就是被代理的所有方法</li></ol><p>动态代理的代码实现<br><strong>代理类的实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 类的作用:</span></span><br><span class="line"><span class="comment"> *  创建一个代理</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  需求:</span></span><br><span class="line"><span class="comment"> *  外面的人想要大明星唱一首歌</span></span><br><span class="line"><span class="comment"> *  1. 获取代理对象</span></span><br><span class="line"><span class="comment"> *      代理对象 =  ProxyUtil.createProxy(大明星的对象)</span></span><br><span class="line"><span class="comment"> *  2.再调用代理的唱歌方法</span></span><br><span class="line"><span class="comment"> *      代理对象，唱歌的方法(&quot;xxx&quot;)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyUtil</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法作用: 给一个对象 创建一个代理</span></span><br><span class="line"><span class="comment">     * 形参: 被代理的对象</span></span><br><span class="line"><span class="comment">     * 返回值: 为对象创建的代理</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bigStar</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Star <span class="title function_">createProxy</span><span class="params">(BigStar bigStar)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * java.lang.reflect.Proxy; 创建代理</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">Star</span> <span class="variable">star</span> <span class="operator">=</span> (Star) Proxy.newProxyInstance(</span><br><span class="line">                <span class="comment">// 用于指定类加载器 去加载生成的代理类</span></span><br><span class="line">                ProxyUtil.class.getClassLoader(),</span><br><span class="line">                <span class="comment">// 指定接口 这些接口用于指定生成的代理长什么样 也就是有那些方法</span></span><br><span class="line">                <span class="comment">// 能代理的方法都在接口中</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Star.class&#125;,</span><br><span class="line">                <span class="comment">// 指定生成的代理都要干啥</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvocationHandler</span>() &#123;</span><br><span class="line">                    <span class="comment">/**</span></span><br><span class="line"><span class="comment">                     *</span></span><br><span class="line"><span class="comment">                     * <span class="doctag">@param</span> proxy the proxy instance that the method was invoked on</span></span><br><span class="line"><span class="comment">                     * 代理的对象</span></span><br><span class="line"><span class="comment">                     *</span></span><br><span class="line"><span class="comment">                     * <span class="doctag">@param</span> method the &#123;<span class="doctag">@code</span> Method&#125; instance corresponding to</span></span><br><span class="line"><span class="comment">                     * the interface method invoked on the proxy instance.  The declaring</span></span><br><span class="line"><span class="comment">                     * class of the &#123;<span class="doctag">@code</span> Method&#125; object will be the interface that</span></span><br><span class="line"><span class="comment">                     * the method was declared in, which may be a superinterface of the</span></span><br><span class="line"><span class="comment">                     * proxy interface that the proxy class inherits the method through.</span></span><br><span class="line"><span class="comment">                     * 要运行的方法 例如: sing</span></span><br><span class="line"><span class="comment">                     *</span></span><br><span class="line"><span class="comment">                     * <span class="doctag">@param</span> args an array of objects containing the values of the</span></span><br><span class="line"><span class="comment">                     * arguments passed in the method invocation on the proxy instance,</span></span><br><span class="line"><span class="comment">                     * or &#123;<span class="doctag">@code</span> null&#125; if interface method takes no arguments.</span></span><br><span class="line"><span class="comment">                     * Arguments of primitive types are wrapped in instances of the</span></span><br><span class="line"><span class="comment">                     * appropriate primitive wrapper class, such as</span></span><br><span class="line"><span class="comment">                     * &#123;<span class="doctag">@code</span> java.lang.Integer&#125; or &#123;<span class="doctag">@code</span> java.lang.Boolean&#125;.</span></span><br><span class="line"><span class="comment">                     * 调用方法 传递的实参</span></span><br><span class="line"><span class="comment">                     *</span></span><br><span class="line"><span class="comment">                     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">                     * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                        <span class="keyword">if</span>(<span class="string">&quot;sing&quot;</span>.equals(method.getName()))&#123;</span><br><span class="line">                            System.out.println(<span class="string">&quot;准备话筒 收钱&quot;</span>);</span><br><span class="line">                        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;dance&quot;</span>.equals(method.getName()))&#123;</span><br><span class="line">                            System.out.println(<span class="string">&quot;准备场地 收钱&quot;</span>);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 去找大明星开始唱歌或跳舞</span></span><br><span class="line">                        <span class="comment">// 代码的表现形式 调用大明星里面的唱歌或者跳舞的方法</span></span><br><span class="line">                        <span class="keyword">return</span> method.invoke(bigStar,args);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>  star;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>测试代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 需求:</span></span><br><span class="line"><span class="comment">     *   外面的人想要大明星唱一首歌</span></span><br><span class="line"><span class="comment">     *   1. 获取代理对象</span></span><br><span class="line"><span class="comment">     *       代理对象 =  ProxyUtil.createProxy(大明星的对象)</span></span><br><span class="line"><span class="comment">     *   2.再调用代理的唱歌方法</span></span><br><span class="line"><span class="comment">     *       代理对象，唱歌的方法(&quot;xxx&quot;)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">BigStar</span> <span class="variable">bigStar</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigStar</span>(<span class="string">&quot;鸡哥&quot;</span>);</span><br><span class="line">        <span class="type">Star</span> <span class="variable">proxy</span> <span class="operator">=</span> ProxyUtil.createProxy(bigStar);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> proxy.sing(<span class="string">&quot;及你太美&quot;</span>);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2><span id="反射">反射</span></h2><p><strong>反射允许对封装类的字段 方法和构造函数的信息进行便编程访问</strong><br><img src="/2023/10/10/interview/java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/img1.png" style="zoom:100%"></p><h3><span id="获取class对象的三种方式">获取class对象的三种方式</span></h3><img src="/2023/10/10/interview/java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/img2.png" style="zoom:100%"><p>三种方式的代码示例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyReflectDemo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 获取class对象的三种方式</span></span><br><span class="line"><span class="comment">         * 1. Class.forName(&quot;全类名&quot;)</span></span><br><span class="line"><span class="comment">         * 2. 类名.class</span></span><br><span class="line"><span class="comment">         * 3. 对象.getClass();</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 第一种方式</span></span><br><span class="line">        <span class="comment">// 全类名: 包名 + 类名</span></span><br><span class="line">        <span class="comment">// 最为常用</span></span><br><span class="line">        Class&lt;?&gt; clazz1 = Class.forName(<span class="string">&quot;Student&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 第二种方式</span></span><br><span class="line">        <span class="comment">// 一般更多当作参数进行传递</span></span><br><span class="line">        Class&lt;Student&gt; clazz2 = Student.class;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 第三种方式</span></span><br><span class="line">        <span class="comment">// 当我们已经有了这个类的对象时 才可以使用</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        Class&lt;? <span class="keyword">extends</span> <span class="title class_">Student</span>&gt; clazz3 = s.getClass();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出均为true 证明三种方式获取的字节码文件是一样的</span></span><br><span class="line">        System.out.println(clazz1 == clazz2);</span><br><span class="line">        System.out.println(clazz1 == clazz3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3><span id="利用反射获取构造方法">利用反射获取构造方法</span></h3><img src="/2023/10/10/interview/java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/img3.png" style="zoom:100%"><p>代码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Parameter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyReflectDemo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException &#123;</span><br><span class="line">        <span class="comment">// 1. 获取class字节码文件对象</span></span><br><span class="line">        Class&lt;?&gt; clazz1 = Class.forName(<span class="string">&quot;Student2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 获取构造方法</span></span><br><span class="line">        <span class="comment">// 获取所有公共构造</span></span><br><span class="line">        Constructor&lt;?&gt;[] cons = clazz1.getConstructors();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> con: cons)&#123;</span><br><span class="line">            System.out.println(con);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取所有构造 包括私有 保护</span></span><br><span class="line">        Constructor&lt;?&gt;[] cons2 = clazz1.getDeclaredConstructors();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> con: cons2)&#123;</span><br><span class="line">            System.out.println(con);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取单个构造</span></span><br><span class="line">        Constructor&lt;?&gt; con1 = clazz1.getDeclaredConstructor(String.class);</span><br><span class="line">        System.out.println(con1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取多个构造</span></span><br><span class="line">        Constructor&lt;?&gt; con2 = clazz1.getDeclaredConstructor(String.class, <span class="type">int</span>.class);</span><br><span class="line">        <span class="comment">// 获取构造方法的权限修饰符</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">modifiers</span> <span class="operator">=</span> con2.getModifiers();</span><br><span class="line">        System.out.println(modifiers);</span><br><span class="line"></span><br><span class="line">        Parameter[] parameters = con2.getParameters();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> parameter: parameters)&#123;</span><br><span class="line">            System.out.println(parameter);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 暴力反射: 表示临时取消权限校验 可以获取私有对象</span></span><br><span class="line">        con2.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">// 使用构造创建对象</span></span><br><span class="line">        <span class="type">Student2</span> <span class="variable">stu</span> <span class="operator">=</span> (Student2) con2.newInstance(<span class="string">&quot;xx&quot;</span>, <span class="number">22</span>);</span><br><span class="line">        System.out.println(stu.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3><span id="利用反射获取成员变量">利用反射获取成员变量</span></h3><img src="/2023/10/10/interview/java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/img4.png" style="zoom:100%"><p>代码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyReflectDemo3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchFieldException, IllegalAccessException &#123;</span><br><span class="line">        Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;Student3&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取单个的成员变量</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">name</span> <span class="operator">=</span> clazz.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        System.out.println(name);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取权限修饰符</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">modifiers</span> <span class="operator">=</span> name.getModifiers();</span><br><span class="line">        System.out.println(modifiers);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取成员变量的名字</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">n</span> <span class="operator">=</span> name.getName();</span><br><span class="line">        System.out.println(n);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取成员变量的数据类型</span></span><br><span class="line">        Class&lt;?&gt; type = name.getType();</span><br><span class="line">        System.out.println(type);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取成员变量记录的值</span></span><br><span class="line">        <span class="type">Student3</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student3</span>(<span class="string">&quot;xx&quot;</span>,<span class="number">22</span>,<span class="number">1</span>);</span><br><span class="line">        name.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> name.get(s);</span><br><span class="line">        System.out.println(value);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 修改对象里面记录的值</span></span><br><span class="line">        name.set(s,<span class="string">&quot;yy&quot;</span>);</span><br><span class="line">        value = name.get(s);</span><br><span class="line">        System.out.println(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3><span id="利用反射获取成员方法">利用反射获取成员方法</span></h3><img src="/2023/10/10/interview/java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/img5.png" style="zoom:100%">]]></content>
      
      
      <categories>
          
          <category> interview </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java反射 </tag>
            
            <tag> 动态代理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode714买卖股票的最佳时机含手续费</title>
      <link href="/2023/10/10/leetcode/leetcode714%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E5%90%AB%E6%89%8B%E7%BB%AD%E8%B4%B9/"/>
      <url>/2023/10/10/leetcode/leetcode714%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E5%90%AB%E6%89%8B%E7%BB%AD%E8%B4%B9/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>原题链接:<br><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee">https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee</a></p><h2><span id="解法1">解法1:</span></h2><p>状态机模型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    相当于在之前状态转移的基础上 除了处理prices[i] 还要多一个处理手续费的过程</span></span><br><span class="line"><span class="comment">    统一将手续费的花销 放在买入的这个过程处理 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices, <span class="type">int</span> fee)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> prices.length;</span><br><span class="line">        <span class="comment">// 前i天 持股状态为j时 可获得的最大现金</span></span><br><span class="line">        <span class="comment">// j = 0 不持股 j = 1持股</span></span><br><span class="line">        <span class="type">int</span> [][] f = <span class="keyword">new</span> <span class="title class_">int</span>[n][<span class="number">2</span>];    </span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>] - fee;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span> ; i &lt; n ; i++)&#123;</span><br><span class="line">            f[i][<span class="number">0</span>] = Math.max(f[i - <span class="number">1</span>][<span class="number">0</span>],f[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">            f[i][<span class="number">1</span>] = Math.max(f[i - <span class="number">1</span>][<span class="number">1</span>],f[i - <span class="number">1</span>][<span class="number">0</span>] - prices[i] - fee);     </span><br><span class="line">        &#125;   </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> f[n - <span class="number">1</span>][<span class="number">0</span>];   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 状态机模型 </tag>
            
            <tag> 股票问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode2731移动机器人</title>
      <link href="/2023/10/10/leetcode/leetcode2731%E7%A7%BB%E5%8A%A8%E6%9C%BA%E5%99%A8%E4%BA%BA/"/>
      <url>/2023/10/10/leetcode/leetcode2731%E7%A7%BB%E5%8A%A8%E6%9C%BA%E5%99%A8%E4%BA%BA/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>原题链接:<br><a href="https://leetcode.cn/problems/movement-of-robots">https://leetcode.cn/problems/movement-of-robots</a></p><h2><span id="解法1">解法1:</span></h2><p>脑筋急转弯 + 排序统计<br>还要注意一下溢出问题 算是这题比较坑的地方</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    1. 题目要求的是机器人之间的距离 与顺序无关 -&gt; 那么把机器人位置交换 并不会对答案产生影响 </span></span><br><span class="line"><span class="comment">    2. 相撞可视为互相穿过对方 -&gt; 可以无视相撞规则 把每个机器人堪称独立运动 </span></span><br><span class="line"><span class="comment">    3. 由于要计算的是每一对机器人之间的距离 所以先对运动后的机器人位置进行排序</span></span><br><span class="line"><span class="comment">       从小到大 枚举 对于第i个数 a[i] 其与前i个数的距离为</span></span><br><span class="line"><span class="comment">       (a[i] - a[i - 1]) + (a[i] - a[i - 2]) + ... + (a[i] - a[0]) </span></span><br><span class="line"><span class="comment">       = i * a[i] - (a[i - 1] + a[i - 2] + ... + a[0]) </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">MOD</span> <span class="operator">=</span> (<span class="type">long</span>)(<span class="number">1e9</span> + <span class="number">7</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumDistance</span><span class="params">(<span class="type">int</span>[] nums, String s, <span class="type">int</span> d)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="comment">// 数组也要建一个新的 因为 nums[i] + d可能溢出</span></span><br><span class="line">        <span class="type">long</span> [] a = <span class="keyword">new</span> <span class="title class_">long</span> [n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span>  <span class="operator">=</span> <span class="number">0</span> ; i &lt; n ; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i) == <span class="string">&#x27;L&#x27;</span>)&#123;</span><br><span class="line">                a[i] = nums[i] - d;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                a[i] = nums[i] + d;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        Arrays.sort(a);</span><br><span class="line">        <span class="comment">// 记录前i个数之和</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">pre</span> <span class="operator">=</span> a[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span> ; i &lt; n ; i++)&#123;</span><br><span class="line">            <span class="comment">// 计算的是 两两之间的距离 所以每一对机器人之间的距离都要计算过一次</span></span><br><span class="line">            <span class="comment">// 要乘一个i</span></span><br><span class="line">            ans =  (ans + i * a[i] - pre) % MOD;</span><br><span class="line">            pre = (pre + a[i]) % MOD;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>)ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 脑筋急转弯 </tag>
            
            <tag> 排序统计 </tag>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode309买卖股票的最佳时机含冷冻期</title>
      <link href="/2023/10/10/leetcode/leetcode309%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E5%90%AB%E5%86%B7%E5%86%BB%E6%9C%9F/"/>
      <url>/2023/10/10/leetcode/leetcode309%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E5%90%AB%E5%86%B7%E5%86%BB%E6%9C%9F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>原题链接:<br><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown">https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown</a></p><h2><span id="解法1">解法1:</span></h2><p>动态规划</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    状态机模型</span></span><br><span class="line"><span class="comment">    与传统股票问题一样 总体上来看也是持股、不持股两个状态</span></span><br><span class="line"><span class="comment">    由于存在冷冻期 </span></span><br><span class="line"><span class="comment">    将不持股这个状态再拆分为 不进行操作的不持股状态 和 卖了股票后因冷冻期而不能操作的不持股状态</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    f[i][j] 表示前i天 持股状态为j时  可获得的最大现金</span></span><br><span class="line"><span class="comment">    f[i][0] 没有操作而不持股票 </span></span><br><span class="line"><span class="comment">    f[i][1] 持股</span></span><br><span class="line"><span class="comment">    f[i][2] 卖出股票后处于冷静期而不能持股</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> prices.length;</span><br><span class="line">        <span class="type">int</span> [][] f = <span class="keyword">new</span> <span class="title class_">int</span> [n][<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始值</span></span><br><span class="line">        <span class="comment">// 初始无操作 现金为0 </span></span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 初始持股 </span></span><br><span class="line">        f[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">/// 初始卖出股票处于冷静期</span></span><br><span class="line">        f[<span class="number">0</span>][<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span> ;i &lt; n ; i++)&#123;</span><br><span class="line">            <span class="comment">// 不操作状态可以由 本身就不操作 或者 冷静期转移而来</span></span><br><span class="line">            f[i][<span class="number">0</span>] = Math.max(f[i - <span class="number">1</span>][<span class="number">0</span>],f[i - <span class="number">1</span>][<span class="number">2</span>]); </span><br><span class="line">            <span class="comment">// 不操作 或者 买入</span></span><br><span class="line">            f[i][<span class="number">1</span>] = Math.max(f[i - <span class="number">1</span>][<span class="number">1</span>],f[i - <span class="number">1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">            <span class="comment">// 只能由 f[i][1] 转移而来</span></span><br><span class="line">            f[i][<span class="number">2</span>] = Math.max(f[i - <span class="number">1</span>][<span class="number">2</span>],f[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不持股 现金才是最大的</span></span><br><span class="line">        <span class="keyword">return</span>  Math.max(f[n - <span class="number">1</span>][<span class="number">0</span>],f[n - <span class="number">1</span>][<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 状态机模型 </tag>
            
            <tag> 股票问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode124买卖股票的最佳时机Ⅳ</title>
      <link href="/2023/10/09/leetcode/leetcode124%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E2%85%A3/"/>
      <url>/2023/10/09/leetcode/leetcode124%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E2%85%A3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>原题链接:<br><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv">https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv</a></p><h2><span id="解法1">解法1:</span></h2><p>动态规划<br>承接123题 相当于120-124 这一类股票问题的最通用姐</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    f[i][j] 表示第i天 持有股票状态为k时的最大现金</span></span><br><span class="line"><span class="comment">    f[i][0] 表示不操作</span></span><br><span class="line"><span class="comment">    f[i][k = 奇数] 表示此时为持有状态</span></span><br><span class="line"><span class="comment">    f[i][k = 偶数] 表示此时为不持有状态</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> prices.length;</span><br><span class="line">        <span class="comment">// 这里k次买卖 那么对应的所能有的持有状态未k*2次</span></span><br><span class="line">        k = k * <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> [][] f = <span class="keyword">new</span> <span class="title class_">int</span>[n][k + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 初始值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;=k ; i++)&#123;</span><br><span class="line">            <span class="comment">// 持有状态</span></span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">1</span>)&#123;</span><br><span class="line">                f[<span class="number">0</span>][i] = -prices[<span class="number">0</span>];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                f[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span> ; i &lt; n ; i++)&#123;</span><br><span class="line">            f[i][<span class="number">0</span>] = f[i - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span> ; j &lt;=k ; j++ )&#123;</span><br><span class="line">                <span class="comment">// 为持有状态 那么只能从上一个未持有状态转移而来 即只能买入 或不操作</span></span><br><span class="line">                <span class="keyword">if</span>(j % <span class="number">2</span> == <span class="number">1</span>)&#123;                   </span><br><span class="line">                    f[i][j] = Math.max(f[i - <span class="number">1</span>][j],f[i - <span class="number">1</span>][j - <span class="number">1</span>] - prices[i]);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">// 未不持有状态 那么只能从上一个持有状态转移而来 即只能卖出 或不操作</span></span><br><span class="line">                    f[i][j] = Math.max(f[i - <span class="number">1</span>][j],f[i - <span class="number">1</span>][j - <span class="number">1</span>] + prices[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt;= k ; i += <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="comment">// 卖出的值 才会是最大的</span></span><br><span class="line">            ans = Math.max(ans,f[n - <span class="number">1</span>][i]);    </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 状态机模型 </tag>
            
            <tag> 股票问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode123买卖股票的最佳时机Ⅲ</title>
      <link href="/2023/10/09/leetcode/leetcode123%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E2%85%A2/"/>
      <url>/2023/10/09/leetcode/leetcode123%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E2%85%A2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>原题链接:<br><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii">https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii</a></p><h2><span id="解法1">解法1:</span></h2><p>动态规划</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    f[i][j] 表示第i天 持有股票状态为j的 所持有的最大现金</span></span><br><span class="line"><span class="comment">    f[i][0] 不操作</span></span><br><span class="line"><span class="comment">    f[i][1] 第一次持有 </span></span><br><span class="line"><span class="comment">    f[i][2] 第一次不持有</span></span><br><span class="line"><span class="comment">    f[i][3] 第二次持有</span></span><br><span class="line"><span class="comment">    f[i][4] 第二次不持有</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> prices.length;</span><br><span class="line">        <span class="type">int</span> [][] f = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>][<span class="number">5</span>];</span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        <span class="comment">// 第0天不操作 那就是0</span></span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 第1次持有 即第一次买入</span></span><br><span class="line">        f[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 第1次不持有 即买入后直接卖出</span></span><br><span class="line">        f[<span class="number">0</span>][<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 第2次持有与不持有 与第1次逻辑相同</span></span><br><span class="line">        f[<span class="number">0</span>][<span class="number">3</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">4</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 状态转移</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n ; i++)&#123;</span><br><span class="line">            <span class="comment">// 第i天不操作 那就是相当于 前一天的值</span></span><br><span class="line">            f[i][<span class="number">0</span>] = f[i - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">            <span class="comment">// 第i天 第1次持有 那么只能是不操作 或者 从第i-1天不持有转移而来 那么只能买入</span></span><br><span class="line">            f[i][<span class="number">1</span>] = Math.max(f[i - <span class="number">1</span>][<span class="number">1</span>],f[i - <span class="number">1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">            <span class="comment">// 第i天 第1次不持有 那么只能是操作 或者 从第i-1天第1次持有转移而来 那么只能卖出</span></span><br><span class="line">            f[i][<span class="number">2</span>] = Math.max(f[i - <span class="number">1</span>][<span class="number">2</span>],f[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">            <span class="comment">// f[i][3] f[i][4] 同理</span></span><br><span class="line">            f[i][<span class="number">3</span>] = Math.max(f[i - <span class="number">1</span>][<span class="number">3</span>],f[i - <span class="number">1</span>][<span class="number">2</span>] - prices[i]);</span><br><span class="line">            f[i][<span class="number">4</span>] = Math.max(f[i - <span class="number">1</span>][<span class="number">4</span>],f[i - <span class="number">1</span>][<span class="number">3</span>] + prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最后一天都卖出 才肯能得到最大现金   </span></span><br><span class="line">        <span class="keyword">return</span> Math.max(f[n - <span class="number">1</span>][<span class="number">2</span>],f[n - <span class="number">1</span>][<span class="number">4</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 股票问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode122买卖股票的最佳时机Ⅱ</title>
      <link href="/2023/10/09/leetcode/leetcode122%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E2%85%A1/"/>
      <url>/2023/10/09/leetcode/leetcode122%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E2%85%A1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>原题链接:<br><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/">https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/</a></p><h2><span id="解法1">解法1:</span></h2><p>贪心</p><p>只要是股票上涨日 就进行买卖那就必赚<br>只用算隔天涨幅赚的钱即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> prices.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; n - <span class="number">1</span> ; i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> prices[i + <span class="number">1</span>] - prices[i];</span><br><span class="line">            <span class="keyword">if</span>(tmp &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                ans += tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2><span id="解法2">解法2:</span></h2><p>动态规划</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  f[i][j] 表示 第i天的持股状态为j时的最大现金数   j = 1 表示持有股票</span></span><br><span class="line"><span class="comment"> *  初始时</span></span><br><span class="line"><span class="comment"> *  1. 如果不进行任何操作 f[0][0] = 0 第一天不交易所以没利润</span></span><br><span class="line"><span class="comment"> *  2. 如果进行交易 f[0][1] = -prices[1] 交易了股票 则要付出现金</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  状态转移</span></span><br><span class="line"><span class="comment"> *  第 i 天 买入 或 不操作 f[i][1] = max(f[i - 1][1],f[i - 1][0] - prices[i])</span></span><br><span class="line"><span class="comment"> *  第 i 天 卖出 或 不操作 f[i][0] = max(f[i - 1][0],f[i - 1][0] + prices[i])</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> prices.length;</span><br><span class="line">        <span class="type">int</span> [][] f = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">        <span class="comment">// 不操作 则 现金为0</span></span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 第1天手上没持股则只能买入</span></span><br><span class="line">        f[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span> ; i &lt; n ; i++)&#123;</span><br><span class="line">            <span class="comment">// 卖出 或者 不操作</span></span><br><span class="line">            f[i][<span class="number">0</span>] = Math.max(f[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i],f[i - <span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">            <span class="comment">// 买入 或者 不操作</span></span><br><span class="line">            f[i][<span class="number">1</span>] = Math.max(f[i - <span class="number">1</span>][<span class="number">0</span>] - prices[i],f[i - <span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span>  Math.max(f[n - <span class="number">1</span>][<span class="number">0</span>],f[n - <span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更进一步的可以在空间上进行优化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 空间优化</span></span><br><span class="line"><span class="comment"> * 先考虑将状态数组分开表示 将表示状态维度省去 (这个操作并没有优化空间)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> prices.length;</span><br><span class="line">        <span class="comment">// 表示第i天所持有的最大现金</span></span><br><span class="line">        <span class="type">int</span> [] cash = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="comment">// 表示第i天是否持有股票</span></span><br><span class="line">        <span class="type">int</span> [] hold = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 初始值</span></span><br><span class="line">        <span class="comment">// 刚开始只能买入 所以可获得的最大现金为0 </span></span><br><span class="line">        cash[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 刚开始为持有状态 则只能买入</span></span><br><span class="line">        hold[<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span> ; i &lt; n ; i++)&#123;</span><br><span class="line">            <span class="comment">// 不操作 或者 卖出  这只会影响到cash 因为卖出一定是赚的</span></span><br><span class="line">            <span class="comment">// 且只有在股票持有的状态才能卖出</span></span><br><span class="line">            cash[i] = Math.max(cash[i - <span class="number">1</span>],hold[i - <span class="number">1</span>] + prices[i]);  </span><br><span class="line"></span><br><span class="line">            <span class="comment">// 不操作 或者 买入 这只会影响hold 因为买入一定是花钱的</span></span><br><span class="line">            <span class="comment">// 通过持有现金才能买入</span></span><br><span class="line">            hold[i] = Math.max(hold[i - <span class="number">1</span>],cash[i - <span class="number">1</span>] - prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> cash[n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在上一步基础可以观察到 cash 和 hold都只涉及到上一步的变量因此 我们可以用滚动数组进一步优化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 空间优化</span></span><br><span class="line"><span class="comment"> * 先考虑将状态数组分开表示 将表示状态维度省去 (这个操作并没有优化空间)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> prices.length;</span><br><span class="line">        <span class="comment">// 表示第i天所持有的最大现金</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">cash</span> <span class="operator">=</span> <span class="number">0</span> ;</span><br><span class="line">        <span class="comment">// 表示第i天是否持有股票</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">hold</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 初始值</span></span><br><span class="line">        <span class="comment">// 刚开始只能买入 所以可获得的最大现金为0 </span></span><br><span class="line">        cash = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 刚开始为持有状态 则只能买入</span></span><br><span class="line">        hold = -prices[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">preCash</span> <span class="operator">=</span> cash;</span><br><span class="line">        <span class="type">int</span> <span class="variable">preHold</span> <span class="operator">=</span> hold;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span> ; i &lt; n ; i++)&#123;</span><br><span class="line">            <span class="comment">// 不操作 或者 卖出  这只会影响到cash 因为卖出一定是赚的</span></span><br><span class="line">            <span class="comment">// 且只有在股票持有的状态才能卖出</span></span><br><span class="line">            cash = Math.max(preCash,preHold + prices[i]);  </span><br><span class="line"></span><br><span class="line">            <span class="comment">// 不操作 或者 买入 这只会影响hold 因为买入一定是花钱的</span></span><br><span class="line">            <span class="comment">// 通过持有现金才能买入</span></span><br><span class="line">            hold = Math.max(preHold,preCash - prices[i]);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 更新状态</span></span><br><span class="line">            preCash = cash;</span><br><span class="line">            preHold = hold;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> cash;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 状态机模型 </tag>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode121买卖股票的最佳时机</title>
      <link href="/2023/10/08/leetcode/leetcode121%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/"/>
      <url>/2023/10/08/leetcode/leetcode121%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>原题链接:<br><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/description/">https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/description/</a></p><h2><span id="解法1">解法1:</span></h2><p>枚举+维护前缀数组的最小值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    由于卖出操作必须在买入操作之后</span></span><br><span class="line"><span class="comment">    即该题可理解存在寻找 顺序限制的最大最小值差值问题</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 用于存储最小值</span></span><br><span class="line">        <span class="type">int</span> m = <span class="number">1e9</span>; </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i &lt; n ; i++)&#123;</span><br><span class="line">            m = <span class="built_in">min</span>(m,prices[i]);</span><br><span class="line">            res = <span class="built_in">max</span>(prices[i] - m,res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>动态规划</strong><br>其实上述解法 其实就是动态规划理解的简化<br>令f[i] 表示 第i天能买到股票的最低价 则最大利润res &#x3D; max(prices[i] - f[i],res);<br>对于f[i]而言 其状态转移方程即为<br>f[i] &#x3D; min(prices[i],f[i - 1])<br>更简化一步 就可以直接用滚动数组的方式进行简化 就变成上面的那种解法</p>]]></content>
      
      
      <categories>
          
          <category> algo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 枚举 </tag>
            
            <tag> 状态机模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode_week_362_恒生电子</title>
      <link href="/2023/09/10/contests/leetcode_week_362/"/>
      <url>/2023/09/10/contests/leetcode_week_362/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>contest url :<br><a href="https://leetcode.cn/contest/weekly-contest-362/">https://leetcode.cn/contest/weekly-contest-362/</a></p><h2><span id="8029-与车相交的点">8029 与车相交的点</span></h2><h3><span id="解法1-模拟">解法1 模拟</span></h3><p>根据题意暴力解决</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numberOfPoints</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;<span class="built_in">q</span>(<span class="number">101</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i &lt; nums.<span class="built_in">size</span>() ; i++)&#123;</span><br><span class="line">            <span class="type">int</span> a = nums[i][<span class="number">0</span>],b = nums[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = a ; j &lt;= b ; j++)&#123;</span><br><span class="line">                q[j] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span> ; i &lt;= <span class="number">100</span> ; i++)&#123;</span><br><span class="line">            ans += q[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2><span id="8049-判断能否在给定时间到达单元格">8049. 判断能否在给定时间到达单元格</span></h2><h3><span id="解法1-数学公式">解法1 数学公式</span></h3><p>常规思路 最短路问题 : BFS<br>但这题没有障碍物 且是无限边界的图 <strong>数据范围1e9</strong> BFS就不适用了<br>考虑数学公式 两边之和 大于等于 第三边<br>由于向周围8格子走 那么理论最短肯定是斜线 由于是格子是整数 所以不会是直接斜线<br>那么最短距离就是先走完最短斜线 -&gt; 起点x,y 终点x,y 任一相等后再走完 -&gt; 即相当于最短 走了最长那条边的距离 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isReachableAtTime</span><span class="params">(<span class="type">int</span> sx, <span class="type">int</span> sy, <span class="type">int</span> fx, <span class="type">int</span> fy, <span class="type">int</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 特殊情况 起点终点相同时 如果只能走一步的话 那就只能往外走 回不来了</span></span><br><span class="line">        <span class="keyword">if</span>(sx == fx &amp;&amp; sy == fy &amp;&amp; t == <span class="number">1</span> )&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">abs</span>(sx - fx),<span class="built_in">abs</span>(sy - fy)) &lt;= t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 恒生电子 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode课程表-合集</title>
      <link href="/2023/09/09/leetcode/leetcode%E8%AF%BE%E7%A8%8B%E8%A1%A8-%E5%90%88%E9%9B%86/"/>
      <url>/2023/09/09/leetcode/leetcode%E8%AF%BE%E7%A8%8B%E8%A1%A8-%E5%90%88%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>原题链接:<br><a href="https://leetcode.cn/problems/course-schedule/description/">https://leetcode.cn/problems/course-schedule/description/</a></p><h2><span id="解法1">解法1:</span></h2><p>拓扑排序 </p><p>基本上照着拓扑排序模板来就行了<br>就是题意稍微理解一下<br>prerequisites[i] &#x3D; [ai, bi] ，表示如果要学习课程 ai 则 必须 先学习课程  bi 。<br>所以 b -&gt; a</p><p>拓扑排序步骤: </p><ol><li>入队所有入度为0 的点</li><li>bfs 取出队头t -&gt; <strong>每取出一次队头说明有一个数已加入排序好的序列</strong></li><li>枚举t的所有出边 t-&gt;j<ol><li>删掉 t-&gt;j 即让 d[j]– (d[j] j的入度)</li><li>if d[j] &#x3D;&#x3D; 0 -&gt; 说明j之前所有点均以排好序 -&gt; j 入队</li></ol></li><li>如果图中存在环则无法全部入队 反之则都可以入队</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">拓扑排序 </span></span><br><span class="line"><span class="comment">学a 需要先学b  a &lt;- b</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canFinish</span><span class="params">(<span class="type">int</span> numCourses, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 图</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;g;</span><br><span class="line">        <span class="comment">// 入度</span></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;d;</span><br><span class="line">        g.<span class="built_in">resize</span>(numCourses);</span><br><span class="line">        d.<span class="built_in">resize</span>(numCourses);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> p : prerequisites)&#123;</span><br><span class="line">            <span class="comment">// b -&gt; a</span></span><br><span class="line">            g[p[<span class="number">1</span>]].<span class="built_in">push_back</span>(p[<span class="number">0</span>]);</span><br><span class="line">            d[p[<span class="number">0</span>]]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        queue&lt;<span class="type">int</span>&gt;q;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i &lt; numCourses ; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(d[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                q.<span class="built_in">push</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(q.<span class="built_in">empty</span>() == <span class="literal">false</span>)&#123;</span><br><span class="line">            <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 每次出队 代表完成一次排序 numCourse--</span></span><br><span class="line">            numCourses--;</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> v:g[t])&#123;</span><br><span class="line">                d[v]--;</span><br><span class="line">                <span class="keyword">if</span>(d[v] == <span class="number">0</span>)&#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> numCourses == <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1><span id="leetcode210-课程表2">leetcode210 课程表2</span></h1><p>原题链接:<br><a href="https://leetcode.cn/problems/course-schedule-ii/">https://leetcode.cn/problems/course-schedule-ii/</a></p><p>和上一题都一样就是要返回具体拓扑的顺序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">拓扑排序</span></span><br><span class="line"><span class="comment">1. 入度为0入队</span></span><br><span class="line"><span class="comment">2. 队头j出队 加入 结果</span></span><br><span class="line"><span class="comment">3. 遍历j 所有边 入度-1 </span></span><br><span class="line"><span class="comment">4. 入度为0再次入队 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findOrder</span><span class="params">(<span class="type">int</span> numCourses, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;g;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;d;</span><br><span class="line">        g.<span class="built_in">resize</span>(numCourses);</span><br><span class="line">        d.<span class="built_in">resize</span>(numCourses);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; prerequisites.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="comment">// a &lt;- b</span></span><br><span class="line">            <span class="type">int</span> a = prerequisites[i][<span class="number">0</span>], b = prerequisites[i][<span class="number">1</span>];</span><br><span class="line">            g[b].<span class="built_in">push_back</span>(a);</span><br><span class="line">            d[a]++;</span><br><span class="line">        &#125;         </span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        queue&lt;<span class="type">int</span>&gt;q;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; numCourses ; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(d[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                q.<span class="built_in">push</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">while</span>(q.<span class="built_in">empty</span>() == <span class="literal">false</span>)&#123;</span><br><span class="line">            <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">            ans.<span class="built_in">push_back</span>(t);</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> j : g[t])&#123;</span><br><span class="line">                d[j]--;</span><br><span class="line">                <span class="keyword">if</span>(d[j] == <span class="number">0</span>)&#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans.<span class="built_in">size</span>() == numCourses ? ans : <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1><span id="1462-课程表-iv">1462. 课程表 IV</span></h1><p>原题链接:<br><a href="https://leetcode.cn/problems/course-schedule-iv/">https://leetcode.cn/problems/course-schedule-iv/</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    在拓扑排序的基础 加一个数组f[][] 用于记录各个节点之间的可达性</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">checkIfPrerequisite</span><span class="params">(<span class="type">int</span> numCourses, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; prerequisites, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; queries)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt;<span class="built_in">f</span>(numCourses,<span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(numCourses,<span class="literal">false</span>)); </span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;<span class="built_in">d</span>(numCourses);</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;<span class="built_in">g</span>(numCourses);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i &lt; prerequisites.<span class="built_in">size</span>() ; i++)&#123;</span><br><span class="line">            <span class="type">int</span> a = prerequisites[i][<span class="number">0</span>], b = prerequisites[i][<span class="number">1</span>];</span><br><span class="line">            g[a].<span class="built_in">push_back</span>(b);</span><br><span class="line">            d[b]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        queue&lt;<span class="type">int</span>&gt;q;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i &lt; numCourses ; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(d[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                q.<span class="built_in">push</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(q.<span class="built_in">empty</span>() == <span class="literal">false</span>)&#123;</span><br><span class="line">            <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> j : g[t])&#123;</span><br><span class="line">                <span class="comment">// j 为t 的边 因此 t,j 可达</span></span><br><span class="line">                f[t][j] = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> h = <span class="number">0</span> ; h &lt; numCourses ; h++)&#123;</span><br><span class="line">                    <span class="comment">// t 可以到j </span></span><br><span class="line">                    <span class="comment">// 那么存在如果一点 h </span></span><br><span class="line">                    <span class="comment">// 如果 h 可以到 t  </span></span><br><span class="line">                    <span class="comment">// 那么 h就可以顺着t 到达j</span></span><br><span class="line">                    <span class="keyword">if</span>(f[h][t])&#123;</span><br><span class="line">                        f[h][j] = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                d[j]--;</span><br><span class="line">                <span class="keyword">if</span>(d[j] == <span class="number">0</span>)&#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;<span class="type">bool</span>&gt; ans;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;qry : queries)&#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(f[qry[<span class="number">0</span>]][qry[<span class="number">1</span>]]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 拓扑排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode2594修车的最少时间</title>
      <link href="/2023/09/07/leetcode/leetcode2594%E4%BF%AE%E8%BD%A6%E7%9A%84%E6%9C%80%E5%B0%91%E6%97%B6%E9%97%B4/"/>
      <url>/2023/09/07/leetcode/leetcode2594%E4%BF%AE%E8%BD%A6%E7%9A%84%E6%9C%80%E5%B0%91%E6%97%B6%E9%97%B4/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>原题链接:<br><a href="https://leetcode.cn/problems/minimum-time-to-repair-cars/description/">https://leetcode.cn/problems/minimum-time-to-repair-cars/description/</a></p><h2><span id="解法1-二分">解法1: 二分</span></h2><p>需要稍微证明一下<br>由题:<br>r * $n^2$ &lt;&#x3D;  t  -&gt; n &lt;&#x3D; $\sqrt{t&#x2F;r}$<br>n 与 r 为常量 即n越大 那么能修的车就越多 -&gt; 即拥有单调性因此可以对t进行二分</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    二分: 上界为能力最低的机械工 单独修完所有车辆的时间</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">repairCars</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; ranks, <span class="type">int</span> cars)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(ranks.<span class="built_in">begin</span>(),ranks.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> right = <span class="number">1LL</span> * ranks[<span class="number">0</span>] * cars * cars;</span><br><span class="line">        <span class="comment">// 下界为 left =  0  一辆都不修</span></span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(left + <span class="number">1</span>&lt; right)&#123;</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> mid =  (left + right) &gt;&gt; <span class="number">1</span>, s = <span class="number">0</span> ;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> r : ranks)&#123;</span><br><span class="line">                s += <span class="built_in">sqrt</span>(mid / r);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 当修 能力最低花 mid 时间修车时</span></span><br><span class="line">            <span class="comment">// 剩余所有修车者可以修完所有车辆</span></span><br><span class="line">            <span class="comment">// -&gt; 证明 分配给mid 的时间太多 可以少一些 减少上界</span></span><br><span class="line">            <span class="keyword">if</span>(s &gt;= cars)&#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                left = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode2511最多可以摧毁的敌人城堡数目</title>
      <link href="/2023/09/03/leetcode/leetcode2511%E6%9C%80%E5%A4%9A%E5%8F%AF%E4%BB%A5%E6%91%A7%E6%AF%81%E7%9A%84%E6%95%8C%E4%BA%BA%E5%9F%8E%E5%A0%A1%E6%95%B0%E7%9B%AE/"/>
      <url>/2023/09/03/leetcode/leetcode2511%E6%9C%80%E5%A4%9A%E5%8F%AF%E4%BB%A5%E6%91%A7%E6%AF%81%E7%9A%84%E6%95%8C%E4%BA%BA%E5%9F%8E%E5%A0%A1%E6%95%B0%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>原题链接:<br><a href="https://leetcode.cn/problems/maximum-enemy-forts-that-can-be-captured/">https://leetcode.cn/problems/maximum-enemy-forts-that-can-be-captured/</a></p><h2><span id="解法1-双指针">解法1: 双指针</span></h2><p>思路比较简单 但是题目要求其实还是要理解一下的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 双指针</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">captureForts</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; forts)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> n = forts.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i &lt; n ; i++)&#123;</span><br><span class="line">            <span class="comment">// 如果是1 找-1 即城堡走到空位</span></span><br><span class="line">            <span class="comment">// 如果是-1 找1 </span></span><br><span class="line">            <span class="keyword">if</span>(forts[i] != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="type">int</span> j = i + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span>(j &lt; n &amp;&amp; forts[j] == <span class="number">0</span>)&#123;</span><br><span class="line">                    j++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 刚好是1个城堡 1个空位的情况 则符合条件更新答案</span></span><br><span class="line">                <span class="keyword">if</span>(forts[i] + forts[j] == <span class="number">0</span>)&#123;</span><br><span class="line">                    ans = <span class="built_in">max</span>(ans,j - i - <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                i = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode_week_359</title>
      <link href="/2023/08/22/contests/leetcode_week_359/"/>
      <url>/2023/08/22/contests/leetcode_week_359/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>contest url :<br><a href="https://leetcode.cn/contest/weekly-contest-359/">https://leetcode.cn/contest/weekly-contest-359/</a></p><h2><span id="2830-销售利润最大化">2830. 销售利润最大化</span></h2><p>很好的一道DP题<br>虽然本质就是普通的线性DP 但是区间的那步转化非常巧妙</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">状态表示: f[i] 表示销售编号不超过i的房屋的最大盈利</span></span><br><span class="line"><span class="comment">    状态计算:</span></span><br><span class="line"><span class="comment">        考虑编号为i的房屋卖或不卖:</span></span><br><span class="line"><span class="comment">        不卖: f[i] = f[i - 1]</span></span><br><span class="line"><span class="comment">        卖: 所有endj = i 的购买请求 有 f[i] = max(f[start - 1] + gold) </span></span><br><span class="line"><span class="comment">        为方便遍历先将所有end相同的购买请求用hash进行存储</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maximizeTheProfit</span><span class="params">(<span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; offers)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 先存储end 相同的offer</span></span><br><span class="line">        <span class="comment">// end -&gt; &lt;start,gold&gt;</span></span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;&gt;hash;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;offer: offers)&#123;</span><br><span class="line">            <span class="keyword">auto</span> &amp;s = offer[<span class="number">0</span>], &amp;e = offer[<span class="number">1</span>], &amp;g = offer[<span class="number">2</span>];</span><br><span class="line">            <span class="comment">// cout &lt;&lt;s &lt;&lt; &#x27; &#x27; &lt;&lt; e &lt;&lt; &#x27; &#x27; &lt;&lt; g &lt;&lt; endl;</span></span><br><span class="line">            hash[e].<span class="built_in">emplace_back</span>(s,g);</span><br><span class="line">        &#125;            </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// f[i] 表示前i个可获得最大利润</span></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;<span class="built_in">f</span>(n + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> e = <span class="number">0</span> ; e &lt; n ; e++)&#123;</span><br><span class="line">            f[e + <span class="number">1</span>] = f[e];</span><br><span class="line">            <span class="keyword">auto</span> &amp; arr = hash[e];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;[s,g] : arr)&#123;</span><br><span class="line">                f[e + <span class="number">1</span>] = <span class="built_in">max</span>(f[e + <span class="number">1</span>], f[s] + g);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> f[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试高频题leetcode篇</title>
      <link href="/2023/08/20/algoSummary/%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91%E9%A2%98leetcode%E7%AF%87/"/>
      <url>/2023/08/20/algoSummary/%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91%E9%A2%98leetcode%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>参考题单:<br><a href="https://zhuanlan.zhihu.com/p/349940945">https://zhuanlan.zhihu.com/p/349940945</a></p><h1><span id="排序类">排序类</span></h1><h2><span id="基础题">基础题</span></h2><h3><span id="148-排序链表">148 排序链表</span></h3><p>原题链接:<br><a href="https://leetcode.cn/problems/sort-list/">https://leetcode.cn/problems/sort-list/</a></p><p>归并排序:</p><ol><li>先快慢指针找到中点</li><li>切分 </li><li>对子序列排序</li><li>merge</li></ol><p>1.归并排序 (TOP-DOWN 自顶向下)<br>把merge 拆分出去写 逻辑上更好理解一些</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">sortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 递归出口</span></span><br><span class="line">        <span class="comment">// 这里可能会有只有一个节点的情况 不需要排序故直接return head 而不是null</span></span><br><span class="line">        <span class="keyword">if</span>(!head || !head-&gt;next)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里快慢指针 这种写法是最稳的 不然会出错 </span></span><br><span class="line">        ListNode * fast = head-&gt;next;</span><br><span class="line">        ListNode * slow = head;        </span><br><span class="line">        <span class="keyword">while</span>(fast &amp;&amp; fast-&gt;next)&#123;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode * mid = slow-&gt;next;</span><br><span class="line">        <span class="comment">// 将链表断开 即 完成 切分  </span></span><br><span class="line">        slow-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">merge</span>(<span class="built_in">sortList</span>(head),<span class="built_in">sortList</span>(mid));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode * <span class="title">merge</span><span class="params">(ListNode * l1,ListNode * l2)</span></span>&#123;</span><br><span class="line">        <span class="function">ListNode <span class="title">dummy</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">auto</span> p =  &amp;dummy;</span><br><span class="line">        <span class="comment">// 默认将l1 视为主链表</span></span><br><span class="line">        <span class="keyword">while</span>(l1 &amp;&amp; l2)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l1-&gt;val &gt; l2-&gt;val)&#123;</span><br><span class="line">                <span class="built_in">swap</span>(l1,l2); </span><br><span class="line">            &#125;</span><br><span class="line">            p-&gt;next = l1;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            l1 = l1-&gt;next;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 加不加都行</span></span><br><span class="line">            <span class="comment">// p-&gt;next = nullptr;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(l1)&#123;</span><br><span class="line">            p-&gt;next = l1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(l2)&#123;</span><br><span class="line">            p-&gt;next = l2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>写法2</strong><br>合在一起写 看着简洁一些 其实只是把merge的逻辑融合进去了 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">sortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head || !head-&gt;next)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode * fast =  head-&gt;next;</span><br><span class="line">        ListNode * slow = head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(fast &amp;&amp; fast-&gt;next)&#123;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode * mid = slow-&gt;next;</span><br><span class="line">        slow-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        ListNode * left = <span class="built_in">sortList</span>(head);</span><br><span class="line">        ListNode * right = <span class="built_in">sortList</span>(mid);</span><br><span class="line"></span><br><span class="line">        ListNode * dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">auto</span> p = dummy;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(left &amp;&amp; right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(left-&gt;val &gt; right-&gt;val)&#123;</span><br><span class="line">                <span class="built_in">swap</span>(left,right);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            p-&gt;next = left;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            left = left-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(left)&#123;</span><br><span class="line">            p-&gt;next = left;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(right)&#123;</span><br><span class="line">            p-&gt;next = right;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="2"><li>归并排序(BOTTOM UP 自底向上)<br>省去了递归的空间栈 优化了内存<br>即实现了 constant space<br>但代码和思维的难度都加大了</li></ol><h3><span id="56-合并区间">56 合并区间</span></h3><p>原题链接:<br><a href="https://leetcode.cn/problems/merge-intervals/submissions/">https://leetcode.cn/problems/merge-intervals/submissions/</a><br>很经典的一道题了<br>虽然归类在排序 但还是在贪心里遇到的次数的多一些</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  </span></span><br><span class="line"><span class="comment">    贪心 按照左端点先排</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">merge</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; intervals) &#123;</span><br><span class="line">        <span class="type">int</span> n = intervals.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">sort</span>(intervals.<span class="built_in">begin</span>(),intervals.<span class="built_in">end</span>(),[&amp;](vector&lt;<span class="type">int</span>&gt;&amp;a,vector&lt;<span class="type">int</span>&gt;&amp;b)&#123;</span><br><span class="line">            <span class="keyword">return</span> a[<span class="number">0</span>] &lt; b[<span class="number">0</span>];</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span> ; i &lt; n ; i++)&#123;</span><br><span class="line">            <span class="comment">// 如果当前为空 或者 已处理完的区间最右边的端点 小于当前区间的左端点 则证明没有重叠直接加入即可 </span></span><br><span class="line">            <span class="keyword">if</span>(ans.<span class="built_in">empty</span>() || ans.<span class="built_in">back</span>()[<span class="number">1</span>] &lt;  intervals[i][<span class="number">0</span>] )&#123;</span><br><span class="line">                ans.<span class="built_in">emplace_back</span>(intervals[i]);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 发生重叠时 右端点取最大的进行合并</span></span><br><span class="line">                ans.<span class="built_in">back</span>()[<span class="number">1</span>] = <span class="built_in">max</span>(ans.<span class="built_in">back</span>()[<span class="number">1</span>],intervals[i][<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>相似题: 插入区间57</strong><br>原题链接:<br><a href="https://leetcode.cn/problems/insert-interval/description/">https://leetcode.cn/problems/insert-interval/description/</a><br>几乎就是合并区间的思路一模一样 但是写法写出来 会有很巧妙的感觉</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">insert</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; intervals, vector&lt;<span class="type">int</span>&gt;&amp; newInterval) &#123;</span><br><span class="line">        <span class="comment">// 排新的区间也加进去一起排序</span></span><br><span class="line">        intervals.<span class="built_in">emplace_back</span>(newInterval);</span><br><span class="line">        <span class="comment">// sort排序 默认按照多元数组第一个值排序</span></span><br><span class="line">        <span class="built_in">sort</span>(intervals.<span class="built_in">begin</span>(),intervals.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 然后合并后区间的思路走一遍</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;ans;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i &lt; intervals.<span class="built_in">size</span>() ; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ans.<span class="built_in">empty</span>() || ans.<span class="built_in">back</span>()[<span class="number">1</span>] &lt; intervals[i][<span class="number">0</span>])&#123;</span><br><span class="line">                ans.<span class="built_in">emplace_back</span>(intervals[i]);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ans.<span class="built_in">back</span>()[<span class="number">1</span>] = <span class="built_in">max</span>(ans.<span class="built_in">back</span>()[<span class="number">1</span>],intervals[i][<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans; </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当然以上是完全从合并区间 模仿而来的写法<br>实际上完全不需要遍历整个区间 即可以优化</p><p>优化:</p><h3><span id="27-移除元素">27 移除元素</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    关注重点在原地修改</span></span><br><span class="line"><span class="comment">    返回是新长度 来决定新的数组 因此前面的数组即为答案 </span></span><br><span class="line"><span class="comment">    从前往后遍历 把不符合条件的往后换即可</span></span><br><span class="line"><span class="comment">    核心做法就是 双指针</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>, j = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= j  &amp;&amp; i &lt; n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == val)&#123;</span><br><span class="line">                <span class="built_in">swap</span>(nums[i],nums[j]);</span><br><span class="line">                <span class="comment">// 防止换到前面的数 仍然是不符合条件的数  因此i-- 然后再判断一次 </span></span><br><span class="line">                i--;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回是长度 所以  +1</span></span><br><span class="line">        <span class="keyword">return</span> j + <span class="number">1</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2><span id="进阶题">进阶题</span></h2><h3><span id="179-最大数">179 最大数</span></h3><p>原题链接:<br><a href="https://leetcode.cn/problems/largest-number/">https://leetcode.cn/problems/largest-number/</a><br>这个题的解法基本没做过 就肯定出不来了<br>因为要求的是拼接后最大的数 那么对拼接后的效果进行比较<br>将ab转换为string后进行拼接  拼接后长度是一样的 所以直接比较字典序即可<br>然后最后要注意处理一下前导0的情况</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">largestNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>(),[&amp;](<span class="type">int</span> a,<span class="type">int</span> b)&#123;</span><br><span class="line">            string x = <span class="built_in">to_string</span>(a);</span><br><span class="line">            string y = <span class="built_in">to_string</span>(b);</span><br><span class="line">            <span class="keyword">return</span> x + y &gt; y + x;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        string s = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;ss : nums)&#123;</span><br><span class="line">            s += <span class="built_in">to_string</span>(ss);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 最后一定还要剩余一个数 所以是s.size() - 1</span></span><br><span class="line">        <span class="keyword">while</span>(p &lt; s.<span class="built_in">size</span>() - <span class="number">1</span> &amp;&amp; s[p] == <span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">            p++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">substr</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1><span id="链表类">链表类</span></h1><h2><span id="基础题">基础题</span></h2><h3><span id="206-反转链表">206 反转链表</span></h3><p>原题链接:<br><a href="https://leetcode.cn/problems/reverse-linked-list/description/">https://leetcode.cn/problems/reverse-linked-list/description/</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode * pre = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode * cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur)&#123;</span><br><span class="line">            ListNode * ne = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = pre;</span><br><span class="line">            pre = cur;   </span><br><span class="line">            cur = ne ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最后返回是pre </span></span><br><span class="line">        <span class="comment">// 因为 pre指向的是 上一步 cur不为null 也就是cur到cur-&gt;next前的位置 </span></span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3><span id="876-链表的中间节点">876 链表的中间节点</span></h3><p>原题链接:<br><a href="https://leetcode.cn/problems/middle-of-the-linked-list/description/">https://leetcode.cn/problems/middle-of-the-linked-list/description/</a></p><p>快慢指针<br>唯一需要注意的是 这题中间节点要返回的是后面那个</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">middleNode</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head || !head-&gt;next)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这种写法 即 快慢指针指向头节点的写法  有两个中间节点时返回后面那个</span></span><br><span class="line"></span><br><span class="line">        ListNode * slow = head;</span><br><span class="line">        ListNode * fast = head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(fast &amp;&amp; fast-&gt;next)&#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>扩展<br>返回中间两节点 返回前面那个写法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">middleNode</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head || !head-&gt;next)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  这种写法 默认返回前面那个</span></span><br><span class="line">        ListNode * slow = head;</span><br><span class="line">        ListNode * fast = head-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(fast &amp;&amp; fast-&gt;next)&#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>summary</strong>：</p><ol><li>中间节点返回后面那个： 快慢指针均指向首节点</li><li>中间节点返回前面那个:  快指针指向首节点 慢指针指向首节点</li></ol><h2><span id="进阶题">进阶题</span></h2><h3><span id="160-相交链表">160 相交链表</span></h3><p>原题链接:<br><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists/">https://leetcode.cn/problems/intersection-of-two-linked-lists/</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    双指针 上下同时开始遍历 </span></span><br><span class="line"><span class="comment">    遍历完跳到另一条链表上遍历 如果相交那么二次遍历时会发生相交 反之不相交</span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        ListNode * p = headA;</span><br><span class="line">        ListNode * q = headB;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 由于不相交 走完两条链表的总路程是一样的 最后一定停在nullptr的情况    </span></span><br><span class="line">        <span class="keyword">while</span>(p != q)&#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                这里第一次写成了 p-&gt;next == nullptr 这是不行的</span></span><br><span class="line"><span class="comment">                因为如果是p-&gt;next 那么如果两条不相交 那么p和q虽然走的路程一样 相对位置一样</span></span><br><span class="line"><span class="comment">                但最后都会指向链表的最后一个节点 即 始终满足 p!=q 陷入死循环</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            p = p == <span class="literal">nullptr</span> ? headB : p-&gt;next;</span><br><span class="line">            q = q == <span class="literal">nullptr</span> ? headA : q-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3><span id="141-环形链表">141 环形链表</span></h3><p>原题链接:<br><a href="https://leetcode.cn/problems/linked-list-cycle/description/">https://leetcode.cn/problems/linked-list-cycle/description/</a></p><p><strong>法1: 染色标记</strong><br>遍历一遍后逐个标记 如果遍历后再次遇到标记 则证明有环</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    染色</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> x = <span class="number">1e6</span>;</span><br><span class="line">        ListNode * p = head;</span><br><span class="line">        <span class="keyword">while</span>(p)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;val == x)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            p-&gt;val = x;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;          </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>法2: 快慢指针</strong></p><p>快慢指针<br>fast每次走两步 slow每一次一步<br>这里有个问题 <strong>fast 会不会跳过slow 从不会与 slow相遇</strong><br>这是不可能的 因为如果有环的话 那么fast slow都会进入环中<br>从相对速度的角度进行理解 即slow不动  fast每次走一步 那么fast slow必定相遇</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode * fast = head;</span><br><span class="line">        ListNode * slow = head;</span><br><span class="line">        <span class="keyword">while</span>(fast &amp;&amp; fast-&gt;next)&#123;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(fast == slow)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3><span id="92-reverse-linked-list-ii">92 Reverse Linked List II</span></h3><p>原题链接:<br><a href="https://leetcode.cn/problems/reverse-linked-list-ii/">https://leetcode.cn/problems/reverse-linked-list-ii/</a></p><p>反转链表的进阶</p><p>原题链接:<br><a href="https://leetcode.cn/problems/reverse-linked-list-ii/description/">https://leetcode.cn/problems/reverse-linked-list-ii/description/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    先找到需要翻转片段的第一个节点 记录p0 为要反转部分的前一个节点 pn为最后一个节点</span></span><br><span class="line"><span class="comment">    则 将中间部分反转后 再将 head-&gt;pn  p0-&gt;tail 即可</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseBetween</span><span class="params">(ListNode head, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>,head);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p0</span> <span class="operator">=</span> dummy;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找到要反转部分的第一个节点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; left - <span class="number">1</span>; i++)&#123;</span><br><span class="line">            p0 = p0.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> p0.next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; right - left + <span class="number">1</span> ; i++)&#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">nxt</span> <span class="operator">=</span> cur.next;</span><br><span class="line">            cur.next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = nxt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// cur操作完后 位于反转部分的后一个位置 </span></span><br><span class="line">        <span class="comment">// pre才在反转部分的最后一个位置</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 顺序不能换 否则p0.next.next就找不到了</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// p0为反转部分第一个节点的前一个节点</span></span><br><span class="line">        <span class="comment">// p0.next反转部分的第一个节点 在反转后位于最后的位置</span></span><br><span class="line">        <span class="comment">// p0.next.next 将反转部分最后接在 cur </span></span><br><span class="line">        p0.next.next = cur;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// p0 反转部分的前一个位置 将其与反转部分的最后一个位置直接相连</span></span><br><span class="line">        p0.next = pre;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3><span id="328-奇偶链表">328 奇偶链表</span></h3><p>原题链接:<br><a href="https://leetcode.cn/problems/odd-even-linked-list/">https://leetcode.cn/problems/odd-even-linked-list/</a></p><p>要求O(1)空间 O(n)时间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    遍历的同时 不断将偶数节点加入偶数的链表 同时删除链表的偶数节点</span></span><br><span class="line"><span class="comment">    最后将原链表尾部与 新链表直接拼接即可</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">oddEvenList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">oddDummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>();</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">oddTail</span> <span class="operator">=</span> oddDummy;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">evenDummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>();</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">evenTail</span> <span class="operator">=</span> evenDummy;</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isOdd</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(head != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 奇数节点</span></span><br><span class="line">            <span class="keyword">if</span>(!isOdd)&#123;</span><br><span class="line">                oddTail.next = head;</span><br><span class="line">                oddTail = oddTail.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                evenTail.next = head;</span><br><span class="line">                evenTail = evenTail.next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            head = head.next;</span><br><span class="line">            isOdd = !isOdd;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        oddTail.next = evenDummy.next;</span><br><span class="line">        evenTail.next = <span class="literal">null</span>;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> oddDummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1><span id="堆-栈-队列-哈希表类">堆、栈、队列、哈希表类</span></h1><h2><span id="基础题-queue">基础题 Queue</span></h2><h3><span id="leetcode225-用队列实现栈">leetcode225 用队列实现栈</span></h3><p>原题链接:<br><a href="https://leetcode.cn/problems/implement-stack-using-queues/">https://leetcode.cn/problems/implement-stack-using-queues/</a></p><p>双队列 q1 q2<br>q1直接视为栈的顺序 q2用于辅助q1在进行加入删除元素操作时 始终仍为栈的顺序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    栈 先进后出</span></span><br><span class="line"><span class="comment">    队列 先进先出</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    一个队列进行入栈 一个队列进行出栈</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    java 队列 统一用 offer() 和 poll() 和 peek()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span> &#123;</span><br><span class="line">    Queue&lt;Integer&gt;q1;</span><br><span class="line">    Queue&lt;Integer&gt;q2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyStack</span><span class="params">()</span> &#123;</span><br><span class="line">        q1 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;();</span><br><span class="line">        q2 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        每次push时 由于队列时先进先出</span></span><br><span class="line"><span class="comment">        将q1队列内的元素 按顺序push到q2中 那么对于而言由于q2也是先进先出 那么相同元素在q2中的出队顺序就是q1中先进后出</span></span><br><span class="line"><span class="comment">        即实现了栈的效果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">        q1 : 1 2 3 4 5</span></span><br><span class="line"><span class="comment">        q2 : 5 4 3 2 1</span></span><br><span class="line"><span class="comment">        s :  5 4 3 2 1      </span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="comment">// 根据栈的定义最后一个入栈的元素 最先出栈</span></span><br><span class="line">        <span class="comment">// 暂存q2 的队头 在q2中最后出 推入q1后变为最先出</span></span><br><span class="line">        q2.offer(x);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!q1.isEmpty())&#123;</span><br><span class="line">            q2.offer(q1.poll());</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;Integer&gt; temp = q1;</span><br><span class="line">        q1 = q2;</span><br><span class="line">        q2 = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        q1直接理解就是栈的顺序</span></span><br><span class="line"><span class="comment">        q2用于帮助q1实现栈</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> q1.poll();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> q1.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> q1.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyStack obj = new MyStack();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.top();</span></span><br><span class="line"><span class="comment"> * boolean param_4 = obj.empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3><span id="leetcodelcr041-数据流中的移动平均值">leetcodeLCR041 数据流中的移动平均值</span></h3><p>队列 按照题意模拟即可</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MovingAverage</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt;q;</span><br><span class="line">    <span class="type">int</span> s;</span><br><span class="line">    <span class="type">double</span> cur = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="built_in">MovingAverage</span>(<span class="type">int</span> size) &#123;</span><br><span class="line">        s = size;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">next</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        q.<span class="built_in">push</span>(val);</span><br><span class="line">        cur += val;</span><br><span class="line">        <span class="keyword">if</span>(q.<span class="built_in">size</span>() &gt; s)&#123;</span><br><span class="line">            cur -= q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cur / q.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MovingAverage object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MovingAverage* obj = new MovingAverage(size);</span></span><br><span class="line"><span class="comment"> * double param_1 = obj-&gt;next(val);</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3><span id="leetcode54-螺旋矩阵">leetcode54 螺旋矩阵</span></h3><p>原题链接:<br><a href="https://leetcode.cn/problems/spiral-matrix/">https://leetcode.cn/problems/spiral-matrix/</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">    模拟</span></span><br><span class="line"><span class="comment">    定好方向 走到边界或者走到走过的格子那么就直接转向</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">spiralOrder</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="comment">// 程序里面 向下走为+1 向上走才是+1</span></span><br><span class="line">        <span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="type">int</span> dy[<span class="number">4</span>] = &#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="type">int</span> d = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>, k = <span class="number">0</span>; k &lt; n * m ; k++ )&#123;        </span><br><span class="line">            ans.<span class="built_in">push_back</span>(matrix[x][y]);</span><br><span class="line">            matrix[x][y] = <span class="number">-1e9</span>;</span><br><span class="line">            <span class="type">int</span> a = x + dx[d];</span><br><span class="line">            <span class="type">int</span> b = y + dy[d];</span><br><span class="line">  </span><br><span class="line">            <span class="keyword">if</span>(a &gt;= m || b &gt;= n || a &lt; <span class="number">0</span> || b &lt; <span class="number">0</span> || matrix[a][b] == <span class="number">-1e9</span>)&#123;</span><br><span class="line">                d = (d + <span class="number">1</span>) % <span class="number">4</span>;</span><br><span class="line">                a = x + dx[d];</span><br><span class="line">                b = y + dy[d];</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            x = a;</span><br><span class="line">            y = b;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2><span id="基础题-stack">基础题 Stack</span></h2><h3><span id="leetcode155-最小栈">leetcode155 最小栈</span></h3><p>原题链接:<br><a href="https://leetcode.cn/problems/min-stack/description/">https://leetcode.cn/problems/min-stack/description/</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    辅助栈维护最小元素</span></span><br><span class="line"><span class="comment">    如果当前元素比 辅助栈栈顶元素小 则 入栈该元素 否则再次入栈辅助栈顶元素</span></span><br><span class="line"><span class="comment">    从而保证辅助栈的元素 始终与主栈同步</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span> &#123;</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    stack&lt;<span class="type">int</span>&gt;stk;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt;helper;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MinStack</span>() &#123;</span><br><span class="line">        <span class="comment">// 否则第一次没法判断  </span></span><br><span class="line">        helper.<span class="built_in">push</span>(INT_MAX);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        stk.<span class="built_in">push</span>(val);</span><br><span class="line">        <span class="keyword">if</span>(val &lt; helper.<span class="built_in">top</span>())&#123;</span><br><span class="line">            helper.<span class="built_in">push</span>(val);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            helper.<span class="built_in">push</span>(helper.<span class="built_in">top</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 题目规定操作是在非空栈上执行 </span></span><br><span class="line">    <span class="comment">// 因此不需要判断元素是否为空直接pop即可</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stk.<span class="built_in">pop</span>();</span><br><span class="line">        helper.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stk.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helper.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MinStack* obj = new MinStack();</span></span><br><span class="line"><span class="comment"> * obj-&gt;push(val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj-&gt;top();</span></span><br><span class="line"><span class="comment"> * int param_4 = obj-&gt;getMin();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h3><span id="leetcode232-用栈实现队列">leetcode232 用栈实现队列</span></h3><p>原题链接:<br><a href="https://leetcode.cn/problems/implement-queue-using-stacks/">https://leetcode.cn/problems/implement-queue-using-stacks/</a></p><p>双栈思路</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    栈 后进先出</span></span><br><span class="line"><span class="comment">    队列 先进先出</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    双栈一个栈专门用于入队 一个栈专门用于出队</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 入队 </span></span><br><span class="line">    stack&lt;<span class="type">int</span>&gt;pushStk;</span><br><span class="line">    <span class="comment">// 出队 </span></span><br><span class="line">    stack&lt;<span class="type">int</span>&gt;popStk;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MyQueue</span>() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 入栈 始终向 入队栈入</span></span><br><span class="line">        pushStk.<span class="built_in">push</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果出队栈为空 无法出队</span></span><br><span class="line">        <span class="comment">// 将入队栈 所有元素推入出队栈</span></span><br><span class="line">        <span class="keyword">if</span>(popStk.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">while</span>(pushStk.<span class="built_in">empty</span>() == <span class="literal">false</span>)&#123;</span><br><span class="line">                popStk.<span class="built_in">push</span>(pushStk.<span class="built_in">top</span>());</span><br><span class="line">                pushStk.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> x = popStk.<span class="built_in">top</span>();</span><br><span class="line">        popStk.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果入队栈为空 </span></span><br><span class="line">        <span class="comment">// 将出队栈所有元素 压入入队栈</span></span><br><span class="line">        <span class="keyword">if</span>(popStk.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">while</span>(pushStk.<span class="built_in">empty</span>() == <span class="literal">false</span>)&#123;</span><br><span class="line">                popStk.<span class="built_in">push</span>(pushStk.<span class="built_in">top</span>());</span><br><span class="line">                pushStk.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 栈顶出栈 那么对应也就是 队列出队的队头</span></span><br><span class="line">        <span class="keyword">return</span> popStk.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pushStk.<span class="built_in">empty</span>() &amp;&amp; popStk.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyQueue* obj = new MyQueue();</span></span><br><span class="line"><span class="comment"> * obj-&gt;push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj-&gt;pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj-&gt;peek();</span></span><br><span class="line"><span class="comment"> * bool param_4 = obj-&gt;empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3><span id="150-逆波兰表达式求值">150 逆波兰表达式求值</span></h3><p>栈</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    逆波兰表达式: 遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">evalRPN</span><span class="params">(vector&lt;string&gt;&amp; tokens)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt;stk;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp; t : tokens)&#123;</span><br><span class="line">            <span class="comment">// 如果不是运算符 那么一定是数 则入栈</span></span><br><span class="line">            <span class="keyword">if</span>(t != <span class="string">&quot;+&quot;</span> &amp;&amp; t != <span class="string">&quot;-&quot;</span> &amp;&amp; t != <span class="string">&quot;*&quot;</span> &amp;&amp; t!= <span class="string">&quot;/&quot;</span>)&#123;</span><br><span class="line">                stk.<span class="built_in">push</span>(<span class="built_in">stoi</span>(t));</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(t == <span class="string">&quot;+&quot;</span>)&#123;</span><br><span class="line">                    <span class="type">int</span> a = stk.<span class="built_in">top</span>();</span><br><span class="line">                    stk.<span class="built_in">pop</span>();</span><br><span class="line">                    <span class="type">int</span> b = stk.<span class="built_in">top</span>();</span><br><span class="line">                    stk.<span class="built_in">pop</span>();</span><br><span class="line">                    stk.<span class="built_in">push</span>(b + a);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(t == <span class="string">&quot;-&quot;</span>)&#123;</span><br><span class="line">                    <span class="type">int</span> a = stk.<span class="built_in">top</span>();</span><br><span class="line">                    stk.<span class="built_in">pop</span>();</span><br><span class="line">                    <span class="type">int</span> b = stk.<span class="built_in">top</span>();</span><br><span class="line">                    stk.<span class="built_in">pop</span>();</span><br><span class="line">                    stk.<span class="built_in">push</span>(b - a);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(t == <span class="string">&quot;*&quot;</span>)&#123;</span><br><span class="line">                    <span class="type">int</span> a = stk.<span class="built_in">top</span>();</span><br><span class="line">                    stk.<span class="built_in">pop</span>();</span><br><span class="line">                    <span class="type">int</span> b = stk.<span class="built_in">top</span>();</span><br><span class="line">                    stk.<span class="built_in">pop</span>();</span><br><span class="line">                    stk.<span class="built_in">push</span>(b * a);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(t == <span class="string">&quot;/&quot;</span>)&#123;</span><br><span class="line">                    <span class="type">int</span> a = stk.<span class="built_in">top</span>();</span><br><span class="line">                    stk.<span class="built_in">pop</span>();</span><br><span class="line">                    <span class="type">int</span> b = stk.<span class="built_in">top</span>();</span><br><span class="line">                    stk.<span class="built_in">pop</span>();</span><br><span class="line">                    stk.<span class="built_in">push</span>(b / a);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> stk.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3><span id="224-基本计算器">224 基本计算器</span></h3><p>双栈思路</p><p>原题链接:<br><a href="https://leetcode.cn/problems/basic-calculator/description/">https://leetcode.cn/problems/basic-calculator/description/</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    逆波兰式的思想 (数字入栈 运计算符出栈) 但这里要额外考虑一个( ) 问题</span></span><br><span class="line"><span class="comment">    双栈 </span></span><br><span class="line"><span class="comment">    nums:存放所有的数字  ops: 存放所有的数字以外的操作</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 将空格 全部跳过</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">replace</span><span class="params">(string &amp;s)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> pos = s.<span class="built_in">find</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="keyword">while</span>(pos != <span class="number">-1</span>)&#123;</span><br><span class="line">            s.<span class="built_in">replace</span>(pos,<span class="number">1</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line">            pos = s.<span class="built_in">find</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 运算</span></span><br><span class="line">    <span class="comment">// 运算栈 以及 操作符栈</span></span><br><span class="line">    <span class="comment">// 直接改变数的值 要加引用</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">cal</span><span class="params">(stack&lt;<span class="type">int</span>&gt;&amp;nums,stack&lt;<span class="type">char</span>&gt; &amp;ops)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>() &lt; <span class="number">2</span> || ops.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">char</span> op = ops.<span class="built_in">top</span>();</span><br><span class="line">        ops.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> a = nums.<span class="built_in">top</span>();</span><br><span class="line">        nums.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> b = nums.<span class="built_in">top</span>();</span><br><span class="line">        nums.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(op == <span class="string">&#x27;+&#x27;</span>)&#123;</span><br><span class="line">            ans = b + a;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(op == <span class="string">&#x27;-&#x27;</span>)&#123;</span><br><span class="line">            ans = b - a;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        nums.<span class="built_in">push</span>(ans);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">calculate</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">replace</span>(s);</span><br><span class="line">        <span class="comment">// 存放所有数字</span></span><br><span class="line">        stack&lt;<span class="type">int</span>&gt;nums;</span><br><span class="line">        nums.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 存放所有的操作 包括 +/- </span></span><br><span class="line">        stack&lt;<span class="type">char</span>&gt; ops;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i &lt; n ; i++)&#123;</span><br><span class="line">            <span class="type">char</span> c = s[i];</span><br><span class="line">            <span class="comment">// 加入操作符栈 等待与之匹配的 )</span></span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                ops.<span class="built_in">push</span>(c);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 使用现有的nums和ops进行计算 直到遇到左边最近的一个左括号为止 计算结果放到nums中</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">while</span>(!ops.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                    <span class="type">char</span> op  = ops.<span class="built_in">top</span>();</span><br><span class="line">                    <span class="keyword">if</span>(op != <span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                        <span class="built_in">cal</span>(nums,ops);</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        ops.<span class="built_in">pop</span>();</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 非括号 二是操作符或者数字的情况</span></span><br><span class="line">                <span class="comment">// 数字</span></span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">isdigit</span>(c))&#123;</span><br><span class="line">                    <span class="type">int</span> cur = <span class="number">0</span>;</span><br><span class="line">                    <span class="type">int</span> j = i;</span><br><span class="line">                    <span class="comment">// 从j位开始的连续数字取出 加入到nums中</span></span><br><span class="line">                    <span class="keyword">while</span>(j &lt; n &amp;&amp; <span class="built_in">isdigit</span>(s[j]))&#123;</span><br><span class="line">                        cur = cur * <span class="number">10</span> + (s[j++] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                    &#125;   </span><br><span class="line">                    nums.<span class="built_in">push</span>(cur);</span><br><span class="line">                    i = j - <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">// 操作符</span></span><br><span class="line">                    <span class="comment">// 防止() 内首个字符为运算符</span></span><br><span class="line">                    <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; (s[i - <span class="number">1</span>] ==  <span class="string">&#x27;(&#x27;</span> || s[i - <span class="number">1</span>] == <span class="string">&#x27;+&#x27;</span> || s[i - <span class="number">1</span>] == <span class="string">&#x27;-&#x27;</span>))&#123;</span><br><span class="line">                        <span class="comment">// 这样就可以有规避 负数问题 直接将负数转换为减号运算 0 - xxx</span></span><br><span class="line">                        nums.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 新操作符号入栈 先把栈内所有符号先算了</span></span><br><span class="line">                    <span class="keyword">while</span>(!ops.<span class="built_in">empty</span>() &amp;&amp; ops.<span class="built_in">top</span>() != <span class="string">&#x27;(&#x27;</span> )&#123;</span><br><span class="line">                        <span class="built_in">cal</span>(nums,ops);</span><br><span class="line">                    &#125;</span><br><span class="line">                    ops.<span class="built_in">push</span>(c);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把()外的剩余数 全部算掉</span></span><br><span class="line">        <span class="keyword">while</span>(!ops.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="built_in">cal</span>(nums,ops);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> nums.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3><span id="20-有效的括号">20 有效的括号</span></h3><p>原题链接:<br><a href="https://leetcode.cn/problems/valid-parentheses/">https://leetcode.cn/problems/valid-parentheses/</a></p><p>栈的基础应用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    栈</span></span><br><span class="line"><span class="comment">    左边入栈  遇到右边出栈判断</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">char</span>&gt;stk;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;c : s)&#123;</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">&#x27;(&#x27;</span> || c == <span class="string">&#x27;&#123;&#x27;</span> || c == <span class="string">&#x27;[&#x27;</span>)&#123;</span><br><span class="line">                stk.<span class="built_in">push</span>(c);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(stk.<span class="built_in">size</span>() &lt; <span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="type">char</span> x = stk.<span class="built_in">top</span>();</span><br><span class="line">                <span class="keyword">if</span>( (x == <span class="string">&#x27;(&#x27;</span> &amp;&amp; c == <span class="string">&#x27;)&#x27;</span>) || (x == <span class="string">&#x27;[&#x27;</span> &amp;&amp; c == <span class="string">&#x27;]&#x27;</span>) || (x == <span class="string">&#x27;&#123;&#x27;</span> &amp;&amp; c == <span class="string">&#x27;&#125;&#x27;</span>))&#123;</span><br><span class="line">                    stk.<span class="built_in">pop</span>();</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果栈中有多余元素则 证明未完成匹配</span></span><br><span class="line">        <span class="keyword">return</span> stk.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3><span id="1472-设计浏览器历史记录">1472 设计浏览器历史记录</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BrowserHistory</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 前进栈存储可以前进的页面</span></span><br><span class="line">    <span class="comment">// 在栈越前面 即越早入栈 越晚前进到</span></span><br><span class="line">    stack&lt;string&gt;sfor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认将后退栈顶视作当前浏览页 方便后续的讨</span></span><br><span class="line">    stack&lt;string&gt;sback;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">BrowserHistory</span>(string homepage) &#123;</span><br><span class="line">        sback.<span class="built_in">push</span>(homepage);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">(string url)</span> </span>&#123;</span><br><span class="line">        sback.<span class="built_in">push</span>(url);</span><br><span class="line">        <span class="keyword">while</span>(!sfor.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            sfor.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">string <span class="title">back</span><span class="params">(<span class="type">int</span> steps)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i &lt; steps &amp;&amp; sback.<span class="built_in">size</span>() &gt; <span class="number">1</span> ; i++)&#123;</span><br><span class="line">            <span class="comment">// 后退意味有更多空间可以前进</span></span><br><span class="line">            sfor.<span class="built_in">push</span>(sback.<span class="built_in">top</span>());</span><br><span class="line">            sback.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sback.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">string <span class="title">forward</span><span class="params">(<span class="type">int</span> steps)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; steps &amp;&amp; sfor.<span class="built_in">size</span>() &gt; <span class="number">0</span> ; i++)&#123;</span><br><span class="line">            <span class="comment">// 前进意味着有更多空间可以后退</span></span><br><span class="line">            sback.<span class="built_in">push</span>(sfor.<span class="built_in">top</span>());</span><br><span class="line">            sfor.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里返回的是 后退栈的顶部</span></span><br><span class="line">        <span class="keyword">return</span> sback.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your BrowserHistory object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * BrowserHistory* obj = new BrowserHistory(homepage);</span></span><br><span class="line"><span class="comment"> * obj-&gt;visit(url);</span></span><br><span class="line"><span class="comment"> * string param_2 = obj-&gt;back(steps);</span></span><br><span class="line"><span class="comment"> * string param_3 = obj-&gt;forward(steps);</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3><span id="1209-删除字符串中的所有相邻重复项">1209 删除字符串中的所有相邻重复项</span></h3><p>有很多种做法栈只是其中的一种</p><p>原题链接:<br><a href="https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string-ii/">https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string-ii/</a></p><ol><li>通过栈对于字符串中 字符的分布情况进行记录 根据栈所记录的字符信息 对原字符串进行修改得到答案</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    栈实现 s</span></span><br><span class="line"><span class="comment">    栈遍历 然后统计相同字符数等于k个时执行删除操作</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">removeDuplicates</span><span class="params">(string s, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt;stk;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i &lt; n ; i++)&#123;</span><br><span class="line">            <span class="comment">// 初始为空时 </span></span><br><span class="line">            <span class="comment">// 或者前后</span></span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">0</span> || s[i] != s[i - <span class="number">1</span>])&#123;</span><br><span class="line">                stk.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                stk.<span class="built_in">top</span>()++;</span><br><span class="line">                <span class="comment">// 符合相同长度要求 则直接从字符串中移除这k个字符</span></span><br><span class="line">                <span class="keyword">if</span>(stk.<span class="built_in">top</span>() == k)&#123;</span><br><span class="line">                    <span class="comment">// 准备删除这段字符所以直接出栈</span></span><br><span class="line">                    stk.<span class="built_in">pop</span>();</span><br><span class="line">                    <span class="comment">// erase 的做法 和 substr 是一样的 从首i 开始往后k个</span></span><br><span class="line">                    s.<span class="built_in">erase</span>(i - k + <span class="number">1</span>,k);        </span><br><span class="line">                    <span class="comment">// 相当于删除的部分 和原来直接拼接 然后再回头进行判断</span></span><br><span class="line">                    i = i - k;                </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="2"><li>将计数器和字符的都存储在栈中 则不需要修改字符串 只需要根据栈中结果重建串即可 (其实上面一种做法是完全相同的 不过这要引入了额外空间 但不用修改原串在代码上简单了一些)</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">removeDuplicates</span><span class="params">(string s, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// vector 代替栈在后面的实现过程中 会方便些</span></span><br><span class="line">        vector&lt;pair&lt;<span class="type">int</span>,<span class="type">char</span>&gt;&gt;stk;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(stk.<span class="built_in">empty</span>() || s[i] != stk.<span class="built_in">back</span>().second)&#123;</span><br><span class="line">                stk.<span class="built_in">push_back</span>(&#123;<span class="number">1</span>,s[i]&#125;);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                stk.<span class="built_in">back</span>().first++;</span><br><span class="line">                <span class="keyword">if</span>(stk.<span class="built_in">back</span>().first == k)&#123;</span><br><span class="line">                    <span class="comment">// 直接删除即可 不需要回退 </span></span><br><span class="line">                    <span class="comment">// 因为出栈 之前字符组就会回到栈顶 相当于连接的情况</span></span><br><span class="line">                    stk.<span class="built_in">pop_back</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        string ans = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> ss : stk)&#123;</span><br><span class="line">            ans += <span class="built_in">string</span>(ss.first,ss.second);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2><span id="hashmapx2f-hashset">Hashmap&#x2F; Hashset</span></h2><h3><span id="146-lru-cache">146 LRU Cache</span></h3><h3><span id="128-最长连续序列">128 最长连续序列</span></h3><p>原题链接:<br><a href="https://leetcode.cn/problems/longest-consecutive-sequence/">https://leetcode.cn/problems/longest-consecutive-sequence/</a></p><p>hash只是其中的一种解法 这个题算是高频题 还有很多其他解法</p><ol><li>hash 集合</li></ol><p>hash 记录所有元素<br>利用序列连续的性质 如果当前遍历的元素的前一个存在于hash中 则跳过 因为从该元素开始向后遍历的序列是不可能比前一个元素开始遍历序列的长度要长的   </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    O(n) 一次遍历 不排序 这个题的连续不包含相同</span></span><br><span class="line"><span class="comment">    hash</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestConsecutive</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt;hash;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x : nums)&#123;</span><br><span class="line">            hash.<span class="built_in">insert</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i &lt; nums.<span class="built_in">size</span>() ; i++)&#123;</span><br><span class="line">            <span class="type">int</span> cur = nums[i];</span><br><span class="line">            <span class="comment">// 这个if判断 可以优化很多</span></span><br><span class="line">            <span class="comment">// 只有当前一个数不存在的时候才需要遍历</span></span><br><span class="line">            <span class="comment">// 前一个如果存在 那一定会在之前进行遍历</span></span><br><span class="line">            <span class="keyword">if</span>(!hash.<span class="built_in">count</span>(cur - <span class="number">1</span>))&#123;</span><br><span class="line">                <span class="keyword">while</span>(hash.<span class="built_in">count</span>(cur))&#123;</span><br><span class="line">                    cur++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">            <span class="comment">// while 循环 cur 已经是答案的下一位了 不需要再加1</span></span><br><span class="line">            ans = <span class="built_in">max</span>(ans,cur - nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="2"><li>hash集合优化 记录右边界</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    hash 记录右边界 每次遍历直接取出右边界进行判断省去了遍历过程</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestConsecutive</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;hash;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x : nums)&#123;</span><br><span class="line">            <span class="comment">// 初始化每个数的右边界为 其zishen</span></span><br><span class="line">            hash[x] = x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x : nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!hash.<span class="built_in">count</span>(x - <span class="number">1</span>))&#123;</span><br><span class="line">                <span class="comment">// 取出当前数的右端点</span></span><br><span class="line">                <span class="type">int</span> right = hash[x];</span><br><span class="line">                <span class="comment">// 右边界 在hash 中存在 那么跟新该数的右边界</span></span><br><span class="line">                <span class="keyword">while</span>(hash.<span class="built_in">count</span>(right + <span class="number">1</span>) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    right++;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 更新该数的右节点 </span></span><br><span class="line">                hash[x] = right;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 更新答案</span></span><br><span class="line">                ans = <span class="built_in">max</span>(ans,right - x + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="3"><li>动态规划</li></ol><p>不使用count<br>其实下面这段语法是不够准确的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    动态规划</span></span><br><span class="line"><span class="comment">    hash 记录数以及当前对应的区间长度 不断通过左右数的区间长度组合成当前数的区间 并更新hash</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestConsecutive</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;hash;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x : nums)&#123;</span><br><span class="line">            <span class="comment">// 如果当前数没出过</span></span><br><span class="line">            <span class="keyword">if</span>(!hash[x])&#123;</span><br><span class="line">                <span class="comment">// 左边区间的长度</span></span><br><span class="line">                <span class="type">int</span> left = hash[x - <span class="number">1</span>];</span><br><span class="line">                <span class="comment">// 右边区间的长度</span></span><br><span class="line">                <span class="type">int</span> right = hash[x + <span class="number">1</span>];</span><br><span class="line">                <span class="comment">// 当前区间长度</span></span><br><span class="line">                <span class="type">int</span> curlen = left + right + <span class="number">1</span>;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans,curlen);</span><br><span class="line">                <span class="comment">// 表示以及遍历过了</span></span><br><span class="line">                hash[x] = <span class="number">-1</span>;</span><br><span class="line">                <span class="comment">// 更新左右区间的长度</span></span><br><span class="line">                hash[x - left] = curlen;</span><br><span class="line">                hash[x + right] = curlen;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>下面这段使用count会比较准确</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    动态规划</span></span><br><span class="line"><span class="comment">    hash 记录数以及当前对应的区间长度 不断通过左右数的区间长度组合成当前数的区间 并更新hash</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestConsecutive</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;hash;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x : nums)&#123;</span><br><span class="line">            <span class="comment">// 如果当前数没出过</span></span><br><span class="line">            <span class="comment">// 这个题 这里还是蛮坑的 如果用C++的话</span></span><br><span class="line">            <span class="comment">// hash[x - 1] hash[x + 1] 在C++如果找不到是默认直接插入</span></span><br><span class="line">            <span class="comment">// 这样如果直接用count判断就会出现问题</span></span><br><span class="line">            <span class="keyword">if</span>(!hash.<span class="built_in">count</span>(x))&#123;  </span><br><span class="line">                <span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">// 左边区间的长度 </span></span><br><span class="line">                <span class="keyword">if</span>(hash.<span class="built_in">find</span>(x - <span class="number">1</span>) != hash.<span class="built_in">end</span>())&#123;</span><br><span class="line">                    left = hash[x - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 右边区间的长度</span></span><br><span class="line">                <span class="keyword">if</span>(hash.<span class="built_in">find</span>(x + <span class="number">1</span>) != hash.<span class="built_in">end</span>())&#123;</span><br><span class="line">                    right = hash[x + <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 当前区间长度</span></span><br><span class="line">                <span class="type">int</span> curlen = left + right + <span class="number">1</span>;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans,curlen);</span><br><span class="line">                <span class="comment">// 表示以及遍历过了</span></span><br><span class="line">                hash[x] = <span class="number">-1</span>;</span><br><span class="line">                <span class="comment">// 更新左右区间的长度</span></span><br><span class="line">                hash[x - left] = curlen;</span><br><span class="line">                hash[x + right] = curlen;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3><span id="73-矩阵置零">73 矩阵置零</span></h3><p>原题链接:<br><a href="https://leetcode.cn/problems/set-matrix-zeroes/description/">https://leetcode.cn/problems/set-matrix-zeroes/description/</a></p><ol><li>非常数空间<br>O(m + n)<br>标记数组<br>hashMap 记录0的行列</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setZeroes</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> matrix.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="comment">// 行</span></span><br><span class="line">        <span class="type">int</span> [] row = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="comment">// 列</span></span><br><span class="line">        <span class="type">int</span> [] col = <span class="keyword">new</span> <span class="title class_">int</span>[m];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i  &lt;  n ; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span> ; j &lt; m ; j++)&#123; </span><br><span class="line">                <span class="keyword">if</span>(matrix[i][j] == <span class="number">0</span>)&#123;</span><br><span class="line">                    row[i] = <span class="number">1</span>;</span><br><span class="line">                    col[j] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i  &lt;  n ; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span> ; j &lt; m ; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(row[i] == <span class="number">1</span> || col[j] == <span class="number">1</span>)&#123;</span><br><span class="line">                    matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="2"><li>常数空间<br>非常麻烦</li></ol><h3><span id="380-o1-时间插入-删除和获取随机元素">380 O(1) 时间插入、删除和获取随机元素</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RandomizedSet</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  hash 记录所有元素的位置与下标 用作O(1) 删除与插入</span></span><br><span class="line"><span class="comment">     *  数组存储数 用于random查找</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 数组的最大大小 因为最多只会进行 2 * 10^5 操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> <span class="number">200010</span>;</span><br><span class="line">    <span class="comment">// val,idx</span></span><br><span class="line">    HashMap&lt;Integer,Integer&gt; hash;</span><br><span class="line">    <span class="type">Random</span> <span class="variable">random</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> [] q;</span><br><span class="line">    <span class="comment">// idx记录当前数组的范围</span></span><br><span class="line">    <span class="type">int</span> idx;</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RandomizedSet</span><span class="params">()</span> &#123;</span><br><span class="line">        hash = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        idx = -<span class="number">1</span>;</span><br><span class="line">        q = <span class="keyword">new</span> <span class="title class_">int</span>[N];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(hash.containsKey(val))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        idx++;</span><br><span class="line"></span><br><span class="line">        q[idx] = val;</span><br><span class="line">        hash.put(val,idx);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移除</span></span><br><span class="line">    <span class="comment">// 不能仅仅是移除元素 而是在移除元素后 将当前数组最后位置的元素 补充在被删除数的位置</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(!hash.containsKey(val))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取要删除元素的位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">loc</span> <span class="operator">=</span> hash.getOrDefault(val,<span class="number">0</span>);</span><br><span class="line">        hash.remove(val);</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里的这一步判断是必须的 </span></span><br><span class="line">        <span class="comment">// 因为如果删除数 刚好就是idx位置的那个 如果不跳过的话相当于i将该数重新插入回了hash 就会导致出错</span></span><br><span class="line">        <span class="keyword">if</span>(loc != idx)&#123;</span><br><span class="line">            hash.put(q[idx],loc);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将要删除的数 替换为数组末尾的数</span></span><br><span class="line">        q[loc] = q[idx];</span><br><span class="line">        idx--;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 随机返回</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getRandom</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> q[random.nextInt(idx + <span class="number">1</span>)];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your RandomizedSet object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * RandomizedSet obj = new RandomizedSet();</span></span><br><span class="line"><span class="comment"> * boolean param_1 = obj.insert(val);</span></span><br><span class="line"><span class="comment"> * boolean param_2 = obj.remove(val);</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.getRandom();</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3><span id="49-字母异位词分组">49 字母异位词分组</span></h3><p>原题链接:<br><a href="https://leetcode.cn/problems/group-anagrams/">https://leetcode.cn/problems/group-anagrams/</a></p><ol><li>排序<br>将排序后的单词作为键值 使用哈希进行存储 不断更新答案</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 字母相同但顺序不同的单词称为字母异位词</span></span><br><span class="line"><span class="comment">     * 将排序后的字符串作为键值 然后遍历 根据键值不断插入</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">groupAnagrams</span><span class="params">(String[] strs)</span> &#123;</span><br><span class="line">        HashMap&lt;String, List&lt;String&gt;&gt; hash = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span>  ss : strs)&#123;</span><br><span class="line">            <span class="type">char</span>[] array = ss.toCharArray();</span><br><span class="line">            Arrays.sort(array);</span><br><span class="line">            <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(array);</span><br><span class="line">            List&lt;String&gt; list = hash.getOrDefault(<span class="keyword">new</span> <span class="title class_">String</span>(array), <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;());</span><br><span class="line">            <span class="comment">// 更新 字母异位词的集合</span></span><br><span class="line">            list.add(ss);</span><br><span class="line">            <span class="comment">// 更新答案</span></span><br><span class="line">            hash.put(key, list);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;String&gt;&gt;(hash.values()) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="2"><li>计数</li></ol><p>本质上和排序一样 都是利用异位词内字符出现次数相同的性质</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  计数</span></span><br><span class="line"><span class="comment">     *  根据题意 异位词中每个字母出现的次数一定相同 使用数组进行记录 每个单词出现字母的次数作为键值</span></span><br><span class="line"><span class="comment">     *  由于数组存的是地址 还是要把数组进行编码转换成相应的字符串 作为键值进行存储</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">groupAnagrams</span><span class="params">(String[] strs)</span> &#123;</span><br><span class="line">        <span class="comment">// 键值---以字符串形式表现的不同的字符出现的个数  以及 每个键值对应的由异位词组合的字符串集合</span></span><br><span class="line">        HashMap&lt;String, List&lt;String&gt;&gt; hash = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> ss : strs)&#123;</span><br><span class="line">            <span class="comment">// 记录每个位字符出现的次数</span></span><br><span class="line">            <span class="type">int</span> [] count = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">var</span> c  : ss.toCharArray())&#123;</span><br><span class="line">                count[c - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 进行编码 生成key</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; <span class="number">26</span> ; i++)&#123;</span><br><span class="line">                key += (<span class="type">char</span>) (<span class="string">&#x27;a&#x27;</span> + i) ;</span><br><span class="line">                key += count[i];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            List&lt;String&gt; list = hash.getOrDefault(key,<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;());</span><br><span class="line">            list.add(ss);</span><br><span class="line"></span><br><span class="line">            hash.put(key,list);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;String&gt;&gt;(hash.values());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3><span id="350-两个数组的交集ii">350 两个数组的交集Ⅱ</span></h3><p>原题链接:<br><a href="https://leetcode.cn/problems/intersection-of-two-arrays-ii/description/">https://leetcode.cn/problems/intersection-of-two-arrays-ii/description/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] intersect(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2) &#123;</span><br><span class="line">        HashMap&lt;Integer,Integer&gt; hash = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> x : nums1)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> hash.getOrDefault(x,<span class="number">0</span>);</span><br><span class="line">            count++;</span><br><span class="line">            hash.put(x,count);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> [] ans = <span class="keyword">new</span> <span class="title class_">int</span>[Math.min(nums1.length,nums2.length)]; </span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> x : nums2)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> hash.getOrDefault(x,<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span>(count &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                count--;</span><br><span class="line">                ans[k++] = x;</span><br><span class="line">                </span><br><span class="line">                hash.put(x,count);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> Arrays.copyOfRange(ans,<span class="number">0</span>,k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="299-猜数字游戏">299 猜数字游戏</span></h3><p>根据题意 哈希 + 模拟</p><ol><li>复杂的哈希解法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getHint</span><span class="params">(String secret, String guess)</span> &#123;</span><br><span class="line">        <span class="type">char</span> [] sarr = secret.toCharArray();</span><br><span class="line">        <span class="type">char</span> [] garr = guess.toCharArray();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// char -&gt; id出现次数</span></span><br><span class="line">        HashMap&lt;Character, Integer&gt; c2i = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> sarr.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>  ; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">tmp</span> <span class="operator">=</span> c2i.getOrDefault(sarr[i],<span class="number">0</span>);</span><br><span class="line">            tmp++;</span><br><span class="line">            c2i.put(sarr[i],tmp);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第一次匹配数和位置 都猜对</span></span><br><span class="line">        <span class="comment">// 否则会导致 数猜对答案 对 数和位置都猜对的答案造成干扰</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; n ; i++)&#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> sarr[i];</span><br><span class="line">            <span class="keyword">if</span>(ch == garr[i])&#123;</span><br><span class="line">                a++;</span><br><span class="line">                <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> c2i.getOrDefault(ch,<span class="number">0</span>);</span><br><span class="line">                tmp--;</span><br><span class="line">                c2i.put(ch,tmp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第二次再找数猜对的</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i  &lt; n ; i++)&#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> garr[i];</span><br><span class="line">            <span class="keyword">if</span>(sarr[i] == ch)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(!c2i.containsKey(ch))&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> c2i.getOrDefault(ch,<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span>(tmp &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                b++;</span><br><span class="line">                tmp--;</span><br><span class="line">                c2i.put(ch,tmp);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> a + <span class="string">&quot;A&quot;</span> + b + <span class="string">&quot;B&quot;</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="2"><li>优化的简单写法<br>主要是理解 数字猜对 但位置不对数 其实就是除了数字和位置都相同的数字外两串字符串中出现数的最小值</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getHint</span><span class="params">(String secret, String guess)</span> &#123;</span><br><span class="line">        <span class="type">char</span> [] s1 = secret.toCharArray();</span><br><span class="line">        <span class="type">char</span> [] s2 = guess.toCharArray();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s1.length;  </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 哈希 记录两个串中不同数出现的次数</span></span><br><span class="line">        <span class="type">int</span> [] cnt1 = <span class="keyword">new</span> <span class="title class_">int</span> [<span class="number">10</span>];</span><br><span class="line">        <span class="type">int</span> [] cnt2 = <span class="keyword">new</span> <span class="title class_">int</span> [<span class="number">10</span>]; </span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; n ; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s1[i] == s2[i])&#123;</span><br><span class="line">                a++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cnt1[s1[i] - <span class="string">&#x27;0&#x27;</span>]++;</span><br><span class="line">                cnt2[s2[i] - <span class="string">&#x27;0&#x27;</span>]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; <span class="number">10</span> ; i++)&#123;</span><br><span class="line">            b += Math.min(cnt1[i],cnt2[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> a + <span class="string">&quot;A&quot;</span> + b + <span class="string">&quot;B&quot;</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2><span id="heap">Heap</span></h2><h3><span id="973-最接近原点的-k-个点">973. 最接近原点的 K 个点</span></h3><p>原题链接:<br><a href="https://leetcode.cn/problems/k-closest-points-to-origin/description/">https://leetcode.cn/problems/k-closest-points-to-origin/description/</a></p><p>堆的基本应用 主要还是语法题 练习java的语法 heap可以直接用lambda传入比较器还是比较方便的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    <span class="type">int</span> v;</span><br><span class="line"></span><br><span class="line">    Node(<span class="type">int</span> a, <span class="type">int</span> b)&#123;</span><br><span class="line">        <span class="built_in">this</span>.a = a;</span><br><span class="line">        <span class="built_in">this</span>.b = b;</span><br><span class="line">        <span class="built_in">this</span>.v = a * a + b * b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] kClosest(<span class="type">int</span>[][] points, <span class="type">int</span> k) &#123;</span><br><span class="line">        PriorityQueue&lt;Node&gt;heap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(((o1, o2) -&gt; o1.v - o2.v ));</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> points.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n ; i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> points[i][<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> points[i][<span class="number">1</span>];</span><br><span class="line">            heap.add(<span class="keyword">new</span> <span class="title class_">Node</span>(a,b));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> [][] ans = <span class="keyword">new</span> <span class="title class_">int</span>[k][<span class="number">2</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; k ; i++)&#123;</span><br><span class="line">            <span class="type">var</span> <span class="variable">node</span> <span class="operator">=</span> heap.poll();</span><br><span class="line">            ans[i][<span class="number">0</span>] = node.a;</span><br><span class="line">            ans[i][<span class="number">1</span>] = node.b;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="347-前k个高频元素">347 前k个高频元素</span></h3><p>原题链接:<br><a href="https://leetcode.cn/problems/top-k-frequent-elements/">https://leetcode.cn/problems/top-k-frequent-elements/</a></p><p>基本是对 堆语法的考察</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] topKFrequent(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="comment">// 值 --- 出现的次数</span></span><br><span class="line">        <span class="type">var</span> <span class="variable">hash</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer,Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> x : nums)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> hash.getOrDefault(x,<span class="number">0</span>);</span><br><span class="line">            v++;</span><br><span class="line">            hash.put(x,v);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 存符合条件的k个数 存键值 通过hash进行排序 (非常巧妙这种做法)</span></span><br><span class="line">        PriorityQueue&lt;Integer&gt;heap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(((o1, o2) -&gt; hash.get(o1) - hash.get(o2)));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> e : hash.entrySet())&#123;</span><br><span class="line">            <span class="keyword">if</span>(heap.size() &gt;= k)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">key</span> <span class="operator">=</span> heap.peek();</span><br><span class="line">                <span class="keyword">if</span>(hash.get(key) &lt; e.getValue())&#123;</span><br><span class="line">                    heap.remove();</span><br><span class="line">                    heap.add(e.getKey());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                heap.add(e.getKey());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> [] ans = <span class="keyword">new</span> <span class="title class_">int</span>[k];</span><br><span class="line">        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!heap.isEmpty())&#123;</span><br><span class="line">            ans[idx++] = heap.poll(); </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">topKFrequent</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;hash;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt;hs;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;ans;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x : nums)&#123;</span><br><span class="line">            hash[x]++;</span><br><span class="line">            <span class="keyword">if</span>(hs.<span class="built_in">contains</span>(x))&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            hs.<span class="built_in">insert</span>(x);</span><br><span class="line">            ans.<span class="built_in">push_back</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">sort</span>(ans.<span class="built_in">begin</span>(),ans.<span class="built_in">end</span>(),[&amp;](<span class="type">int</span> a,<span class="type">int</span> b)-&gt;<span class="type">bool</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> hash[a] &gt; hash[b];</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(ans.<span class="built_in">begin</span>(),ans.<span class="built_in">begin</span>() + k) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3><span id="23-合并k个升序链表">23 合并k个升序链表</span></h3><p>原题链接:<br><a href="https://leetcode.cn/problems/merge-k-sorted-lists/">https://leetcode.cn/problems/merge-k-sorted-lists/</a></p><p>堆(是其中的一种解法)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeKLists</span><span class="params">(ListNode[] lists)</span> &#123;</span><br><span class="line">        <span class="comment">// 最小堆 根据当前节点进行排序</span></span><br><span class="line">        PriorityQueue&lt;ListNode&gt;heap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((o1,o2) -&gt;&#123;</span><br><span class="line">            <span class="keyword">return</span> o1.val - o2.val;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> node : lists)&#123;</span><br><span class="line">            <span class="keyword">if</span>(node != <span class="literal">null</span>)&#123;</span><br><span class="line">                heap.offer(node);</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> dummy;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!heap.isEmpty())&#123;</span><br><span class="line">            <span class="type">var</span> <span class="variable">node</span> <span class="operator">=</span> heap.poll();</span><br><span class="line">            cur.next = node;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">            <span class="keyword">if</span>(node.next != <span class="literal">null</span>)&#123;</span><br><span class="line">                heap.offer(cur.next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3><span id="264-丑数ii">264 丑数Ⅱ</span></h3><p>原题链接:<br><a href="https://leetcode.cn/problems/ugly-number-ii/">https://leetcode.cn/problems/ugly-number-ii/</a></p><p>优先队列(不止这一种做法) 丑数也是leetcode里面的一个经典题型了 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 打表</span></span><br><span class="line"><span class="comment"> 对于任意一个丑数 x，其与任意的质因数 (2、3、5)相乘，结果 (2x、3x、5x) 仍为丑数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> <span class="number">1690</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> [] ans = <span class="keyword">new</span> <span class="title class_">int</span>[N];</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> [] nums = <span class="keyword">new</span> <span class="title class_">long</span>[]&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// 最小堆</span></span><br><span class="line">        <span class="comment">// 这个点非常的坑 </span></span><br><span class="line">        <span class="comment">// Long 这里排序 不能用 o1 - o2 因为会存在溢出问题 一定要统一使用 o1.compareTo(o2)</span></span><br><span class="line">        PriorityQueue&lt;Long&gt;pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((o1, o2) -&gt; o1.compareTo(o2));</span><br><span class="line">        <span class="comment">// 存储出现过的元素 防止再次入堆</span></span><br><span class="line">        HashSet&lt;Long&gt; hash = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        pq.offer(<span class="number">1L</span>);</span><br><span class="line">        hash.add(<span class="number">1L</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; N ; i++)&#123;</span><br><span class="line">            <span class="type">var</span> <span class="variable">x</span> <span class="operator">=</span> pq.poll();</span><br><span class="line">            ans[i] = x.intValue();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">var</span> num : nums)&#123;</span><br><span class="line">                <span class="type">long</span> <span class="variable">t</span> <span class="operator">=</span> num * x;</span><br><span class="line">                <span class="keyword">if</span>(!hash.contains(t))&#123;</span><br><span class="line">                    pq.offer(t);</span><br><span class="line">                    hash.add(t);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">nthUglyNumber</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ans[n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3><span id="88-合并两个有序数组">88 合并两个有序数组</span></h3><p>原题链接:<br><a href="https://leetcode.cn/problems/merge-sorted-array/">https://leetcode.cn/problems/merge-sorted-array/</a></p><p>这个题堆可以做 但不是一种的好的解法<br>双指针才是最优解 这里只展示堆的做法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span> m, <span class="type">int</span>[] nums2, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        PriorityQueue&lt;Integer&gt;pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((o1,o2)-&gt;o1 - o2);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; m ; i++)&#123;</span><br><span class="line">            pq.add(nums1[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; n ; i++)&#123;</span><br><span class="line">            pq.add(nums2[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; m + n ; i++)&#123;</span><br><span class="line">            nums1[i] = pq.poll();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3><span id="692-前k个高频单词">692 前k个高频单词</span></h3><p>原题链接:<br><a href="https://leetcode.cn/problems/top-k-frequent-words/description/">https://leetcode.cn/problems/top-k-frequent-words/description/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">topKFrequent</span><span class="params">(String[] words, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        HashMap&lt;String,Integer&gt; hash = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> s : words)&#123;</span><br><span class="line">            <span class="type">var</span> <span class="variable">c</span> <span class="operator">=</span> hash.getOrDefault(s,<span class="number">0</span>);</span><br><span class="line">            c++;</span><br><span class="line">            hash.put(s,c);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 大根堆</span></span><br><span class="line">        PriorityQueue&lt;String&gt;pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((o1,o2)-&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span>(hash.get(o2) == hash.get(o1))&#123;</span><br><span class="line">                <span class="comment">// 字典序 直接用compareTo 比较</span></span><br><span class="line">                <span class="keyword">return</span> o1.compareTo(o2);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> hash.get(o2) - hash.get(o1);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> s : hash.keySet())&#123;</span><br><span class="line">            pq.add(s);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i  &lt; k ; i++)&#123;</span><br><span class="line">            ans.add(pq.poll());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3><span id="378-有序矩阵中第k小的元素">378 有序矩阵中第k小的元素</span></h3><p>个人认为是堆中一道很好的题</p><p>原题链接:<br><a href="https://leetcode.cn/problems/kth-smallest-element-in-a-sorted-matrix/">https://leetcode.cn/problems/kth-smallest-element-in-a-sorted-matrix/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    根据题意最小的元素一定在左上角</span></span><br><span class="line"><span class="comment">    先将第一列的元素以及位置加入堆中 </span></span><br><span class="line"><span class="comment">    每次都比较第一列以及第一行右边的一个元素 这样就可以保证堆中始终存放着全局的最小元素</span></span><br><span class="line"><span class="comment">    第一行如果选完了就往下选一行 直到出堆k个数 就可以得到答案</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">    <span class="type">int</span> v;</span><br><span class="line">    Node(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> v)&#123;</span><br><span class="line">        <span class="built_in">this</span>.x = x;</span><br><span class="line">        <span class="built_in">this</span>.y = y;</span><br><span class="line">        <span class="built_in">this</span>.v = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">kthSmallest</span><span class="params">(<span class="type">int</span>[][] matrix, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        PriorityQueue&lt;Node&gt;pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((o1,o2)-&gt;o1.v - o2.v);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> matrix.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="comment">// 加入 第1列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n ; i++)&#123;</span><br><span class="line">            pq.offer(<span class="keyword">new</span> <span class="title class_">Node</span>(i,<span class="number">0</span>,matrix[i][<span class="number">0</span>]));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// pq.poll();</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; k - <span class="number">1</span> ; i++)&#123;</span><br><span class="line">            <span class="type">var</span> <span class="variable">node</span> <span class="operator">=</span> pq.poll();</span><br><span class="line">            <span class="comment">// System.out.println(i);</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> node.x , y = node.y , v = node.v;</span><br><span class="line">            <span class="keyword">if</span>(y + <span class="number">1</span> &lt; m)&#123;</span><br><span class="line">                pq.offer(<span class="keyword">new</span> <span class="title class_">Node</span>(x,y + <span class="number">1</span>,matrix[x][y + <span class="number">1</span>]));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 下面这一行其实是没必要的 </span></span><br><span class="line">            <span class="comment">// 行中取满后 由于我们已经把第一列加入到堆中了 不需要生动去调整行</span></span><br><span class="line">            <span class="comment">// 直接从堆中自动取出下一行的元素即可</span></span><br><span class="line">            <span class="comment">// else&#123;</span></span><br><span class="line">            <span class="comment">//     y = 1;</span></span><br><span class="line">            <span class="comment">//     x++;</span></span><br><span class="line">            <span class="comment">//     pq.add(new Node(x,y,matrix[x][y + 1]));</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> pq.poll().v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3><span id="295-数据流的中位数">295 数据流的中位数</span></h3><p>原题链接:<br><a href="https://leetcode.cn/problems/find-median-from-data-stream/description/">https://leetcode.cn/problems/find-median-from-data-stream/description/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    双堆</span></span><br><span class="line"><span class="comment">    一个大根堆l 维护数据流左半  一个小根堆r 维护数据流右半</span></span><br><span class="line"><span class="comment">    计算中间值时 取出 l的堆顶 和 r的堆顶即可</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    l 存储奇数值 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MedianFinder</span> &#123;</span><br><span class="line">    <span class="comment">// 大根堆</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> PriorityQueue&lt;Integer&gt;l;</span><br><span class="line">    <span class="comment">// 小根堆</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> PriorityQueue&lt;Integer&gt;r;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MedianFinder</span><span class="params">()</span> &#123;</span><br><span class="line">        l = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;Integer&gt;((o1,o2)-&gt;o2 - o1);</span><br><span class="line">        r = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;Integer&gt;((o1,o2)-&gt;o1 - o2);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addNum</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">s1</span> <span class="operator">=</span> l.size();</span><br><span class="line">        <span class="type">int</span> <span class="variable">s2</span> <span class="operator">=</span> r.size();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 偶数的情况 </span></span><br><span class="line">        <span class="keyword">if</span>(s1 == s2)&#123;</span><br><span class="line">            <span class="comment">// r 右半集合为空 或者 num 比 r的最小值小 则证明当前应存储与左半集合</span></span><br><span class="line">            <span class="keyword">if</span>(r.isEmpty() ||  num &lt;= r.peek())&#123;</span><br><span class="line">                l.offer(num);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 根据定义 左半维持的奇数的情况</span></span><br><span class="line">                l.offer(r.poll());</span><br><span class="line">                r.offer(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 根据定义 s1 != s2 只可能是 s1 &gt; s2 且 s1为奇数</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// l的最大值 如果比 num小 那么直接放入右半边接口</span></span><br><span class="line">            <span class="keyword">if</span>(l.peek() &lt;= num)&#123;</span><br><span class="line">                r.offer(num);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 与上述调整相同 防止出现l与r差两个元素情况 调整完后s1 == s2</span></span><br><span class="line">                r.offer(l.poll());</span><br><span class="line">                l.offer(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">findMedian</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">s1</span> <span class="operator">=</span> l.size();</span><br><span class="line">        <span class="type">int</span> <span class="variable">s2</span> <span class="operator">=</span> r.size();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 两者大小相等那么 直接根据定义返回均值即可</span></span><br><span class="line">        <span class="keyword">if</span>(s1 == s2)&#123;</span><br><span class="line">            <span class="keyword">return</span> (l.peek() + r.peek()) / <span class="number">2.0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 奇数的情况直接返回中间数</span></span><br><span class="line">            <span class="keyword">return</span> l.peek();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MedianFinder object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MedianFinder obj = new MedianFinder();</span></span><br><span class="line"><span class="comment"> * obj.addNum(num);</span></span><br><span class="line"><span class="comment"> * double param_2 = obj.findMedian();</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3><span id="767-重构字符串">767 重构字符串</span></h3><p>原题链接:<br><a href="https://leetcode.cn/problems/reorganize-string/description/">https://leetcode.cn/problems/reorganize-string/description/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reorganizeString</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> [] count = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="type">var</span> <span class="variable">ss</span> <span class="operator">=</span> s.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span>  ss.length;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> c:ss)&#123;</span><br><span class="line">            count[c - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">            <span class="keyword">if</span>(count[c - <span class="string">&#x27;a&#x27;</span>] &gt; (n + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 大根堆 根据字符的出现次数排序</span></span><br><span class="line">        PriorityQueue&lt;Character&gt;pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(((o1, o2) -&gt; count[o2.charValue() - <span class="string">&#x27;a&#x27;</span>] - count[o1.charValue() - <span class="string">&#x27;a&#x27;</span>]));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">var</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span> ; c &lt;= <span class="string">&#x27;z&#x27;</span> ; c++)&#123;</span><br><span class="line">            <span class="comment">// 只将 出现次数大于0 入队 提高效率</span></span><br><span class="line">            <span class="keyword">if</span>(count[c - <span class="string">&#x27;a&#x27;</span>] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                pq.add(c);   </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(pq.size() &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="type">var</span> <span class="variable">letter1</span> <span class="operator">=</span> pq.poll();</span><br><span class="line">            <span class="type">var</span> <span class="variable">letter2</span> <span class="operator">=</span> pq.poll();</span><br><span class="line">            sb.append(letter1);</span><br><span class="line">            sb.append(letter2);</span><br><span class="line">            count[letter1 - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">            count[letter2 - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">            <span class="keyword">if</span>(count[letter1 - <span class="string">&#x27;a&#x27;</span>] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                pq.add(letter1);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(count[letter2 - <span class="string">&#x27;a&#x27;</span>] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                pq.add(letter2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(pq.size() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            sb.append(pq.poll());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1><span id="二分">二分</span></h1><h3><span id="34-在排序数组中查找元素的第一个和最后一个位置">34 在排序数组中查找元素的第一个和最后一个位置</span></h3><p>原题链接:<br><a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">查找元素x的第一个位置和最后一个位置 即</span></span><br><span class="line"><span class="comment">1.&gt;=x 的第一个位置</span></span><br><span class="line"><span class="comment">2.&gt;=(x + 1) 的第一个位置前面的的一个位置</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] searchRange(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> lower_bound(nums,target);</span><br><span class="line">        <span class="keyword">if</span>(a &gt;= nums.length || nums[a] != target)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span> [] &#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> lower_bound(nums,target + <span class="number">1</span>) - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// a 存在那么b一定存在 因为大不了 a == b</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span> [] &#123;a,b&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// &gt;= </span></span><br><span class="line">    <span class="comment">// 闭区间写法 [l,r]</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lower_bound</span><span class="params">(<span class="type">int</span> [] arr, <span class="type">int</span> x)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span> , r = arr.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l + r &gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(arr[mid] &gt;= x)&#123;</span><br><span class="line">                <span class="comment">// l x mid r</span></span><br><span class="line">                <span class="comment">// [l , mid - 1]</span></span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// l mid x r</span></span><br><span class="line">                <span class="comment">// [mid + 1 , r]</span></span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1><span id="双指针">双指针</span></h1><p>常见双指针算法分为三类，同向（即两个指针都相同一个方向移动），背向（两个指针从相同或者相邻的位置出发，背向移动直到其中一根指针到达边界为止），相向（两个指针从两边出发一起向中间移动直到两个指针</p><h2><span id="背向双指针">背向双指针</span></h2>]]></content>
      
      
      <categories>
          
          <category> algo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>lambda</title>
      <link href="/2023/08/18/algoSummary/lambda/"/>
      <url>/2023/08/18/algoSummary/lambda/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2><span id="c">C++</span></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    lambda 直接表示函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在函数内定义</span></span><br><span class="line">function&lt;<span class="type">int</span>(<span class="type">int</span>,<span class="type">int</span>,<span class="type">int</span>,<span class="type">int</span>)&gt; get = [&amp;](<span class="type">int</span> x1,<span class="type">int</span> y1,<span class="type">int</span> x2,<span class="type">int</span> y2) -&gt; <span class="type">int</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为了不出错 直接写成 这样也好记一些</span></span><br><span class="line"><span class="keyword">auto</span> get = [&amp;](<span class="type">int</span> x1,<span class="type">int</span> y1,<span class="type">int</span> x2,<span class="type">int</span> y2) -&gt; <span class="type">int</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等于在函数外再定义一个 </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> x1,<span class="type">int</span> y1,<span class="type">int</span> x2,<span class="type">int</span> y2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    遇到结构体且无返回值的情况时 就尽量不要用auto了 否则容易出问题</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">function&lt;<span class="type">void</span>(TreeNode*)&gt; dfs = [&amp;](TreeNode* root) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> lambda </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode198打家劫舍</title>
      <link href="/2023/08/18/leetcode/leetcode198%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/"/>
      <url>/2023/08/18/leetcode/leetcode198%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>原题链接:<br><a href="https://leetcode.cn/problems/house-robber/description/">https://leetcode.cn/problems/house-robber/description/</a></p><h2><span id="解法1">解法1</span></h2><p>动态规划 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  </span></span><br><span class="line"><span class="comment">    状态表示 f[i] 表示从前i家偷的最大值  注意这里的i表示 前i 这对后续的状态转移的理解很关键</span></span><br><span class="line"><span class="comment">    状态计算 -&gt; 以最后一家为界:</span></span><br><span class="line"><span class="comment">    偷: f[i] = f[i - 2] + nums[i]  </span></span><br><span class="line"><span class="comment">    根据题目要求则只能从前 i-2 家偷的最大值转移而来 -&gt; f[i - 2] + nums[i] </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    不偷: f[i] = f[i - 1]  则可以直接由上一家转移而来 </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    即 f[i] = max(f[i - 1] , f[i - 2] + nums[i]) </span></span><br><span class="line"><span class="comment">    但这样会产生负数下标 </span></span><br><span class="line"><span class="comment">    注意由于f[i]  可以理解存储的值的方式 那么可以直接把 f[i] 对应的全部 + 2 j 即规避了初始化问题</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 这种情况 不用考虑边界会更加简洁</span></span><br><span class="line">        <span class="type">int</span> f[n + <span class="number">2</span>];</span><br><span class="line">        <span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="keyword">sizeof</span> f);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i &lt; n ; i++)&#123;</span><br><span class="line">            f[i + <span class="number">2</span>] = <span class="built_in">max</span>(f[i + <span class="number">1</span>],f[i] + nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> f[n + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2><span id="扩展-环形打家劫舍-leetcode213">扩展: 环形打家劫舍 leetcode213</span></h2><p>原题链接:<br><a href="https://leetcode.cn/problems/house-robber-ii/description/">https://leetcode.cn/problems/house-robber-ii/description/</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    动态规划</span></span><br><span class="line"><span class="comment">    相较于198 多了 环形的条件 主要影响头尾的判断 记录房屋为h</span></span><br><span class="line"><span class="comment">    h[0] 选了 则 h[n - 1] 不能选    反之同理    </span></span><br><span class="line"><span class="comment">    而h[1] --- h[n - 2] 的情况是与198 完全相同的</span></span><br><span class="line"><span class="comment">    由于h[0] 与 h[n - 1] 只有两种情况</span></span><br><span class="line"><span class="comment">    那么不妨走两遍 取最大值即为本题答案</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    1. 选h[0]时 -&gt; f[0] = nums[0] 此时只用算 2 --- n-2</span></span><br><span class="line"><span class="comment">        注意不是 1 --- n-2 因为根据题目相同要求  0 与 1 也是相邻的所以也是不能选的 所以直接从2开始</span></span><br><span class="line"><span class="comment">    2. 不选h[0] 时 f[0] = 0 此时只用算 1 --- n-1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> f1[n + <span class="number">2</span>],f2[n + <span class="number">2</span>];</span><br><span class="line">        <span class="built_in">memset</span>(f1,<span class="number">0</span>,<span class="keyword">sizeof</span> f1);</span><br><span class="line">        <span class="built_in">memset</span>(f2,<span class="number">0</span>,<span class="keyword">sizeof</span> f2);</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 情况1 </span></span><br><span class="line">        <span class="comment">// f1[0] = nums[0];  注意这样写时没有意义的 因为根据定义nums[0] 是必须要加的</span></span><br><span class="line">        <span class="comment">// 从i = 2 开始其实是算不到f1[0]的 没有意义</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span> ; i &lt; n - <span class="number">1</span>; i++)&#123;</span><br><span class="line">            f1[i + <span class="number">2</span>] = <span class="built_in">max</span>(f1[i + <span class="number">1</span>] , f1[i] + nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 情况2 </span></span><br><span class="line">        f2[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span> ; i &lt; n ; i++)&#123;</span><br><span class="line">            f2[i + <span class="number">2</span>] = <span class="built_in">max</span>(f2[i + <span class="number">1</span>], f2[i] + nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(f1[n] + nums[<span class="number">0</span>],f2[n + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode1444-切披萨的方案</title>
      <link href="/2023/08/17/leetcode/leetcode1444-%E5%88%87%E6%8A%AB%E8%90%A8%E7%9A%84%E6%96%B9%E6%A1%88/"/>
      <url>/2023/08/17/leetcode/leetcode1444-%E5%88%87%E6%8A%AB%E8%90%A8%E7%9A%84%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>原题链接:<br><a href="https://leetcode.cn/problems/number-of-ways-of-cutting-a-pizza/">https://leetcode.cn/problems/number-of-ways-of-cutting-a-pizza/</a></p><p>非常好的一道题 尤其整个将子问题划分的思想可以说是非常经典了 </p><h2><span id="分析过程">分析过程</span></h2><img src="/2023/08/17/leetcode/leetcode1444-%E5%88%87%E6%8A%AB%E8%90%A8%E7%9A%84%E6%96%B9%E6%A1%88/notes.jpg" style="zoom:80%"><h2><span id="代码">代码</span></h2><h3><span id="记忆化搜索-递归">记忆化搜索 - 递归</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">ways</span><span class="params">(vector&lt;string&gt;&amp; pizza, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        <span class="type">int</span> m = pizza.<span class="built_in">size</span>() , n = pizza[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> s[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">memset</span>(s,<span class="number">0</span>,<span class="keyword">sizeof</span> s);</span><br><span class="line">        <span class="comment">// 计算前缀和数组 用于判断是否存在苹果即是否可切</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i &lt; m ; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span> ; j &lt; n ; j++)&#123;</span><br><span class="line">                s[i + <span class="number">1</span>][j + <span class="number">1</span>] = s[i + <span class="number">1</span>][j] + s[i][j + <span class="number">1</span>] - s[i][j] + (pizza[i][j] &amp; <span class="number">1</span>) ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取前缀和数组 (x1,y1,x2,y2) 区域的值</span></span><br><span class="line">        function&lt;<span class="type">int</span>(<span class="type">int</span>,<span class="type">int</span>,<span class="type">int</span>,<span class="type">int</span>)&gt; get = [&amp;](<span class="type">int</span> x1,<span class="type">int</span> y1,<span class="type">int</span> x2,<span class="type">int</span> y2) -&gt; <span class="type">int</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> s[x2][y2] - s[x2][y1] - s[x1][y2] + s[x1][y1];</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> memo[k][m][n];</span><br><span class="line">        <span class="comment">// -1 表示没有计算过</span></span><br><span class="line">        <span class="built_in">memset</span>(memo,<span class="number">-1</span>,<span class="keyword">sizeof</span> memo);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// c i j : 剩余可切的刀数 (i,j) 当前矩阵左上角的位置</span></span><br><span class="line">        function&lt;<span class="type">int</span>(<span class="type">int</span>,<span class="type">int</span>,<span class="type">int</span>)&gt; dfs = [&amp;](<span class="type">int</span> c,<span class="type">int</span> i, <span class="type">int</span> j) -&gt; <span class="type">int</span>&#123;</span><br><span class="line">            <span class="comment">// 递归边界 无法再切</span></span><br><span class="line">            <span class="keyword">if</span>(c == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">// 如果当前区域有一个 苹果 则满足条件 直接分掉 可以算是一种分法</span></span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">get</span>(i,j,m,n) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">            &#125;            </span><br><span class="line"></span><br><span class="line">            <span class="comment">// 定义为引用 因为要同步在计算过程中更新memo 的状态</span></span><br><span class="line">            <span class="type">int</span> &amp;res =  memo[c][i][j];</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(res != <span class="number">-1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">             <span class="comment">// 开始切 左上角是已经分好 因此整体往右下进行枚举(程序中的坐标顶点在左上位置)</span></span><br><span class="line">            <span class="comment">// 垂直切 枚举j2</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j2 = j;j2 &lt; n ; j2++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">get</span>(i,j,m,j2))&#123;</span><br><span class="line">                    res = (res + <span class="built_in">dfs</span>(c- <span class="number">1</span>,i,j2)) % MOD;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i2 = i ; i2 &lt; m ; i2++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">get</span>(i,j,i2,n))&#123;</span><br><span class="line">                    res = (res + <span class="built_in">dfs</span>(c<span class="number">-1</span>,i2,j)) % MOD;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(k - <span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algo </category>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前缀和 </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 记忆化搜搜 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>经典DP问题</title>
      <link href="/2023/04/23/algoDP/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
      <url>/2023/04/23/algoDP/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>最为基础的DP模板 但真的无论过了多久都会忘掉</p><h2><span id="背包问题">背包问题</span></h2><h3><span id="01背包问题">01背包问题</span></h3><p>最基础的DP问题 选择模型 </p><p>f[i][j] 表示选前i个物品 体积不超过j的物品的最大价值<br>不选当前物品的集合为 f[1…i-1][j] 其最大值为 max(f[1… i-1])<br>选取当前物体的集合的最大值 f[i - 1][j - v[i]] + w[i] (从集合的体积中除去当前物品的体积 并加上当前物体的最大值)<br>原题链接:<br><a href="https://www.acwing.com/problem/content/2/">https://www.acwing.com/problem/content/2/</a></p><ol><li><p>基础解法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> w[N],v[N]; <span class="comment">// 价值与体积</span></span><br><span class="line"><span class="type">int</span> f[N][N];    <span class="comment">// f[i][j] 前i个物体中 体积不超过j的物品的价值最大值</span></span><br><span class="line"><span class="type">int</span> n,m;    <span class="comment">// 物品件数n 与背包容量m</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="comment">// 读入数据</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span> ; i &lt;= n ; i++)&#123;</span><br><span class="line">        cin&gt;&gt;v[i] &gt;&gt; w[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n ; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m ; j++)&#123;</span><br><span class="line">            <span class="comment">// 最大值为 前i - 1物品 即不选的最大值</span></span><br><span class="line">            f[i][j] = f[i <span class="number">-1</span>][j];</span><br><span class="line">            <span class="comment">// 最大值为 选了当前位置的最大值</span></span><br><span class="line">            <span class="keyword">if</span>(j &gt;= v[i])&#123;</span><br><span class="line">                f[i][j]  = <span class="built_in">max</span>(f[i][j],f[i - <span class="number">1</span>][j - v[i]] + w[i]);    </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; f[n][m];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>一维数组优化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> w[N],v[N]; <span class="comment">// 价值与体积</span></span><br><span class="line"><span class="type">int</span> f[N];    <span class="comment">// f[i][j] 前i个物体中 体积不超过j的物品的价值最大值</span></span><br><span class="line"><span class="type">int</span> n,m;    <span class="comment">// 物品件数n 与背包容量m</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="comment">// 读入数据</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span> ; i &lt;= n ; i++)&#123;</span><br><span class="line">        cin&gt;&gt;v[i] &gt;&gt; w[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n ; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = m; j &gt;=v[i] ; j--)&#123;</span><br><span class="line">            <span class="comment">// 最大值为 前i - 1物品 即不选的最大值</span></span><br><span class="line">            <span class="comment">// 进行1维优化后 该步仍然等价</span></span><br><span class="line">            <span class="comment">//f[i][j] = f[i -1][j]; -&gt; f[i] = f[i]</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 最大值为 选了当前位置的最大值</span></span><br><span class="line">                <span class="comment">// f[i][j]  = max(f[i][j],f[i - 1][j - v[i]] + w[i]); </span></span><br><span class="line">                <span class="comment">// -&gt; f[i] = max(f[i] , f[j - v[i]] + w[i])</span></span><br><span class="line">                <span class="comment">// 此步优化为1维后 如果是从小到大计算j 那么j - v[i] 一定是小于j的 </span></span><br><span class="line">                <span class="comment">// 即j-v[i] 是先被计算出来 即此时j-v[i] 是第i层的j-v[i]</span></span><br><span class="line">                <span class="comment">// 即进行一维转换 等价于 f[i][j - v[i]] 而不是f[i -1][j - v[i]] 即结果与原式不等价</span></span><br><span class="line">                <span class="comment">// 所以只需改变循环顺序 从大到小枚举 那么此时 j-v[i] 对应的上一层就是f[i - 1]</span></span><br><span class="line">                f[j] = <span class="built_in">max</span>(f[j], f[j - v[i]] + w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; f[m];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h3><span id="完全背包问题">完全背包问题</span></h3><p>完全背包问题代码上与01背包区别很小 但实际分析思路却区别很大<br>完全背包问题中每件物品可以取无限次而不是1次</p><ol><li>状态表示: f[i][j] 表示从前i个物品中选 总体积不大于j的 最大值</li><li>状态计算: 同样与01背包问题相同的思路可以进行两种状态的划分<ol><li>不取当前物体的集合 f[i - 1][0 …. j] 其最大值即为 max(f[i - 1][j])</li><li>取当前物体的集合<br> f[i][j] &#x3D; max(f[i - 1][j],f[i -1][j -v] + w, f[i - 1][j - 2v] + 2w, ….)<br> f[i][j - v] &#x3D; max(f[i -1][j  -v], f[i - 1][j - 2v] + w, f[i - 1][j - 3v] + 2w, …)<br> 上面两式子合并可得<br> f[i][j] &#x3D; max(f[i - 1][j] , f[i][j - v] + w)</li></ol></li></ol><p>原题链接:<br><a href="https://www.acwing.com/problem/content/3/">https://www.acwing.com/problem/content/3/</a></p><ol><li><p>朴素二维DP做法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> v[N],w[N];</span><br><span class="line"><span class="type">int</span> f[N][N];    <span class="comment">// 取前i个物品的集合中 体积小于j的集合最大值</span></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span> ; i &lt;= n ; i++)&#123;</span><br><span class="line">        cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>  ; i &lt;= n ; i++ )&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span> ; j &lt;= m ; j++)&#123;</span><br><span class="line">            <span class="comment">// 第一部分一定存在 即不取第i件物品最大值 等于之前所有不取第i件物品的集合的最大值</span></span><br><span class="line">            f[i][j] = f[i - <span class="number">1</span>][j];</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 第二部分的最大值 当选择取第i件物品时 </span></span><br><span class="line">            <span class="comment">// 当前物品件数可以取</span></span><br><span class="line">            <span class="keyword">if</span>(j &gt;= v[i])&#123;</span><br><span class="line">                f[i][j] = <span class="built_in">max</span>(f[i][j],f[i][j - v[i]] + w[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cout&lt;&lt; f[n][m];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>一维数据优化</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> v[N],w[N];</span><br><span class="line"><span class="type">int</span> f[N];    <span class="comment">// 取前i个物品的集合中 体积小于j的集合最大值</span></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span> ; i &lt;= n ; i++)&#123;</span><br><span class="line">        cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>  ; i &lt;= n ; i++ )&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = v[i] ; j &lt;= m; j++)&#123;</span><br><span class="line">            <span class="comment">// 第一部分一定存在 即不取第i件物品最大值 等于之前所有不取第i件物品的集合的最大值</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 进行1维优化后  改步保持不变即可忽略</span></span><br><span class="line">            <span class="comment">// f[j] = f[j];</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 第二部分的最大值 当选择取第i件物品时 </span></span><br><span class="line">            <span class="comment">// 当前物品件数可以取</span></span><br><span class="line">            </span><br><span class="line">                <span class="comment">// f[i][j] = max(f[i][j],f[i][j - v[i]] + w[i]);</span></span><br><span class="line">                <span class="comment">// -&gt; f[j] = max(f[j],f[j - v[i]] + w[i]);</span></span><br><span class="line">                <span class="comment">// j 从小到大开始枚举 因此j - v[i] &lt; j 在上一层已经被计算过 故j直接从大到小枚举即可</span></span><br><span class="line">            f[j] = <span class="built_in">max</span>(f[j],f[j  - v[i]] + w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cout&lt;&lt; f[m];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> algo </tag>
            
            <tag> 算法总结 </tag>
            
            <tag> DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cvnotes</title>
      <link href="/2023/03/26/CV/cvnotes/"/>
      <url>/2023/03/26/CV/cvnotes/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2><span id="目标检测">目标检测</span></h2><h3><span id="检测框生成">检测框生成</span></h3><ol><li>SS(Selective Search): 经典检测中用于生成检测框 较早RCNN中会用<ol><li>优势<ol><li>捕捉不同尺度</li><li>多样化</li><li>快速计算<br> 即SS 是用于目标检测的区域提议算法 计算速度快 具有很高的召回率 基于颜色、纹理、大小和形状兼容计算相似区域的分层分组</li></ol></li></ol></li><li>RPN: Faster Rcnn 使用的检测框生成算法 效率更高<br>RPN最终就是在原图尺度上，设置了密密麻麻的候选Anchor。然后用cnn去判断哪些Anchor是里面有目标的positive anchor，哪些是没目标的negative anchor。所以，仅仅是个二分类而已<ol><li>RPN包括以下部分:<ol><li>生成anchor boxes</li><li>判断每个anchor box为foregoroud(包含物体)或者background(背景) 二分类</li><li>边界框回归对anchor box进行微调 使得 positive anchor 和真实框(Ground Truth Box)更加接近</li></ol></li><li>anchor: <ol><li>感受野: 感受野也就是特征上的一个元素，对于输入图像的感受范围。 卷积层⬆ -&gt; 特征感受野↑</li><li>在最后一层中 特征的感受野一般都比较大 而且感受野一般都是正方形 -&gt; 网络收敛困难</li><li>在原始的输入图像上设置很多预设框 假定预设框是存在目标 然后一个一个的去对每一个预设框进行判断 是否存在目标 预设框是否和目标符合 -&gt; <ol><li>不存在目标 就在分类分支打低分 存在就打高分</li><li>如果预设框和目标相比偏了 那就需要调整预设框的偏移量 调整一下预设框的大小和中心位置 -&gt; 即回归分支计算损失<br>-&gt; 那个预设框即为 anchor<br>-&gt; 这一阶段输出的框即为 Anchor + 偏移量的结果</li></ol></li></ol></li></ol></li></ol><h3><span id="roi-pooling">ROI pooling</span></h3><p>在Fast-Rcnn中<br>RoI Pooling层则负责收集proposal，并计算出proposal feature maps，送入后续网络</p><ol><li>Rol pooling层有2个输入:<ol><li>原始的feature maps</li><li>RPN输出的proposal boxes（大小各不相同）</li><li></li></ol></li></ol><h2><span id="特征融合">特征融合</span></h2><pre><code>特征融合的目的 是把从图像中提取的特征 合并成一个比输入特征更具有判别能力的特征 因此如何正确进行融合特征就成了一个重要问题</code></pre><ol><li>早融合(early fusion) 和 晚融合(late fusion)<br>在很多工作中，融合不同尺度的特征是提高分割性能的一个重要手段。低层特征分辨率更高，包含更多位置、细节信息，但是由于经过的卷积更少，其语义性更低，噪声更多。高层特征具有更强的语义信息，但是分辨率很低，对细节的感知能力较差。如何将两者高效融合，取其长处，弃之糟泊，是改善分割模型的关键。<br>很多工作通过融合多层来提升检测和分割的性能，按照融合与预测的先后顺序，分类为早融合(Early fusion)和晚融合(Late fusion)。<ol><li>early fusion: 用经典的特征融合方法，在现有的网络中 用<strong>concat或add</strong>融合其中的某几层</li><li>lately fusion: <ol><li>采用类似**特征金字塔(FPN)**的思想 对特征融合后进行预测</li><li>feature不融合，多尺度的feture分别进行预测，然后对预测结果进行综合，如Single Shot MultiBox Detector (SSD) , Multi-scale CNN(MS-CNN)</li><li>用一个具有高低特征融合能力的网络替代普通的网络，如Densenet；</li><li>不进行高低层特征融合，而是在高层特征预测的基础上，再用底层特征进行预测结果的调整</li></ol></li></ol></li><li>concat 和 add<ol><li>concat: concat是通道数的增加 </li><li>add: add是特征图相加，通道数不变</li><li>两者有如下区别<ol><li>add是描述图像的特征下信息量增多了 但是描述图像的维度本身并没有增加 只是每一维下的信息量在增加 -&gt; 因此对与最终的图像分类是有益的</li><li>concat是通道数的合并 也就是说描述图像本身的特征数(通道数)增加了 而每一特征下的信息没有增加</li><li>concat每个通道对应着对应的卷积核 而add形式则将对应的特征图相加 再进行下一步卷积操作 再进行下一步卷积操作 -&gt; 相当于加了一个先验 (add等价于concat之后对应通道共享同一个卷积核)</li><li>add可以认为是特殊的concat形式 但是add的计算量要比concat的计算量小得多</li></ol></li></ol></li></ol><h3><span id="图像采样上下采样">图像采样(上下采样)</span></h3><ol><li>缩小图像 即 下采样&#x3D;&#x3D;降采样 主要目的如下<ol><li>使得图像符合显示区域的大小</li><li>生成对应图像的缩略图</li></ol></li><li>放大图像 即 上采样&#x3D;&#x3D;图像插值 主要目的下<ol><li>放大原图像 从而可以显示在更高分辨率的显示设备</li></ol></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>yolo</title>
      <link href="/2023/03/26/CV/yolo/"/>
      <url>/2023/03/26/CV/yolo/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2><span id="yolov1">yolov1</span></h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>diffusion</title>
      <link href="/2023/03/17/DL/diffusion/"/>
      <url>/2023/03/17/DL/diffusion/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>深度学习指标</title>
      <link href="/2023/03/12/DL/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%8C%87%E6%A0%87/"/>
      <url>/2023/03/12/DL/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%8C%87%E6%A0%87/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2><span id="目标检测中常用指标">目标检测中常用指标</span></h2><h3><span id="iou">IoU</span></h3><p>IoU -&gt; Intersection over Union -&gt; 常用用于衡量目标检测任务中 预测结果的位置信息的准确程度<br>IoU &#x3D; (物体实际区域与推测区域重合的面积) &#x2F; 两个区域整体所占的面积 (即两个区域的交集 &#x2F;  两个区域的并集)<br>IoU ⬆ -&gt; 推测出的物体区域就越准确</p><h3><span id="gt">GT</span></h3><p>GT(Ground Truth) -&gt; 指真实的标签或真实的对象</p><h3><span id="常用指标">常用指标</span></h3><ol><li>TP: True Postive -&gt; IoU &gt; 0.5 的检测框数量 -&gt; 认为匹配成功</li><li>FP: False Postive -&gt; IoU &lt;&#x3D; 0.5 的检测框 (或者检测到同一个GT的多余检测框的数量) 即本身不是目标 但被检测为目标</li><li>FN: False Negative -&gt; 没有检测到的GT的数量 即漏检目标的数量</li><li>Precision: 查准率 TP&#x2F;(TP + FP) 模型预测的所有目标中 预测准确的比例</li><li>Recall: 查全率 TP&#x2F;(TP + FN) 所有真实目标中 模型预测正确的目标比例</li><li>AP: P-R曲线下的面积</li><li>mAP: mean Average Precision 即各类别AP的平均值</li></ol><h2><span id="mot-多目标跟踪指标">MOT 多目标跟踪指标</span></h2><pre><code>可参考[MOT Challenge](https://motchallenge.net/results/MOT17/?orderBy=MOTA&amp;orderStyle=DESC) 所列出的指标列表 就基本上比较常用</code></pre><p>MOT指标<br><img src="/2023/03/12/DL/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%8C%87%E6%A0%87/MOT指标.jpg" style="zoom:50%"></p><h3><span id="classical-metrics">Classical metrics</span></h3><ol><li>MT: Most Tracked trajectories 成功跟踪的帧数占总帧数的80%以上的GT轨迹数量</li><li>Fagments: 碎片数 成功跟踪的帧数占总帧数的80%以下的预测轨迹数量</li><li>ML: Most Lost trajectories 成功跟踪的帧数占总帧数的20%以下的GT轨迹数量</li><li>False trajectories: 预测出来的轨迹匹配不上GT轨迹，相当于跟踪了个寂寞</li><li>ID switches: 因为跟踪的每个对象都是有ID的，一个对象在整个跟踪过程中ID应该不变，但是由于跟踪算法不强大，总会出现一个对象的ID发生切换，这个指标就说明了ID切换的次数，指前一帧和后一帧中对于相同GT轨迹的预测轨迹ID发生切换，跟丢的情况不计算在ID切换中。<img src="/2023/03/12/DL/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%8C%87%E6%A0%87/MOTclassic_metrics.jpg"></li></ol><h3><span id="clear-mot-metrics">Clear MOT metrics</span></h3><ol><li>FP</li><li>FN</li><li>FM: 总的fragmentation数量</li><li>IDSW: 总的ID switch数量 -&gt; 即对每帧发生的ID Switch数量求和</li><li>MOTA: 跟踪准确度 -&gt; 1 - (FN + FP + IDSW) &#x2F; GT (MOTA最大值为1)</li><li>MOTP: 衡量跟踪的位置误差  $\Sigma$ $(d_{t,i})$&#x2F; $\Sigma$ $(c_t)$ (其中t表示第t帧 i代表t帧中第i个匹配对的距离)</li></ol><h3><span id="id-scores">ID Scores</span></h3><pre><code>MOTA的主要问题是它主要考虑了跟踪器做出错误决定的次数(比如IDSW) 而在某些情况下不想丢失跟踪对象的位置位置，我们更关心这个跟踪器跟踪某个对象的时间长短 -&gt; 因此ID scores被提出</code></pre><ol><li>IDP: Identification precision  (类似于查准率) -&gt; IDTP &#x2F; (IDTP + IDFP)</li><li>IDR: Identification recall   (类似于查全率) -&gt; IDTP &#x2F; (IDTP + IFFN)</li><li>IDF1： Identification F1 是IDP和IDR的调和均值</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> AI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode1590使数组和能被 P 整除</title>
      <link href="/2023/03/10/leetcode/leetcode1590%E4%BD%BF%E6%95%B0%E7%BB%84%E5%92%8C%E8%83%BD%E8%A2%AB%20P%20%E6%95%B4%E9%99%A4/"/>
      <url>/2023/03/10/leetcode/leetcode1590%E4%BD%BF%E6%95%B0%E7%BB%84%E5%92%8C%E8%83%BD%E8%A2%AB%20P%20%E6%95%B4%E9%99%A4/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>原题链接:<br><a href="https://leetcode.cn/problems/make-sum-divisible-by-p/">https://leetcode.cn/problems/make-sum-divisible-by-p/</a></p><p>很有意思的一道前缀和的题目 直接从来没想过这种思路</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  </span></span><br><span class="line"><span class="comment">    记数组总和为S1 连续子数组为S2</span></span><br><span class="line"><span class="comment">    移除子数组模数为0 即 (S2 - S1) % MOD P = 0 </span></span><br><span class="line"><span class="comment">    根据模运算法则即 S2 % P = S1 % P</span></span><br><span class="line"><span class="comment">    用前缀和来表示子数组S2 = f[i] - f[j]</span></span><br><span class="line"><span class="comment">    即 S1 % P = (f[i] - f[j]) % P = f[i] % P - f[j] % P</span></span><br><span class="line"><span class="comment">    记 S1 % P = x </span></span><br><span class="line"><span class="comment">    即为 f[j] % P   = f[i] % P - x</span></span><br><span class="line"><span class="comment">    使用hash表记录 f[j] % P (j 定义为i 前面的序列)</span></span><br><span class="line"><span class="comment">    因此不断右移的过程 即可同时保存 f[j] % P 同时计算f[i] % P - x 判断是否符合条件</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minSubarray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;<span class="built_in">s</span>(n + <span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i &lt; n; i++)&#123;</span><br><span class="line">            s[i + <span class="number">1</span>] = (nums[i] + s[i]) % p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> x = s[n];</span><br><span class="line">        <span class="keyword">if</span>(x  == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;hash;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ans = n + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i &lt;= n ; i++)&#123;</span><br><span class="line">            <span class="comment">// 记录以i为结尾的 前缀和值的对应位置</span></span><br><span class="line">            <span class="comment">// 这里直接顺着来就可以了 因为要找的是前面的j</span></span><br><span class="line">            hash[s[i]] = i;</span><br><span class="line">            <span class="comment">// 这里其实是处理 f[i] % P - x 会出现的负数的情况 保证值始终为正的</span></span><br><span class="line">            <span class="keyword">auto</span> it = hash.<span class="built_in">find</span>((s[i] - x + p) % p);</span><br><span class="line">            <span class="keyword">if</span>(it != hash.<span class="built_in">end</span>())&#123;</span><br><span class="line">                <span class="comment">// 即存在前一个以j结尾的子序列其mod的值与 f[i] % P - x 相同的情况</span></span><br><span class="line">                <span class="comment">// 更新答案</span></span><br><span class="line">                ans = <span class="built_in">min</span>(ans,i - it-&gt;second);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans &lt; n ? ans : - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 前缀和 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Multimodal Machine Learning</title>
      <link href="/2023/03/08/DL/Multimodal_Machine_Learning/"/>
      <url>/2023/03/08/DL/Multimodal_Machine_Learning/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2><span id="模态">模态</span></h2><p>在人机交互的背景下 模态是计算机和人之间的单一独立感官输入&#x2F;输出通道的分类 如果系统仅实现一种模态 则将其指定为单模态 如果具有多个模态 则将其指定为多模态</p><h3><span id="多模态">多模态</span></h3><p>多模态指的是多种模态的信息(包括: 文本、视频、音频等) -&gt; 多模态研究的就是这些不同类型的数据融合问题</p><p>多模态研究的是视觉语言问题，其任务是关于图像和文字的分类、问答、匹配、排序、定位等问题。</p><h2><span id="目标检测">目标检测</span></h2><ol><li>NMS: Non-maximum suppression 即非极大值抑制在目标检测中的出镜率也很高呀。在目标检测中，不论是最初的region proposal，还是后来的anchor box，不可避免的一个问题就是对于同一个物体，会预测出多个bounding box。而NMS所做的就是去除掉多余的bounding box，只保留和ground truth重叠度最高的bounding box. (<a href="https://zhuanlan.zhihu.com/p/60794316">参考链接</a>)</li><li>Bounding box regression: 其实就是对提取出来的不太准确的结果 进行微调调整为ground truth(<a href="https://zhuanlan.zhihu.com/p/60794316">参考链接</a>)</li><li>Kalman Filter: 卡尔曼滤波法 简而理解的话就是利用已知的量去预测未知的量(通常这些量无法直接测量 或者测起来比较困难) 专业一些的话 kalman Filter就是一种优化估值算法 可以预测所需要的参数(例如 位置 速度 方向)且是在存在误差的情况下 (<a href="https://blog.csdn.net/TYUT_xiaoming/article/details/102888434">参考链接</a>)</li></ol><h2><span id="目标跟踪">目标跟踪</span></h2><p>   目标检测和目标跟踪的区别在于 理想情况下可以使用它目标检测的方法去一直实现目标跟踪 但如果在某一时刻目标遭到了遮挡 那么目标检测就会失效即会失去的目标 即在目标跟踪的这个动态的过程会存在着许多没有目标的时刻 通常采用 kalman filter, deepsort 等方式进行解决 当然目标检测和目标跟踪还有很多不同 尤其是涉及多目标跟踪时 </p><ol><li>分类<ol><li>按研究领域 <ol><li>单目标跟踪: 给定一个目标 追踪这个目标的位置</li><li>多目标跟踪: 追踪多个目标的位置</li><li>Person ReID: 行人重识别</li><li>MTMCT: 多目标多摄像头跟踪 跟踪多个摄像头拍摄的多个人 </li><li>姿态跟踪: 追踪人的姿态</li></ol></li><li>按任务计算类型<ol><li>在线跟踪: 在线跟踪需要实时处理任务，通过过去和现在帧来跟踪未来帧中物体的位置</li><li>离线跟踪: 离线跟踪是离线处理任务，可以通过过去、现在和未来的帧来推断物体的位置，因此准确率会在线跟踪高</li></ol></li></ol></li><li>目标跟踪的困难点:<ol><li>形态变化: 姿态变化是目标跟踪中常见的干扰问题。运动目标发生姿态变化时, 会导致它的特征以及外观模型发生改变, 容易导致跟踪失败。例如:体育比赛中的运动员、马路上的行人</li><li>尺度变化:<ol><li>当目标尺度缩小时 -&gt; 跟踪框不能自适应跟踪 会将很多背景信息包含在内 导致目标模型的更新错误</li><li>当目标尺度增大时 -&gt; 由于跟踪框不能将目标完全包括在内 跟踪框内目标信息不全 也会导致目标模型的更新错误</li></ol></li><li>遮挡与消失: 目标在运动过程中可能出现被遮挡或者短暂的消失情况。当这种情况发生时, 跟踪框容易将遮挡物以及背景信息包含在跟踪框内, 会导致后续帧中的跟踪目标漂移到遮挡物上面。若目标被完全遮挡时, 由于找不到目标的对应模型, 会导致跟踪失败</li><li>图像模糊: 光照强度变化, 目标快速运动, 低分辨率等情况会导致图像模型, 尤其是在运动目标与背景相似的情况下更为明显。因此, 选择有效的特征对目标和背景进行区分非常必要。</li></ol></li><li>目标跟踪方法:<ol><li>生成式模型: 此类方法首先建立目标模型或者提取目标特征, 在后续帧中进行相似特征搜索.逐步迭代实现目标定位(早期工作) -&gt; 缺点 图像的背景信息没有得到全面的利用.且目标本身的外观变化有随机性和多样性特点, 因此, 通过单一的数学模型描述待跟踪目标具有很大的局限性.具体表现为在光照变化, 运动模糊, 分辨率低, 目标旋转形变等情况下, 模型的建立会受到巨大的影响, 从而影响跟踪的准确性; 模型的建立没有有效地预测机制, 当出现目标遮挡情况时, 不能够很好地解决。</li><li>鉴别式模型：鉴别式模型是指 将目标模型和背景信息同时考虑在内 通过对比目标模型和背景信息的差异 将目标模型提取出来 从而得到当前帧中的目标位置 文献在对跟踪算法的评估中发现[25], 通过将背景信息引入跟踪模型, 可以很好地实现目标跟踪.因此鉴别式模型具有很大的优势.</li></ol></li><li>目标跟踪算法<ol><li>发展: 经典跟踪算法 -&gt; 基于核相关滤波的跟踪算法 -&gt;基于深度学习的跟踪算法<ol><li>经典跟踪算法(光流法 Meanshift 粒子滤波)</li><li>基于核相关滤波的跟踪算法(MOSSE)</li><li>基于深度学习的跟踪算法</li></ol></li></ol></li></ol><h3><span id="mot-多目标跟踪">MOT 多目标跟踪</span></h3><ol><li>多目标跟踪流程: 目标定位 特征提取  相似度计算 数据关联(特征匹配)</li></ol><h2><span id="reid">REID</span></h2><pre><code>REID -&gt; Re-identification 其定义为利用算法 在图像库中找到要搜索的目标的技术 所以它属于图像检索的一个子问题</code></pre><h3><span id="p-edestrain-reid">P-edestrain ReID</span></h3><p> 行人重识别</p><ol><li><p>背景</p><ol><li>人工查找监控效率低下</li><li>监控摄像头分辨率低 难以获得清晰的人身图像 -&gt; 尝试ReID 代替人脸识别 -&gt; <strong>在监控拍不到人的情况下 ReID可以代替人脸识别来在视频序列中找到想要的目标</strong></li></ol></li><li><p>发展 </p><ol><li>深度学习之前-&gt; ReID基本是基于特征的阶段 -&gt; 人工特征(如 颜色 HOG特征等) </li><li>深度学习之后-&gt; 黑盒性质特征</li><li>迁移学习 GAN</li></ol></li><li><p>how -&gt; 如何做ReID</p><ol><li>Detection -&gt; 检测出行人 (数据集已经完成)</li><li>训练特征提取网络 -&gt; 根据特征所计算的度量距离等到损失值 -&gt; 优化器去迭代找到loss最小值 -&gt; 不断更新网络的参数达到学习效果 </li><li>测试时将要检索的的图片(query) 在底库gallery中 根据计算出的特征距离进行排序 选出最TOP的几张图片 -&gt; 达到目标检索的目的</li></ol></li><li><p>ReID 评测指标</p><ol><li>CMC (有缺陷)</li><li>mAP   </li><li>rank-1 首次命中率 -&gt; 表示在候选库中得到与检索目标相似度排名最高的图片为目标行人的概率</li></ol></li></ol><h4><span id="表征学习">表征学习</span></h4><p>   表征学习的方法没有直接在训练网络的时候考虑图片间的相似度 而把行人重识别任务当做分类问题或者验证问题</p><ol><li>分类损失: 分类损失也叫ID损失 只有ID损失的网络称为ID Embedding网络(IDE网络)<ol><li>训练集中行人的ID数为网络的类别数</li><li>特征层后接一个分类FC 经过softmax激活函数计算交叉熵损失</li><li>测试阶段使用倒数第二层的特征向量进行检索 分类FC层丢弃</li></ol></li><li>属性损失: <ol><li>可以同时连接几个属性分类损失增强ReID特征的性能</li><li>每一个属性损失都一个分类二道交叉熵</li><li>可以等效于一个multi-task的网络</li><li>测试阶段将所有分类FC丢弃只使用ReID特征</li></ol></li><li>验证损失<ol><li>每次输入一对图片 进入同一个Siamese网络提取特征</li><li>融合两个特征信息计算一个二分类损失</li><li>训练阶段可以和ID损失一起使用</li><li>测试阶段输入两张图片 直接判断该两张图片是否属于一个行人</li></ol></li></ol><h4><span id="度量学习">度量学习</span></h4><p>   度量学习旨在通过网络学习出两张图片的相似度 在行人重识别问题上 表现为同一行人的不同图片之间的相似度大于不同行人的不同图片</p><h2><span id="deeport">deeport</span></h2><p>   sort -&gt; simple online realtime tracking (不是排序的意思)</p><ol><li>detection (rcnn yolo)</li><li>estimate (linear constant velocity model: kalman filter)</li><li>target assocation -&gt; Hungarian algoritm 拟合检测框</li><li>track identity life cycle 轨迹</li></ol><h2><span id="siamese-network-孪生神经网络">Siamese network 孪生神经网络</span></h2><p>   孪生即为连体婴儿的意思 -&gt; 神经网络的连体是通过共享权值实现</p><ol><li>Siamese network 即共享权值 左右两边两个网络权值一样 甚至使用同一个网络都可以</li><li>pseudo-siamese network： 伪孪生神经网络 不共享权值 两边是两个不同的神经网络<br><strong>孪生神经网络的主要用途</strong><br>简单来说，衡量两个输入的相似程度。孪生神经网络有两个输入（Input1 and Input2）,将两个输入feed进入两个神经网络（Network1 and Network2），这两个神经网络分别将输入映射到新的空间，形成输入在新的空间中的表示。通过Loss的计算，评价两个输入的相似度。<br><strong>孪生神经网络和伪孪生神经网络分别适用于什么场景呢</strong><br>先上结论：孪生神经网络用于处理两个输入”比较类似”的情况。伪孪生神经网络适用于处理两个输入”有一定差别”的情况。比如，我们要计算两个句子或者词汇的语义相似度，使用siamese network比较适合；如果验证标题与正文的描述是否一致（标题和正文长度差别很大），或者文字是否描述了一幅图片（一个是图片，一个是文字），就应该使用pseudo-siamese network。也就是说，要根据具体的应用，判断应该使用哪一种结构，哪一种Loss。</li></ol><p><a href="https://zhuanlan.zhihu.com/p/35040994">参考链接</a></p><h2><span id="模式识别">模式识别</span></h2><h2><span id="中间模态">中间模态</span></h2>]]></content>
      
      
      
        <tags>
            
            <tag> 多模态 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pytorch</title>
      <link href="/2023/02/28/DL/pytorch/"/>
      <url>/2023/02/28/DL/pytorch/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ol><li>epoch：所有的训练样本输入到模型中称为一个epoch； </li><li>iteration：一批样本输入到模型中，成为一个Iteration;</li><li>batchszie：批大小，决定一个epoch有多少个Iteration；</li><li>迭代次数（iteration）&#x3D;样本总数（epoch）&#x2F;批尺寸（batchszie）</li><li>dataset (Dataset) – 决定数据从哪读取或者从何读取；</li><li>batch_size (python:int, optional) – 批尺寸(每次训练样本个数,默认为１）</li><li>shuffle (bool, optional) –每一个 epoch是否为乱序 (default: False)；</li><li>num_workers (python:int, optional) – 是否多进程读取数据（默认为０);</li><li>drop_last (bool, optional) – 当样本数不能被batchsize整除时，最后一批数据是否舍弃（default: False)</li><li>pin_memory（bool, optional) - 如果为True会将数据放置到GPU上去（默认为false）</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> AI </tag>
            
            <tag> pytorch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>transfomer</title>
      <link href="/2023/02/24/DL/Transformer/"/>
      <url>/2023/02/24/DL/Transformer/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1><span id="transformer-attention-is-all-you-need">Transformer - attention is all you need</span></h1><ol><li>layernorm: 每一个样本进行归一化</li><li>seqToseq模型</li><li>Encoder: 输入一个vector seq 输出另外一个 vector seq</li><li>Decoder: <ol><li>Encoder的输出会输入Decoder</li><li>Decoder 看到的输入会是自身前一个的输出 </li><li>Decoder 根据Encoder的输入 和 Decoder自己前一个的输入决定当前的输出(最开始的输入是Begin)</li><li>Decoder 的输出是一个一个产生(a1 a2 a3…) 而非一次性全部出现 所以会有withmask</li><li>Decoder 必须自己决定输出seq的长度 当Decoder输出到最后时 会根据Encoder的embeding 和 其自己之前的输出来判断当前是否输出End符号 </li><li>NAT - Non-autoregressive: NAT一次性输入所有的begin 一次输出所有的结果 NAT忽略掉token后所有输出 从而确定每次输出的长度 但是NAT 通常其效果是不如 AT的</li><li>Cross Attention</li></ol></li><li>Training<ol><li>Copy Mechanism: 在一些任务中Decoder并不需要自己产生输出 可能只是需要从输入中复制一些东西 (EX: Chat-Bot)</li></ol></li><li>Positional Encoding: Positional Encoding就是句子中词语相对位置的编码，让Transformer保留词语的位置信息。</li><li>Feed-Forward Network: Feed-Forward层包括两层全连接层以及一个非线性激活函数ReLu。Transformer 在Muti-Head Attention内部结构中 进行的主要是矩阵乘法 即进行的都是线性变换 而线性变换的学习能力是不如非线性变化的强，所以Muti-Head Attention的输出尽管利用了Attention机制 学习到了每个单词的权重 但是这种表达能力可能并不是很强 所以可以通过激活函数 来强化每个单词的表达能力。 在Feed-Foward层中 先将数据映射到高维空间再映射到低维空间的过程 可以学习到更加抽象的特征 即Feed-Forward层使得单词的表达能力更强 更加能够表示单词与context中其他单词之间的作用关系。 </li><li>Scaled Dot-Product Attention: Scaled Dot-Product Attention属于点乘注意力机制，并在一般点乘注意力机制的基础上，加上了scaled。scaled是指对注意力权重进行缩放，以确保数值的稳定性。<ol><li>当 $\sqrt{d}$ 较小时 除不除都没关系</li><li>当 $\sqrt{d}$ 较大时 两个向量的长度会比较长 两个向量的相对差距就会变大 值最大的那个值做出来的softmax会更加靠近1 剩下的会更加靠近0 值的分布会更加向两端靠拢 此时计算梯度的时候 梯度比较小 就会跑不动</li><li>（刚开始训练的时候，梯度较小不是一个好的情况。因为训练初期，模型还没找到一个合适的参数空间，梯度较小表明模型还没有开始学习，需要更多的训练才能得到好的结果；当模型的初始参数已经非常接近最优解，此时的梯度可能会很小，因为模型已经处于一个相对平坦的区域，此时小梯度可以帮助模型更稳定地收敛到最优解，避免出现震荡和过拟合的情况）</li></ol></li></ol><h2><span id="homework">Homework</span></h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>DLNotes</title>
      <link href="/2023/02/23/DL/DLNotes/"/>
      <url>/2023/02/23/DL/DLNotes/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ol><li>sigmoid 将所有值压缩到[0,1] 所以当input的输入变化很大时 通过sigmoid会将变化缩小至[0,1] 这个变化在network 层数越来越深时 其对于变化削减则越为明显<br>对于这个问题的解决方法则是使用Relu 作为activation function<br>Relu 当input &gt; 0时 output仍然是input 当input小于0时 output为0<br>除此之外 Relu 由于函数简单 运算起来比sigmoid 快很多 且可以解决 Vanishing gradient problem的问题</li><li>Maxout 自动去学习 activation function ,  Relu 作为Maxout的一种特例</li><li>全连接层: 将特征整合到一起 输出为一个值 (全连接之前是特征提取)</li><li>learing rate: 学习率控制每一次迭代中梯度向损伤函数最优解移动的步长 其大小决定了网络学习速度快慢 在网络模型训练中 模型通过样本数据给出预测值 计算代价函数并通过反向传播来调整参数 重复上述过程直至模型参数逐步趋于最优解从而获得最优模型 在这个过程学习率控制每一步更新参数的步长 合适的学习率可以使得代价函数以合适的速度收敛到最小值</li><li>drop out 在train set上跑的好 但在test set上跑的不好时加drop out</li><li>CNN ： input(image) -&gt; Convolution -&gt; Max Pooling (Conn -&gt; MaxPooling 这两步课重复多次) -&gt; Flatten  -&gt; Fully Connected Feedforward network -&gt; result<ol><li>Property1 : pattern 只需看一张图片的一个小部分 而不需看整个image</li><li>Property2 : 同样的pattern 会出同张image的不同区域 </li><li>Property3 : Subsampling<br>Property1 Property2 -&gt; Conn<br>Property3 -&gt; MaxPooling</li></ol></li><li>Normalization <ol><li>为什么需要Normalization -&gt;&gt; 可以理解是为了获取数据的独立同分布<br>独立同分布的数据可以简化常规机器学习模型的训练 提升机器机器学习的预测能力 -&gt; 已成为共识<br>因此将数据喂给机器学习模型时 需要一个重要的步骤就是”白化”</li><li></li></ol></li><li>filter 即 kernel 滤波器 卷积核中数值为对图像中与卷积核同样大小的子块像素点进行卷积计算时所采用的权重。</li><li>feature map 特征图(特征映射) 在每个卷积层，数据都是以三维形式存在的。你可以把它看成许多个二维图片叠在一起，其中每一个称为一个feature map。在输入层，如果是灰度图片，那就只有一个feature map；如果是彩色图片，一般就是3个feature map（红绿蓝）。层与层之间会有若干个过滤器&#x2F;卷积核（kernel），这个过滤器的尺寸大小（宽、高）和深度（长）是需要人工设定的，常用的过滤器尺寸有3<em>3或5</em>5。当前层中的所有feature map分别跟当前层和下一层间的每个卷积核做卷积求和后，都会产生下一层的一个feature map。通常有多少个卷积核，下一层就会生成多少个feature map。 reference: <a href="https://cloud.tencent.com/developer/article/1766105">https://cloud.tencent.com/developer/article/1766105</a></li><li>CAM 特征可视化技术 称Class Activation Mapping，既类别激活映射图 reference: <a href="https://zhuanlan.zhihu.com/p/269702192">https://zhuanlan.zhihu.com/p/269702192</a></li><li>Global Average Pooling(GAP) -&gt; 全局平局池化<ol><li>例如 最后一层是4个6<em>6的特征图 GAP是将每一张特征图计算所有像素点的均值 输出一个数据值 这样4个特征图输出4个数据点 将这些数据点组成一个1</em>4的向量的话 就成为一个特征向量 就可以送入到之后的计算中了</li><li>GAP替代CNN中传统的全连接层 主要目的是减少参数量 与全连接层相比 GAP有两个优点<ol><li>GAP 通过强制使特征图和类别之间相对应，对于卷积结构更来说这个转换更自然</li><li>GAP 层没有参数用于优化，避免了过拟合</li></ol></li></ol></li><li>Embedding: 一种将离散变量转变为连续向量的方式</li><li>RNN(recurrent neural networks)-&gt; 循环神经网络:<ol><li>神经网络只能单独的去处理一个个输入的数据 但前一个输入和后一个输入之间是没有联系的 但在处理一些场景的时候是考虑到前后输入的 如机器翻译的时候 那么此时则需要使用循环神经网络 即RNN</li></ol></li><li>Attention: 核心即从关注全部到关注核心重点 <ol><li>优点<ol><li>参数少 速度快 效果好</li></ol></li><li>主要思路: 带权求和</li></ol></li><li>Multi-headed Self-attention: 多头自注意力机制</li><li>padding: 填充影响输出的大小 假设如形状为n x m 卷积核则为 a x b 则输出为 (n - a + 1) * (m - b + 1)那么如此一来当经历多层卷积后 图像大小就会迅速减小 从而损失很多有效信息 故需要padding 填充来解决这一问题 </li><li>dropout: 当模型参数过多 但训练样本过少时 容易出现过拟合的情况 使用dropout可以解决这一情况</li></ol><h3><span id="bactch-noramaliza">Bactch  Noramaliza</span></h3><pre><code>在做图像预处理过程中 通常会对图像采取标准化处理  BN的目的就是使得图像(例如 feature map) 满足均值为0 方差为1的分布规律</code></pre><ol><li>BN: BatchNorm 批量归一化   <ol><li>训练时要将trainning参数设置为True 在验证时设置为False(在pytorch中 model.trian() 和 model.eval())</li><li>batch size尽可能大 这样才可以尽可能的接近整体样本 设置的越大求的均值和方差越接近整个训练集和方差</li><li>将BN层置于 卷积层和激激活层之间 且卷积层不要使用偏置bias</li></ol></li></ol><h3><span id="降采样">降采样</span></h3><ol><li>降采样: <ol><li>pooling: 网络小时效果好</li><li>stride: 网络大时效果好 (stride &#x3D; 2)</li></ol></li></ol><h3><span id="迁移学习">迁移学习</span></h3><ol><li>迁移学习: 使用预训练模型去训练</li><li>使用别人预训练模型参数时 要注意别人的预处理方式</li><li>常见迁移学习方式(2 3 适合设备有限 时间有限时采用)<ol><li>载入权重后训练所有参数</li><li>载入权重后只训练最后几层参数</li><li>载入权重后在原网络基础上再添加一层全连接层 仅训练最后一个全连接层</li></ol></li></ol><h3><span id="auto-regressive-ar-自回归模型">Auto regressive (AR) 自回归模型</span></h3><pre><code>AR 是指利用预测目标的历史时间数列在不同时期取值之间存在的依存关系(即自身相关)，建立起回归方程进行预测</code></pre><p>具体说，就是用一个变量的时间数列作为因变量数列，用同一变量向过去推移若干期的时间数列作自变量数列，分析一个因变量数列和另一个或多个自变量数列之间的相关关系，建立回归方程进行预测。<br>再通俗一点讲，<strong>就是用过去时间点的数据预测未来时间点的数据</strong>。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>backpropagation</title>
      <link href="/2023/02/23/DL/backpropagation/"/>
      <url>/2023/02/23/DL/backpropagation/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>反向传播的这个反向过程就是利用根据节点的值 x 上游输出值 反向传播给下游</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>diary-2022-12-20</title>
      <link href="/2022/12/20/life/diary-2022-12-20/"/>
      <url>/2022/12/20/life/diary-2022-12-20/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="517a060913cb0c27a93a11894b7ca4fb8048855aa9edce45579e88580e9ee64f">abb32f68827b16598088320c52df6dceed8d5732823a156d7b7dde0f3ca94ce092d793d245a28467421de433918fe97783ad87d643071b4aac7499e49ea5d4381e0064624190220d04ef98e0846cc340b317838685ec2d0257a5425bfdef7ecd9e788dade6781cb45b4ac1d6bd43e978fd16cb72fa694331a67f8ff722dffb14aab72e6896ff650d5259397a72346fd2ddd410f4006d3d56397c9b1b45482969ce61e6bd38d82118dba608ebfd01048537512b3583452b2c8f8136da476aade1c424c4d4ce8b36ae78f4ac19b370f987e2032c457ce1391c9954a9fa0025e70fae3f62b72c97a4f977f92f165537e25aef9bdb0f580c8ad53b2f1093f705ac15fa350a34e25ad5811fa3ccb1ba6e88564f9f1d86e7b06844cc71c91e974599f1daa3987c7533ec0677a6c87cf8a1064b166ad233e3d367521d70ebc320f02f0c8acf4adabd4b3face017504ceb3e30569ccf46815a34f485767a81f8dce47df1bdd4811ff6ab80440daa30c50ca604de9938297a9ba81ff24dda1b7cc9d611f6c94c05a3dc1c222a6f1b721991e7cf05e80eaee71fd7dfa064a52b39e431aacac6ae6e7c38947947bf569f778326b882cb99923f0d2067d7851bd3cb0e5e6d6fe1fa01b2d61a2e83d1ee8810f89cc68016369a06218c596286d367ef614cbc99e530c353af00614661ab9439395b6ac1dd4e7dbbf2df9083391cd590bb0f9a242c861248e4d2356f0cea1dfb0f600bf0b323d78d8174caf6cfa6af2f868e87e534af8216c5a02ca832c4d851da7d300166d09ce91ed8d3af91dc08d71f5389feeccb55ca764986b786f47700d3cca4f25f2da8683fb50b5a43ff5dc17f60683bb62961c837e2b9378a5c8ae7e0ca8905a9603a24e693e40550231869ac62bc46d0ebbe6fb3c579a65fdb6108af8dae5d2a39b486526366db954855d157f33daec6a398a232a90420f46072559e55b2efe510d3c026ab970f85080e98f4cdc03b6d8f0f359be4c50ca078d99a23c34b3caa23409ef4fb954977765a93b40f698816c98a10664b6480155847b516ff30a60e0497e725ae1c1de387315910e868861628ce0783b102c544a2df6a718c0064b736123e7bfe5d914940b2fe55060ae01392c9cd135326397299ff23fb4a08295d96341aef22548a98b2fa1c0dcf856985e282125ca4f0f110810c115c160d47ae56bd763a1ec35442ae2c481f48467bd65a2a3a026a59dd0ff79658ec7928b15c7843e8d4093b8f7f18f204387c06cfe9d1341a0a2c6a4cf5355b0b1b7418455d0b9dcf839c53f608e87fc11404fe14ca4c481ed90b241403a5cd60e46058546a6b2aac298e99eb569b8f07c83938191087c4720640f0eb367fde2146a9f8ee</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode6268查询树中环的长度</title>
      <link href="/2022/12/18/leetcode/leetcode6268%E6%9F%A5%E8%AF%A2%E6%A0%91%E4%B8%AD%E7%8E%AF%E7%9A%84%E9%95%BF%E5%BA%A6/"/>
      <url>/2022/12/18/leetcode/leetcode6268%E6%9F%A5%E8%AF%A2%E6%A0%91%E4%B8%AD%E7%8E%AF%E7%9A%84%E9%95%BF%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>原题链接:<br><a href="https://leetcode.cn/problems/cycle-length-queries-in-a-tree/">https://leetcode.cn/problems/cycle-length-queries-in-a-tree/</a></p><h2><span id="lca-最长公共祖先问题">LCA 最长公共祖先问题</span></h2><p>LCA问题:<br>根据完全二叉树的性质 越往下的节点值越大<br>则从下往上的遍历的过程 即为值见减小的过程<br>环长 &#x3D; dist(LCA,a) + dist(LCA,b) + 1</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">cycleLengthQueries</span><span class="params">(<span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; queries)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i &lt; queries.<span class="built_in">size</span>() ; i++)&#123;</span><br><span class="line">            <span class="type">int</span> a = queries[i][<span class="number">0</span>], b = queries[i][<span class="number">1</span>];</span><br><span class="line">            <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(a != b)&#123;</span><br><span class="line">                <span class="keyword">if</span>(a  &gt; b)&#123;</span><br><span class="line">                    a = a / <span class="number">2</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    b = b / <span class="number">2</span>; </span><br><span class="line">                &#125;</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ans.<span class="built_in">push_back</span>(res);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algo </category>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LCA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode6267添加边使所有节点度数为偶数</title>
      <link href="/2022/12/18/leetcode/leetcode6267%E6%B7%BB%E5%8A%A0%E8%BE%B9%E4%BD%BF%E6%89%80%E6%9C%89%E8%8A%82%E7%82%B9%E5%BA%A6%E6%95%B0%E4%B8%BA%E5%81%B6%E6%95%B0/"/>
      <url>/2022/12/18/leetcode/leetcode6267%E6%B7%BB%E5%8A%A0%E8%BE%B9%E4%BD%BF%E6%89%80%E6%9C%89%E8%8A%82%E7%82%B9%E5%BA%A6%E6%95%B0%E4%B8%BA%E5%81%B6%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>原题链接:<br><a href="https://leetcode.cn/problems/add-edges-to-make-degrees-of-all-nodes-even/">https://leetcode.cn/problems/add-edges-to-make-degrees-of-all-nodes-even/</a></p><h2><span id="分类讨论">分类讨论</span></h2><p>这题基本上是图论的常规操作，但重要的是分清楚情况。<br>最多添加两条额外的边使得所有点的度变为偶数<br>则度为奇数的点数量x(x一定小于4) 有以下几种情况:</p><ol><li>x &gt; 4  return false</li><li>x &#x3D; 4 时  a , b ,c ,d这四个点<br>存在一对两个点之间不存在边 则可通过加两边方式使得奇数点均变为偶数<br>否则不行</li><li>x &#x3D; 2 时 a ,b 两个点<br>如果两个点之间  不存在边则直接加边即可<br>若两个点之间也存在点 则可通过加两条边的方式 将两个点都向那个点连一条边<br>从而达成条件<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      这里哈希映射加速的办法还是蛮值得一学的 </span></span><br><span class="line"><span class="comment">      有些极限的情况下stl会比较慢</span></span><br><span class="line"><span class="comment">      本题是两个点 一个10^5 这个数量 故这样*10^6 进行映射则能形成唯一对 </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 哈希映射 主要用于优化加速</span></span><br><span class="line">    <span class="function">LL <span class="title">get</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a &gt; b)&#123;</span><br><span class="line">            <span class="built_in">swap</span>(a,b);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1000000ll</span> * a  + b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPossible</span><span class="params">(<span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;LL&gt;s;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;<span class="built_in">d</span>(n + <span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;vs;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;e : edges)&#123;</span><br><span class="line">            <span class="type">int</span> a = e[<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> b = e[<span class="number">1</span>];</span><br><span class="line">            s.<span class="built_in">insert</span>(<span class="built_in">get</span>(a,b));</span><br><span class="line">            d[a]++;</span><br><span class="line">            d[b]++;   </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 统计度为奇数的点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span> ; i &lt;= n ; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(d[i] % <span class="number">2</span>)&#123;</span><br><span class="line">                vs.<span class="built_in">push_back</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> c = vs.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(c == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(c == <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="type">int</span> a = vs[<span class="number">0</span>], b = vs[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(!s.<span class="built_in">count</span>(<span class="built_in">get</span>(a,b)))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span> ; i &lt;= n ; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i == a || i == b)&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果存在两个点都没有连接边的点 则可以加边</span></span><br><span class="line">                <span class="keyword">if</span>(!s.<span class="built_in">count</span>(<span class="built_in">get</span>(a,i)) &amp;&amp; !s.<span class="built_in">count</span>(<span class="built_in">get</span>(b,i)))&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(c == <span class="number">4</span>)&#123;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt;tmp&#123;vs[<span class="number">0</span>],vs[<span class="number">1</span>],vs[<span class="number">2</span>],vs[<span class="number">3</span>]&#125;;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">24</span> ; i++)&#123;</span><br><span class="line">                <span class="type">int</span> a = tmp[<span class="number">0</span>],b = tmp[<span class="number">1</span>],c = tmp[<span class="number">2</span>],d = tmp[<span class="number">3</span>];</span><br><span class="line">                <span class="keyword">if</span>(!s.<span class="built_in">count</span>(<span class="built_in">get</span>(a,b)) &amp;&amp; !s.<span class="built_in">count</span>(<span class="built_in">get</span>(c,d)))&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">next_permutation</span>(tmp.<span class="built_in">begin</span>(),tmp.<span class="built_in">end</span>());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> algo </category>
          
          <category> leetcode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>diary-2022-12-01</title>
      <link href="/2022/12/01/life/diary-2022-12-01/"/>
      <url>/2022/12/01/life/diary-2022-12-01/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="de8bf79dc70910b34c1c15e5a9dce273876d40fc6c71d683981fa2a2759123c3">abb32f68827b16598088320c52df6dceed8d5732823a156d7b7dde0f3ca94ce092d793d245a28467421de433918fe97783ad87d643071b4aac7499e49ea5d4381e0064624190220d04ef98e0846cc340b317838685ec2d0257a5425bfdef7ecd9e788dade6781cb45b4ac1d6bd43e978fd16cb72fa694331a67f8ff722dffb14aab72e6896ff650d5259397a72346fd2ddd410f4006d3d56397c9b1b45482969ce61e6bd38d82118dba608ebfd01048537512b3583452b2c8f8136da476aade1c424c4d4ce8b36ae78f4ac19b370f9874e2e28509003cb6e4b59514b6281eb1404d286f4e91c8dd9234ab4fe41a1f0fc310cf44fcc1762cf124878078c938df4b801a84e28034e665baca6a3cf8d3c61</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>区块链基本概念</title>
      <link href="/2022/11/28/blockchain/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
      <url>/2022/11/28/blockchain/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>区块链的核心意义就是保证承诺不被违背</strong></p><ol><li>Immutable</li><li>Decentralized</li><li>Transparent</li></ol><h2><span id="区块链的应用">区块链的应用</span></h2><ol><li>DeFi</li><li>DAOs</li><li>NFTs</li></ol>]]></content>
      
      
      <categories>
          
          <category> blockchain </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux使用笔记</title>
      <link href="/2022/11/26/Linux%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/11/26/Linux%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2><span id="ubuntu下无法从本地上传文件的解决方法">Ubuntu下无法从本地上传文件的解决方法</span></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> 777 filename</span><br></pre></td></tr></table></figure><p>为文件夹进行授权 从而在该文件夹下即可以进行上传</p>]]></content>
      
      
      <categories>
          
          <category> dev </category>
          
          <category> linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>食品追溯系统</title>
      <link href="/2022/11/23/food-trace/"/>
      <url>/2022/11/23/food-trace/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2><span id="溯源论文总体安排">溯源论文总体安排</span></h2><ol><li>前言: 食品溯源的必要性(科技发展 人们生活水平提高 食品安全重要性提升)</li><li>溯源需求分析 (以 渔业系统为例 具体有哪几个关键节点需要进行溯源 溯源需要查询出什么信息？ 如质量 时间等)</li><li>相关技术研究以及说明 (根据上述需求分析内容 进行技术选型以及说明 为什么要选这门技术 这门技术的优势)<ol><li>例: 如要构建 网站 后端架构需要使用到springboot框架 java 等</li><li>例: 如在溯源的中要使用到区块链 则需要应用到智能合约存储等</li><li>…</li></ol></li><li>溯源系统设计 (根据第一步需求分析的内容进行设计)<ol><li>整体架构设计(有哪些功能模块)</li><li>数据库表设计 </li><li>….</li></ol></li><li>溯源系统实现与测试<ol><li>展示具体溯源系统实现的效果 (看情况展示代码)</li><li>展现系统实现过程中必要的配置参数</li><li>…</li></ol></li><li>章节总结</li><li>致谢</li><li></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>diary-2022-11-23</title>
      <link href="/2022/11/23/life/diary-2022-11-23/"/>
      <url>/2022/11/23/life/diary-2022-11-23/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="872a9f37c50803f77a76c0af92692e6c4fa111df89337edf908fae662f670bc1">dc49651648acacfd7b8aa92c798562c50f39888456ccbb95186c7a4273069f6a488c6e95eba3cd6b1edbc4ef1c7dd2ed766d68659788ed98606bad2f1d54648475b17c4255d424da66f77598ecce809cce13f06de2a1e8e6d0fb14fa026629d5ac8234cab2b2caf6108b1913e3e90bee91f209777fba4d7884e268bd6f403aac7bd4e207696146220c8630f0de095206e2f4be56f29dadac9dacd179e2c4a7942ab1517f8909e43b2f2b7856d8d1c52ad174e75d25a7457c55c65f7c0214d7a1af792bbb669ae03813643bd8f2687a9ae14a6d6b104e1d8cfb0de73bf82fc9b9ed3156f8aabca75054b908153c0526782e9b90360cdc5121d7dd6eec76d452a3e854a097952c20e98e855ac262c1e8e62cb73d36cf8754cdd0078a16df5a73bd0f4f2dd49297ce90477c8268972e847eaac258563f5a809276188f3917da11871bc1fa154a23d1ead5cfbf262d0ea841a1645c05538a5d9ccb0e9d75db567fdf94f624f675171cbc02277de34350a81493e35037c13d103d3c3a7d79b86e905d2d3b45573531d1c23cc6b86fb539fef78ceabd73a675318377543c4d332cd327e18bac5d33096a62642e5965aea7ee37bdf67bb7e42b973e597c9590dc71bd55f69208620917295ed9ea544e76bf6413d033216b604514e98efd6883f19d705c01af71f83d4bfb9d2eee48aaab4d9f97929b84cb4ef306745a222ed604fd060599741a52357f7414e001eadc624bea6873adbded6abafb03c308fe23ab34d2c6c3ffd6baca8c9cf5e99670cce6ecea629aadbcd7e9d933761c711072633749576082cea473da431653c5471b70fff93a19836c35c6f6d82fff4f36b41283c31550150c8abb46815a6f0f712f429e7bca6c5f3451b032967b5ff7054d7c6964e3e9b591a129b82d35e8a2a03629e0c73526ae3d975ba6e49ae04af5e4d1bdb880d30a71a9f8be3ea79715a331623eff571670c994e53bf06378a270b87cf8ed85d3898fd6f3908ff3d775e24b509cb4865f4d91db76d7835493e4c141af522d3c30fc9c15c7824366e65d36bed0a3c34273dd7676c8c36a3dd7ee849d3c5c9b1c029e42b0242c52eb205e70cd9a7498f7f5797bd876c7f5c47d5c10635a22df0109bca1d9225d36b43ec2fef329426d4c5c6c13d698df28512494ad4e92fa92b9ae0964e76ad2a7dba6aaf1b73dbdae9037c955057eac31bc56fcd1f4753768886020f77674e86f206c6fd9ce1f2c45f0c6a554aa9bfeb64eaa629ba98290db5309fcdbb54123448880daa2c976a66688c2857190fc8cce07a02fd48c81e3826a01be705970a318f0149439efd9bbe450a2eea124d128b7d1b52fe5d5a9a48bb5e0c11e508397c51128ae5a64741e9fb74d0c2183b0e8182a34206bdaac3e18ac74ccc887f34069c2dbcef5c55c4f6e087d5064c5346eb11c64aba2a7aca68b0269b10dc742315ae7dd930ddac0932743349f2ea874e448d6aa14367917d85c6363d0f340378a2caa1c6621f73fe239ae6dbb3e3b60bbfaa2e548c241f6a8072cc5d2e150ed18c7af47a921ad9c538353929eafc30a2782a4a1b0a93d5712d6a4bf36f1fa5d789f9d3c90837c96ae78b2177bd20719735d8cac9f41fc6b1f41c615945fd520ef97d83c1c617e64663e4ed640190199726166cf44eabe789575644ea6ab0d90e3c39ba44d161bde91e850a909ef499e367f32fa3c214956c560fba4bb42b52a459da92bd4ef941d5e972b09862bfde0dca84c9873e3ff07c4b80e360c1eca0e7c5e8a7fa6a0495dea6006fd34a028cb5d6bcc1a2ec479637939db7b483c425e3e79e4d706712877fd2c78057b2267330abef4998064bbdeffdf42c97815301b042107256b5b7ca053ee75476d2d5b449bc4e6f1b0bc63c8a371d5c0fd3b907bedc7fea29c92103edfbf71979a2552cde508317631671a585543e0a9bf2efc692947fc04586c81ea01d13ddf033495dd0eefacda686e6316eb5267f0df5bd26a08e836e826e8ecedda2cb5476b1f565d6689224e3748abf4bd64b76c4cd4aeca085740a9a5abc15ec672101746c0ca583f85eb8425f40c408529945bbc21b754e8903168c192871ab5fd32d02bf012a4ddb5dd5215357611fac26d851602248e45b1be66ba5e02a539d74ea73f6abfc1be9ece36054dc01de42d448ab678cfdaa5847f59a2abc0c0d2d8c829a390ce1f03e5747aa4c35122358779a8f5a99e48e2259554405339f9f58695fc2df1b37d116e94ee5bdcc86b7ecc1dd6f23c610c9034ba5ef0747bfc8c650bf1dc44b007d212393a015ab6c9dc87e3162dd690385f5389e0ec49f527038cf172a4c5e53450ce52cbc7a4ea1d1361c9cb38606e28001c5f752068330726e36749045a77eccf617d4ef48eb0f2f7be0ccaf36002e1e2127894d52f5ecc027df4971a0643cb8e4738ec4b3314cc963b741aff138f2fae1c47c9cc56e38794bc50b23a0db17cab96ab70fc3e8068324a0942f8fcdbd4d54d23d859a214505c3dedcdc45235081e37542bd94ec8f1ae51a542bc2ad4f989d323a6ca23831f0395b53e027d2d807d9f69a36fac48bddd8a83b0c6aac2dcf21d98b52a978b864daec919201df7074e7e606004cad55cf0865c894118ee26538c43de0b07e74562d15baf4cfcde401e403161bd81f44e09d2196b6a8b5ce4ca7c01266abf0883555bac8a13e4be11e7634c41b729f754095bf2f77ccd8b589d613333d8e00af5133ae8c4b4249930d53fcb018670b7f3c0e1e9ec5eaa8dc3ee489cb120e62a7a662c0c9dc0b6b777b2ab69a3032d44b1dd8519a7e6a854c1a0a9d911989110bd301cd15372a0fbe2a627301411ad681129aa57e71e9f36a2653b9d24fa759addd502a2d22530f281a78227354050caa88d3f5a1672d2cee3e3f757c419c29a5ce4ad23a2b2172dcdaccee2023e545a0c0814c0d74d671e7d783779da8b180b865466ad9ace76b1a6b1cb185fdbcfb5920dfca406939eb62d7c10a9fcddc7fe2c91ff045ebd0021883cffa158f185fdff306e2f7a40253a323376456afac23132b9352022537bb3500823e622b1e567da57106ca54fad17ed37fa8fcad38f3721d0a2cfa05c49592444aae24d6b3800d60ec9fc5f1ae79473bdc2e5af019f3c3fe7d704dbb49fa014a393cc5b9c9c8b08aec7c28fbadc5cf1fca101e8a3529e7b70dfcdc9911db0fa63af701389b65b399d068d837675c57713f34865adc8bd569f16b2a755b06933d62b5aa00c25b9865276a8145b91913ecd78d6e433d743b7cb307873b03bc8c9403927dc4750cf427b551f</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法模板-二分</title>
      <link href="/2022/11/20/algoSummary/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF-%E4%BA%8C%E5%88%86/"/>
      <url>/2022/11/20/algoSummary/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF-%E4%BA%8C%E5%88%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2><span id="基础二分模板">基础二分模板</span></h2><p>有单调性的题目一定可以二分 但没有单调性不一定不可以二分<br>另外 最大值最小 最小值最大 –&gt; 二分</p><h2><span id="二分">二分</span></h2><h3><span id="闭区间写法-lr">闭区间写法 [l,r]</span></h3><p><strong>推荐这一种 最好记 最不容易出错</strong><br>闭区间就是在 定义初始l r的时候 l与r 都是直接取区间上的位置<br>即 <code>l = 0 , r = n - 1</code></p><p>对应代码 返回相等的数 前面的一个数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 相同找最前面的 </span></span><br><span class="line"><span class="comment">// 闭区间 写法 </span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">binary1</span><span class="params">(<span class="type">int</span> [] arr, <span class="type">int</span> x)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length;</span><br><span class="line">    <span class="comment">// l 与 r 直接取区间内的位置</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span> , r = n - <span class="number">1</span>; </span><br><span class="line">    <span class="comment">// l始终指向左半部分区域 r始终指向右半区域</span></span><br><span class="line">    <span class="comment">// 在闭区间上操作 所以 l与r始终应该是指向区间内的元素</span></span><br><span class="line">    <span class="comment">// 所以应该是 l&lt;=r 即只要区间不为空那么就继续循环 </span></span><br><span class="line">    <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">        <span class="comment">// left+(right - left) // 2     防溢出写法</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// arr[mid] &gt;= x</span></span><br><span class="line">        <span class="comment">// 则代表 mid + 1 到 r 这一段区间与x的关系是已经确定的</span></span><br><span class="line">        <span class="comment">//   (l x mid r ) 所以更新 r -&gt; (r = mid - 1) -&gt; l x r</span></span><br><span class="line">        <span class="keyword">if</span>(arr[mid] &gt;= x)&#123;</span><br><span class="line">            <span class="comment">// 即接下来要寻找的是  </span></span><br><span class="line">            <span class="comment">// [left,mid - 1]</span></span><br><span class="line">            r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 即需要找的是[mid + 1,right]</span></span><br><span class="line">            <span class="comment">// l mid x r -&gt; 更新 l &gt; l x r </span></span><br><span class="line">            <span class="comment">// 由于始终是在闭区间操作 所以l = mid</span></span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3><span id="开区间写法-左闭右开lr">开区间写法 左闭右开[l,r)</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 相同的找最前面的</span></span><br><span class="line"><span class="comment">// 开区间写法 左闭右开 [l,r)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">binary1</span><span class="params">(<span class="type">int</span> [] arr,<span class="type">int</span> x)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length;</span><br><span class="line">    <span class="comment">// 右开 即右指针始终指向数组边界外</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span> , r = n;</span><br><span class="line">    <span class="comment">// 左闭右开 所以当 左右相等时证明区间为空 则退出循环</span></span><br><span class="line">    <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(arr[mid] &gt;= x)&#123;</span><br><span class="line">            <span class="comment">// l x mid r</span></span><br><span class="line">            <span class="comment">// 所以下一步需要寻找的区间在 [l,mid - 1) 右开 所以r=mid 而不是mid - 1</span></span><br><span class="line">            r = mid;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// l mid x  r</span></span><br><span class="line">            <span class="comment">// 下一步需要寻找的是 [mid + 1, r)</span></span><br><span class="line">            l = mid + <span class="number">1</span>; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3><span id="开区间-左右都开-lr">开区间 左右都开 (l,r)</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 相同的找最前面的</span></span><br><span class="line"><span class="comment">// 开区间写法 左右都开 (l,r)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">binary1</span><span class="params">(<span class="type">int</span> [] arr,<span class="type">int</span> x)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length;</span><br><span class="line">    <span class="comment">// 左右都开 即左右指针都不指向区间内</span></span><br><span class="line">    <span class="comment">// 所以 l = - 1 ,  r = n</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> -<span class="number">1</span> , r = n;</span><br><span class="line">    <span class="comment">// 左右指针都不指向区间内</span></span><br><span class="line">    <span class="comment">// 所以当l  + 1 = r时 意味着区间为空</span></span><br><span class="line">    <span class="keyword">while</span>(l + <span class="number">1</span> &lt; r)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(arr[mid] &gt;= x)&#123;</span><br><span class="line">            <span class="comment">// l mid r -&gt; l x mid r</span></span><br><span class="line">            <span class="comment">// (l,mid - 1)</span></span><br><span class="line">            r = mid;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// l mid r -&gt; l mid x r</span></span><br><span class="line">            <span class="comment">// (mid + 1, r)</span></span><br><span class="line">            l = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(r &gt;= n || arr[r] != x)&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2><span id="gtx3d-转换为其他形式">&gt;&#x3D;  转换为其他形式</span></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">1. ```&gt;= x``` 转换为 &gt; x  即 ```&gt;= x + 1```</span><br><span class="line">2. ```&gt;= x``` 转换为 &lt; x  即 ```(&gt;=x) - 1```</span><br><span class="line">3. ```&gt;= x``` 转换为 &lt;= x 即 ```(&gt;x)  - 1```  -&gt; ```&gt;= x + 1``` - 1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 例题</span><br><span class="line"></span><br><span class="line">### leetcode 34 在排序数组中查找元素的第一个和最后一个位置</span><br><span class="line"></span><br><span class="line">原题链接:</span><br><span class="line">https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/description/</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">查找元素x的第一个位置和最后一个位置 即</span><br><span class="line">1.&gt;=x 的第一个位置</span><br><span class="line">2.&gt;=(x + 1) 的第一个位置前面的的一个位置</span><br><span class="line"></span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public int[] searchRange(int[] nums, int target) &#123;</span><br><span class="line">        int a = lower_bound(nums,target);</span><br><span class="line">        if(a &gt;= nums.length || nums[a] != target)&#123;</span><br><span class="line">            return new int [] &#123;-1,-1&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int b = lower_bound(nums,target + 1) - 1;</span><br><span class="line">        // a 存在那么b一定存在 因为大不了 a == b</span><br><span class="line">        return new int [] &#123;a,b&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // &gt;= </span><br><span class="line">    // 闭区间写法 [l,r]</span><br><span class="line">    public int lower_bound(int [] arr, int x)&#123;</span><br><span class="line">        int l = 0 , r = arr.length - 1;</span><br><span class="line">        while(l &lt;= r)&#123;</span><br><span class="line">            int mid = l + r &gt;&gt;1;</span><br><span class="line">            if(arr[mid] &gt;= x)&#123;</span><br><span class="line">                // l x mid r</span><br><span class="line">                // [l , mid - 1]</span><br><span class="line">                r = mid - 1;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                // l mid x r</span><br><span class="line">                // [mid + 1 , r]</span><br><span class="line">                l = mid + 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3><span id="leetcode-162-寻找峰值">leetcode 162 寻找峰值</span></h3><p>原题链接:<br><a href="https://leetcode.cn/problems/find-peak-element/">https://leetcode.cn/problems/find-peak-element/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findPeakElement</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">// 使用lower_bound 的闭区间写法</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span> , r = n - <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 证明 mid 要么是峰顶 或者 峰顶 在左侧</span></span><br><span class="line">            <span class="comment">// mid mid + 1 r</span></span><br><span class="line">            <span class="comment">// 即查找区间更新为[l , mid - 1]</span></span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt;= nums[mid + <span class="number">1</span>])&#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> l;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3><span id="leetcode-153-寻找旋转排序数组中的最小值">leetcode 153 寻找旋转排序数组中的最小值</span></h3><p>原题链接:<br><a href="https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/">https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    旋转一次的意思 最后一个元素往前置</span></span><br><span class="line"><span class="comment">    所以旋转后必定是分为 两段递增的序列</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    每次二分mid与最后一个元素x比较  </span></span><br><span class="line"><span class="comment">    mid &gt;= x 即 l x mid r  证明该段序列位于最小值的右边 否则 证明mid 是最小值 或者在mid左边是最小值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMin</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> lower_bound(nums);</span><br><span class="line">        <span class="keyword">return</span> nums[k];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lower_bound</span><span class="params">(<span class="type">int</span> [] arr)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span> , r = n - <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">last</span> <span class="operator">=</span> arr[n - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// l mid x  r </span></span><br><span class="line">            <span class="keyword">if</span>(arr[mid] &gt;= last)&#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3><span id="33-搜索旋转排序数组">33 搜索旋转排序数组</span></h3><p>法1: 直接二分 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    双重判断 还是与最后一个数last 比较 </span></span><br><span class="line"><span class="comment">    记录要寻找的数为 x   x &gt; last  则证明存在x  </span></span><br><span class="line"><span class="comment">    而如果mid &gt;= x  则证明x 位于 l mid 这一段</span></span><br><span class="line"><span class="comment">    否则 x 位于 mid + 1 , r 这一段</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="comment">// n - 1 为last 不加入 比较</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span> , r = n - <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(check(nums,target,mid))&#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(l &gt;= n || nums[l] != target)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">check</span><span class="params">(<span class="type">int</span> [] arr,<span class="type">int</span> target , <span class="type">int</span> mid)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">last</span> <span class="operator">=</span> arr[arr.length - <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// mid &gt;= last </span></span><br><span class="line">        <span class="comment">// mid 此时处于last 右边 l last mid r</span></span><br><span class="line">        <span class="comment">// r = mid - 1</span></span><br><span class="line">        <span class="keyword">if</span>(arr[mid] &gt;=  last)&#123;</span><br><span class="line">            <span class="comment">// target 与 mid 属于 同区间</span></span><br><span class="line">            <span class="comment">// l (last) mid r last</span></span><br><span class="line">            <span class="comment">// l target mid r last</span></span><br><span class="line">            <span class="comment">// 即可以确定mid 右边为另外一种性质的序列 且target与mid处于同种性质的序列中</span></span><br><span class="line">            <span class="keyword">return</span> target &gt; last &amp;&amp; arr[mid] &gt;=  target;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//  l mid last r</span></span><br><span class="line">            <span class="comment">//  如果target &gt; last   l mid (last)  target r  因为是有序递增的 证明 target处于第一个有序递增区间 即mid 的右边是另外一种性质的序列 </span></span><br><span class="line">            <span class="comment">//  如果 arr[mid] &gt;= target</span></span><br><span class="line">            <span class="comment">// l target mid (last)  r  则证明mid target均属于第一个有序递增区间 即mid 右半部分为另外一种性质序列 </span></span><br><span class="line">            <span class="keyword">return</span> target &gt; last || arr[mid] &gt;= target;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3><span id="leetcode35-搜索插入位置">leetcode35 搜索插入位置</span></h3><p>原题链接:<br><a href="https://leetcode.cn/problems/search-insert-position/description/">https://leetcode.cn/problems/search-insert-position/description/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">searchInsert</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="comment">// 练习一下 开区间写法</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> - <span class="number">1</span> , r = n;</span><br><span class="line">        <span class="keyword">while</span>(l + <span class="number">1</span>  &lt; r)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt;= target)&#123;</span><br><span class="line">                r = mid;                </span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                l = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3><span id="leetcode-209-长度最小的子数组">leetcode 209 长度最小的子数组</span></h3><p>原题链接:<br><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/description/">https://leetcode.cn/problems/minimum-size-subarray-sum/description/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">    前缀和 + 二分</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> [] sum = <span class="keyword">new</span> <span class="title class_">int</span> [n + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 前缀和数组 </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span> ; i &lt;= n ; i++)&#123;</span><br><span class="line">            sum[i] = sum[i - <span class="number">1</span>] + nums[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> n + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历 nums 的右端点i 寻找满足 sum[i - mid] = sum[i] - sum[mid] &gt;= target  条件的 mid的最小值</span></span><br><span class="line">        <span class="comment">// 即 sum[i] - target &gt;= sum[mid] </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span> ; i &lt;= n ; i++)&#123;</span><br><span class="line">            <span class="comment">// sum[i] 表示 nums[0] ... nums[i - 1]的加和</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> sum[i] - target;</span><br><span class="line">            <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span> , r = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(l + <span class="number">1</span> &lt; r)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// l mid d  r </span></span><br><span class="line">                <span class="comment">// r 应该是返回的 sum[r] &gt;= d 的第一个位置</span></span><br><span class="line">                <span class="comment">// 所以要求 sum[r] &lt;= d 即 sum[r] &gt; d 的第一个位置的前一个位置 即 sum[r] &gt;= d + 1 的前一个位置</span></span><br><span class="line">                <span class="comment">// d &lt;= sum[mid]</span></span><br><span class="line">                <span class="comment">// l x mid r</span></span><br><span class="line">                <span class="keyword">if</span>(sum[mid] &gt;= d + <span class="number">1</span>)&#123;</span><br><span class="line">                    r = mid;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    l = mid;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果存在答案 </span></span><br><span class="line">            <span class="comment">// r == 0 表示 该数已经在区间外了 肯定不是答案</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(r &gt; <span class="number">0</span> &amp;&amp; r &lt;  i + <span class="number">1</span> &amp;&amp; sum[r - <span class="number">1</span>] &lt;=  d)&#123;</span><br><span class="line">                <span class="comment">// r = r - 1;</span></span><br><span class="line">                <span class="comment">// r - 1是答案的位置 即 sum[i] - sum[r - 1] 为所求子数组</span></span><br><span class="line">                <span class="comment">// 其元素为 nums[r] , nums[r + 1] , nums[r + 2] , ... , nums[i] 为 i - r + 1个数  </span></span><br><span class="line">                ans = Math.min(ans,i - r + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans == n + <span class="number">10</span> ? <span class="number">0</span> : ans ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="leetcode-240-搜索二维矩阵-ii">leetcode 240 搜索二维矩阵 II</span></h3><p>原题链接:<br><a href="https://leetcode.cn/problems/search-a-2d-matrix-ii/description/">https://leetcode.cn/problems/search-a-2d-matrix-ii/description/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">searchMatrix</span><span class="params">(<span class="type">int</span>[][] matrix, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="comment">// 抽象BST</span></span><br><span class="line">        <span class="comment">// 右上角为根 向左为左子树 向下为右子树</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> matrix.length, m = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span> , y = m - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(x &lt; n &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; matrix[x][y] != target)&#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[x][y] &gt; target)&#123;</span><br><span class="line">                y--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                x++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(x &gt;= n || y &lt; <span class="number">0</span>  || matrix[x][y] != target)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3><span id="leetcode-278-第一个错误的版本">leetcode 278 第一个错误的版本</span></h3><p>原题链接:<br><a href="https://leetcode.cn/problems/first-bad-version/description/">https://leetcode.cn/problems/first-bad-version/description/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* The isBadVersion API is defined in the parent class VersionControl.</span></span><br><span class="line"><span class="comment">      boolean isBadVersion(int version); */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> <span class="keyword">extends</span> <span class="title class_">VersionControl</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">firstBadVersion</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">// 这题刚好会溢出到爆int那一位 用这种闭区间的写法 会好一些</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">1</span> ,  r = n;</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">tmp</span> <span class="operator">=</span> (<span class="type">long</span>)  l + r  &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (<span class="type">int</span>)tmp;</span><br><span class="line">            <span class="comment">// 所有版本出错的第一个错误 </span></span><br><span class="line">            <span class="comment">// 即 &gt;= </span></span><br><span class="line">            <span class="comment">// l x  mid  r </span></span><br><span class="line">            <span class="keyword">if</span>(isBadVersion(mid))&#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3><span id="leetcode-69-x-的平方根">leetcode 69 x 的平方根</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">mySqrt</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = x;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">mid</span> <span class="operator">=</span> l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="type">long</span> <span class="variable">tmp</span> <span class="operator">=</span> mid * mid;</span><br><span class="line">            <span class="keyword">if</span>(tmp &gt;= x)&#123;</span><br><span class="line">                r = (<span class="type">int</span>)mid - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                l = (<span class="type">int</span>)mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里因为返回的时第一个大于等于的值 但答案有可能是位于 [x,x + 1]</span></span><br><span class="line">        <span class="keyword">if</span>(l * l &gt;= x + <span class="number">1</span>)&#123;</span><br><span class="line">            l--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="acwing旧模板-不推荐使用-整数二分-边界情况">Acwing旧模板 不推荐使用 整数二分 边界情况</span></h2><p>二分一共两个模板 适用于两种不同的情况</p><ol><li><p>版本1<br>满足check()区间内找左边界 -&gt; 将区间划分为 [l,mid] 和 [mid + 1, r] 时<br>其每次操作都将 r &#x3D; mid 或者 l &#x3D; mid + 1 , 计算mid时不需要加1 (可以看r r不加1 那么 mid就不加1)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">binary_search</span>(<span class="type">int</span> x)&#123;</span><br><span class="line">    <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(x))&#123;</span><br><span class="line">            r = mid;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>版本2<br> 满足check()区间内找右边界 -&gt; 将区间划分为 [l,mid - 1] 和 [mid,r]<br> 其每次操作都将 r &#x3D; mid - 1或 l &#x3D; mid , 为了防止死循环 计算时要将mid + 1</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">binary_search</span>(<span class="type">int</span> x)&#123;</span><br><span class="line">    <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(x))&#123;</span><br><span class="line">            l = mid;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3><span id="c-二分库函数">c++ 二分库函数</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    lower_bound 返回 第一个大于等于 x 的位置 </span></span><br><span class="line"><span class="comment">    (也就是当查询到多个等于x的数时 返回前面那个)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;q;</span><br><span class="line"><span class="type">int</span> low = <span class="built_in">lower_bound</span>(q.<span class="built_in">begin</span>(),q.<span class="built_in">end</span>(),x) - q.<span class="built_in">begin</span>();</span><br><span class="line"><span class="comment">// 得到对应的数</span></span><br><span class="line">cout &lt;&lt; q[low] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    这里注意 如果想要返回多个等于x的数 后面的那个</span></span><br><span class="line"><span class="comment">    不能直接用下面的upper_bound 而应该对lower_bound 进行转化</span></span><br><span class="line"><span class="comment">    如下</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 返回第一个大于 x 的数 的第一个位置的前面一个位置 即多个等于x的数中 最后面那个数</span></span><br><span class="line">    low = <span class="built_in">lower_bound</span>(q.<span class="built_in">begin</span>(),q.<span class="built_in">end</span>(),x + <span class="number">1</span>) - q.<span class="built_in">begin</span>() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    upper_bound 返回 第一个大于x的位置</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> upp = <span class="built_in">upper_bound</span>(q.<span class="built_in">begin</span>(),q.<span class="built_in">end</span>(),x) - q.<span class="built_in">begin</span>();</span><br><span class="line">cout &lt;&lt; q[upp] &lt;&lt; endl;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2><span id="四种二分求有序数组-类型的转换-以golang为例">四种二分求有序数组 类型的转换 (以Golang为例)</span></h2><p>有序数组的二分一共就四种类型:</p><blockquote><p>&#x3D; &gt; &lt; &lt;&#x3D;<br>最常见的类型是 &gt;&#x3D; 例如go的内置二分函数就是求的&gt;&#x3D;<br>(&gt;&#x3D;问题:即 返回有序数组中第一个 &gt;&#x3D; x 的数的位置 如果所有数都 &lt; x 返回数组长度)<br>但是这四种类型的求解都可以在 <strong>&gt;&#x3D;</strong> 的形式基础上进行转换<br>记 要二分查找的这个数为x</p></blockquote><ol><li>大于 &gt;  -&gt; &gt;&#x3D; x + 1      大于等于x+1这个数</li><li>小于 &lt;  -&gt; (&gt;&#x3D; x) - 1    大于等于x左边的一个数</li><li>小于等于 &lt;&#x3D; -&gt;  ( &gt; x) - 1   大于x左边的一个数 即 大于等于x+1左边的一个数</li></ol><h2><span id="例题总结">例题总结</span></h2><p>二分本身这个点比较简单 但可以和其他很多形式的题目进行结合<br><font color="red"><strong>经典例题总结</strong></font><br><font color="purple">难度值:1 对于模板的基本应用</font><br><a href="#%E6%95%B0%E7%9A%84%E8%8C%83%E5%9B%B4">数的范围</a><br><font color="purple">难度值:2 结合一些基本场景</font><br><a href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E6%9C%80%E8%BF%91%E8%8A%82%E7%82%B9%E6%9F%A5%E8%AF%A2">二叉搜索树最近节点查询</a><br><font color="purple">难度值3:结合场景 且思维难度较高</font><br><a href="#%E8%A2%8B%E5%AD%90%E9%87%8C%E6%9C%80%E5%B0%91%E6%95%B0%E7%9B%AE%E7%9A%84%E7%90%83">袋子里最少数目的球</a></p><h3><span id="数的范围"><p id="#数的范围">数的范围</p><p></p></span></h3><p>原题链接:<br><a href="https://www.acwing.com/problem/content/791/">https://www.acwing.com/problem/content/791/</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">int</span> n,q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i &lt; n ; i++)&#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> l,r;    </span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="type">int</span> k;</span><br><span class="line">        cin &gt;&gt; k;</span><br><span class="line">        <span class="comment">// 寻找最左边的点 即符合check() 找左边界</span></span><br><span class="line">        l = <span class="number">0</span>;</span><br><span class="line">        r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">            <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(a[mid] &gt;= k)&#123;</span><br><span class="line">                r = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 没找到的情况</span></span><br><span class="line">        <span class="keyword">if</span>(a[l] != k)&#123;</span><br><span class="line">            cout&lt;&lt; <span class="string">&quot;-1 -1&quot;</span>&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ans[<span class="number">0</span>] = l;</span><br><span class="line">        </span><br><span class="line">        l = <span class="number">0</span>;</span><br><span class="line">        r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">            <span class="type">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(a[mid] &lt;= k)&#123;</span><br><span class="line">                l = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans[<span class="number">1</span>] = l;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">2</span>;i++)&#123;</span><br><span class="line">            cout&lt;&lt;ans[i]&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="二叉搜索树最近节点查询"><p id="#二叉搜索树最近节点查询">二叉搜索树最近节点查询</p><p></p></span></h3><p>原题链接:<br><a href="https://leetcode.cn/problems/closest-nodes-queries-in-a-binary-search-tree/">https://leetcode.cn/problems/closest-nodes-queries-in-a-binary-search-tree/</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *`     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">closestNodes</span><span class="params">(root *TreeNode, queries []<span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> inorder <span class="function"><span class="keyword">func</span><span class="params">(root *TreeNode)</span></span></span><br><span class="line">    q := []<span class="type">int</span>&#123;&#125;</span><br><span class="line">    inorder = <span class="function"><span class="keyword">func</span><span class="params">(root *TreeNode)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        &#125;</span><br><span class="line">        inorder(root.Left)</span><br><span class="line">        q = <span class="built_in">append</span>(q,root.Val)</span><br><span class="line">        inorder(root.Right)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    inorder(root)</span><br><span class="line">    </span><br><span class="line">    ans := [][]<span class="type">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> _,v := <span class="keyword">range</span> queries&#123;</span><br><span class="line">        a := sort.SearchInts(q,v + <span class="number">1</span>) - <span class="number">1</span></span><br><span class="line">        b := sort.SearchInts(q,v)</span><br><span class="line">        <span class="keyword">if</span> a &gt;= <span class="built_in">len</span>(q) || a &lt; <span class="number">0</span>&#123;</span><br><span class="line">            a = <span class="number">-1</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            a = q[a]</span><br><span class="line">            <span class="keyword">if</span> a &gt; v&#123;</span><br><span class="line">                a = <span class="number">-1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> b &gt;= <span class="built_in">len</span>(q) &#123;</span><br><span class="line">            b = <span class="number">-1</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            b = q[b]</span><br><span class="line">            <span class="keyword">if</span> b &lt; v &#123;</span><br><span class="line">                b = <span class="number">-1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ans = <span class="built_in">append</span>(ans,[]<span class="type">int</span>&#123;a,b&#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="袋子里最少数目的球"><p id="#袋子里最少数目的球">袋子里最少数目的球</p><p></p></span></h3><p>原题链接:<br><a href="https://leetcode.cn/problems/minimum-limit-of-balls-in-a-bag/">https://leetcode.cn/problems/minimum-limit-of-balls-in-a-bag/</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    最大值最小 ---&gt; 二分</span></span><br><span class="line"><span class="comment">    二分最大值 </span></span><br><span class="line"><span class="comment">    l = 0 , r = 最大值 </span></span><br><span class="line"><span class="comment">    经过op次操作 将最大值分摊给其他数 从而达成mid 当op &lt;= maxOperations 为符合条件 则继续向左区间寻找(最小化最大值)</span></span><br><span class="line"><span class="comment">    即check() 符合条件的在左区间 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> m,<span class="type">int</span> maxOperations,vector&lt;<span class="type">int</span>&gt;&amp;nums)</span></span>&#123;</span><br><span class="line">        <span class="comment">// m = 0 时  ops为无穷大 肯定是大于maxOperations 不符合条件</span></span><br><span class="line">        <span class="keyword">if</span>(m == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ops = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp; x : nums)&#123;</span><br><span class="line">            <span class="comment">// 如果当前值超过了 所设定的最大值</span></span><br><span class="line">            <span class="comment">// 则其差距需要 (x - 1)/m 次操作进行弥补  </span></span><br><span class="line">            <span class="comment">// m - 1 下取整 </span></span><br><span class="line">            ops += (x - <span class="number">1</span>)/ m;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ops &lt;= maxOperations)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minimumSize</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> maxOperations)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span> , r = *<span class="built_in">max_element</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">            <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">check</span>(mid,maxOperations,nums))&#123;</span><br><span class="line">                r = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 二分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三日间的幸福</title>
      <link href="/2022/11/19/book/%E4%B8%89%E6%97%A5%E9%97%B4%E7%9A%84%E5%B9%B8%E7%A6%8F/"/>
      <url>/2022/11/19/book/%E4%B8%89%E6%97%A5%E9%97%B4%E7%9A%84%E5%B9%B8%E7%A6%8F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><img src="/2022/11/19/book/%E4%B8%89%E6%97%A5%E9%97%B4%E7%9A%84%E5%B9%B8%E7%A6%8F/图1-封面图.jpg" style="zoom:50%">"自动贩卖机总是站在原地为人提供服务，对吧？只要投钱就随时为人们提供温暖。自动贩卖机总能让人感觉到一种果断、稳定、永恒的特制呢"<p>我觉得男主楠木的一些经历和想法和我很像 浑浑噩噩的过去人生的前20年 没有花时间和精力去维护友谊只是孤独会想起来 好在我目前还有唯数不多的几个朋友<br>但真的是用一个手指头就能数完<br>小说整体还是比较平淡的 不过豆瓣评分8.0 有人留言说比较一般 但不得不承认确实 因为楠木前20岁的人生真的除了他和那个青梅竹马姬野的一点点小暧昧的描述外<br>作者就没怎么进行描写的 最后男主发现宫城善意的谎言那里算是一个小意外吧 但总的来说楠木卖掉寿命后的三个月并没有发生什么事情<br>反倒是不断击碎楠木之前对现实的一些美好幻想 每次宫城揭晓答案 我觉得可以预料 有点令人难受 却也非常合理<br>楠木之前的遇到学妹 在刚刚开始有好感的时候没有及时接住 但楠木想到的时候感觉过去就是过去了 无法挽回<br>之前的高中好友也是 友谊随时间消逝 况且那个好友本身并不如他之前想象的那么好<br>最后宫城也揭晓了自己的答案 真的这个世界上没有谁是不可或缺 更多时候可能都是自以为是 甚至成为了别人幸福路上的绊脚石</p>]]></content>
      
      
      <categories>
          
          <category> book </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>diary-2022-11-19</title>
      <link href="/2022/11/19/life/diary-2022-11-19/"/>
      <url>/2022/11/19/life/diary-2022-11-19/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="4298531499d55bf0cd77b16f07a051b339b350a36b4138828fa14ad2318262f9">abb32f68827b16598088320c52df6dceed8d5732823a156d7b7dde0f3ca94ce092d793d245a28467421de433918fe97783ad87d643071b4aac7499e49ea5d4381e0064624190220d04ef98e0846cc340b317838685ec2d0257a5425bfdef7ecd9e788dade6781cb45b4ac1d6bd43e978fd16cb72fa694331a67f8ff722dffb14aab72e6896ff650d5259397a72346fd2ddd410f4006d3d56397c9b1b45482969ce61e6bd38d82118dba608ebfd01048537512b3583452b2c8f8136da476aade1c424c4d4ce8b36ae78f4ac19b370f987b8b9f4e9c67b4007c77a34a95b89e390b34bfe74768ba11b7f05b9f7074f3b62a67a52337916bb19e1fe9f5e4c1e62573e5b723fea962d91b818e28f9a6e7de3637d4e9dee13ed2cbd960d406c19ac61ae688ae0dac4ea8ee50c45afa828530aa98de3457ef00a5d791b39a0d0960e15db43e7b7796972472d2b2f35d2a2ef85203755ecbfc5321cb4cf07e93bcd317d1ce8b9fecc4b58df4fd81d4f7502172ee4e3fa1400dc12a2963bed64a0745549b44a2fa2d0e7014d2d81297a062c3cf4ec9f70418ad0b6df994cedf03cc7f932e8799f7f9d75e983bbc0b3542d77baad646363bd7140becfbc1c734b3ae5cdf9c196633df4ef7ea3b9f605f0012488312d6eb338f5669739994fac6415c82d9fa952c44fc2cc98e9817408b7844c4c08d41981d11e0e12a988f68743d638df53ecd6a7d3ab6b7ddc8c2a7dc51807d6dcb8839116e2b60c3f29d9b597ee534254f076448d4dc03ffe572171f5804201bd006ee1ba02b8242240fc719cf60c2b0c6e30d7f5c427a6dce0a92b82e569a9eed44793e7958b3d9096d31908935c9c55a7796fa891c6eee0a3c6752f91e977af4fb71eea523bca653dd5220de4e4f27435cb9a920c9b7523625627172e4156a5c776033cb01860f5a9eb267f13f11400192283eed889c8c7bf82a93e81629ffbd9f890a2e32877cdb37ff4e70bb69ef3e473528094c3ad405abffc010f879a2e74e870c3d402b8091df2c75ad08b88d79ec20a7f93243cd9b885e9124f0e4d6812b55556d4dd639a5cf56890d5a67b801fb5afea6bf733284b0a9f66fd046c75cb56a3858e4c4d87f539525f0fb845b6283ebd26588157614613185bcd34e2b6c59d1f1cc93329b7943ea8723815e289e008c577451b87987c3f0b2b404388d42f7c073b91d6cc06120c01ecdb83154d706703b9200538a64da520af809179bead8351ae0a0e11854e414cff4c43d2269bc057c779ef43e89f14fe90518081656c8afcd37616470220631f53a602edbbe327e38cdc8af537f9e6d91a8295e007b8b8566f7a71b2c842eedf19b14b907d824c898900f2ab5956f3427c77632999f205c3fedda84828610d5e43cbe7a4faf8e19cd6ab2784a8a2e3f791b33b0e6218c105298732c2c4e962b27a261ba230b4893a899ecd98dbecef7dba00a5a8585883c21b72f3d0b5c4005feebeb07328ffa1850af9dd53a96245da4fe26a0a3a02d9b260cdf6854727267fa597d00c58a1b60014ad689276e9f23db4b3693aed9be0ac0f645fc3079c2fe0f6b67a6a4512460f9d89ab62cf8c3fc4b056b53b97d6448af0940e52c723a69a003486e813cd8c6def6b9cc47c28ea639e34162da77026dd51e250182c2cd9782343d474819aa96ec7c5cb59af24c6df05c59256b69213990b08f7f76a247504c1706ebf36141d46affc092dcc85ab194d211e63d93d3829b65950461dc2dddcbae43dfd9b0be9ab828d74b1232e2d67c1e2968c5cbdc39c5c1c31b766cc434165f9bd34794d96037453bb14931b26fbc5a22f03ce30131e6c7539be2731bdf0c0889f9032d086005cd68d8d0b8261df70db41548ceffe470fd91dd8b65fd47ff9deae2b34a9c2022b53a0a2cd42ee13ef27a1a5a9ad1c2e212b9faa8f850364b464114622897178a84d93de0d87abc3e64c11d27503b709ddbb9991d931b7d4a55d844da1d352a5005d64828d540b22cf3c01602d8584f9de33975af9dca205e69d6c585b0d9f4998c3602c0523374fd563172e0a652b3e46dcc32fb27fb6bd159f60da2ea27361cb827f7cffc7973b734b369cea7e86d19f94aa826da1bd154ff703993000a3540397ccf320e8b59fa88074b2ccbeff409180aff093175d2dd5becc62a6239e72d0e7759af718830a08642523ac6fc9e4f6e0628685b0b4286e98cb6082603864faf6802e6e5f65f32549f3651aa3bdbcfa0acab1df7ec4866c44f37f18cdd9e83a17ba7102b93fffc6f10b90f8a65a37667341dd529de217626552fdbc395dd79f0c0c20054ed139d3fac49dec61b13c22ca02a2be0a890b45f0066ab0725bfe929a101415be4c40e4fe1a32439cf9d9d55806f0f5abe42bacdb4134500c68290a825f8ac9ba1c12d96de70d20aa725b66ec69d9a0c5e79f0034583f636df8c33418f3dcca30a2a1e4650e44a63dd57dd066b1f60e139aa17552be0551ae9873741ff80b6b299168d42c7988885a12720efb86fd7ea88a3ba2bf1691de96fb1434e307807bd20a38f6f3f1a3f88536612435a98ff427d8441a0f594e02773539611c71fdbc93c9db226a7e02495d9100589c0e25a271427b2d85a66069cb68538f37d18fd3d5a672318b9c09dce855c2ac50c6da38633d1114668e05e4</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode891子序列宽度之和</title>
      <link href="/2022/11/18/leetcode/leetcode891%E5%AD%90%E5%BA%8F%E5%88%97%E5%AE%BD%E5%BA%A6%E4%B9%8B%E5%92%8C/"/>
      <url>/2022/11/18/leetcode/leetcode891%E5%AD%90%E5%BA%8F%E5%88%97%E5%AE%BD%E5%BA%A6%E4%B9%8B%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>原题链接:<br><a href="https://leetcode.cn/problems/sum-of-subsequence-widths/">https://leetcode.cn/problems/sum-of-subsequence-widths/</a></p><h2><span id="贡献值法">贡献值法</span></h2><ol><li>子序列为去掉某个数后的序列 即不要求连续</li><li>只关注最大最小值 则与序列顺序无关<br>由 1 2 分析可得我们可以对子序列排序后进行求解<br>以排序后结果为 1 2 3 4 5 6 的序列为例<br>对于4来说<br>1 - 4 构成的序列均可选4 作为最大值<br>4 - 6 构成的序列均可选4 作为最小值<br>宽度值的定义为 最大值 - 最小值<br>因此4 对于宽度值的贡献为<br>[1 - 4]所构成序列中的所有最大值 - [4 -6]所构成序列中所有最小值<br>根据乘法原理其贡献值为:  2 ^ (4) - 2 ^ (6 - 4) &#x3D; 8<br>将其进行推广则对排序后每个数x的贡献值为:<br><font color="purple"><strong>x * 2^(i) - 2^(n -  1 - i)</strong></font> (其中i为x在排序后序列中的位置 n序列总长)</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;sort&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> MOD <span class="type">int</span> = <span class="type">int</span>(<span class="number">1e9</span>) + <span class="number">7</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">abs</span><span class="params">(x <span class="type">int</span>)</span></span><span class="type">int</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> x &lt; <span class="number">0</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> -x</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sumSubseqWidths</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">n := <span class="built_in">len</span>(nums)</span><br><span class="line">sort.Slice(nums, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line"><span class="keyword">return</span> nums[i] &lt; nums[j]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 预处理2的平方</span></span><br><span class="line">pow := <span class="built_in">make</span>([]<span class="type">int</span>, n)</span><br><span class="line">pow[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt; n; i++ &#123;</span><br><span class="line">pow[i] = pow[i<span class="number">-1</span>] * <span class="number">2</span> % MOD</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ans := <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, x := <span class="keyword">range</span> nums &#123;</span><br><span class="line">ans += x * (pow[i] - pow[n<span class="number">-1</span>-i]) </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最后这里由于可能最后算出来是一个负数 </span></span><br><span class="line">    <span class="comment">// 所以要负数取模</span></span><br><span class="line"><span class="keyword">return</span> (ans % MOD + MOD) % MOD</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algo </category>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贡献值法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode792匹配子序列的单词数</title>
      <link href="/2022/11/17/leetcode/leetcode792%E5%8C%B9%E9%85%8D%E5%AD%90%E5%BA%8F%E5%88%97%E7%9A%84%E5%8D%95%E8%AF%8D%E6%95%B0/"/>
      <url>/2022/11/17/leetcode/leetcode792%E5%8C%B9%E9%85%8D%E5%AD%90%E5%BA%8F%E5%88%97%E7%9A%84%E5%8D%95%E8%AF%8D%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>原题链接:<br><a href="https://leetcode.cn/problems/number-of-matching-subsequences/">https://leetcode.cn/problems/number-of-matching-subsequences/</a></p><h2><span id="法1分桶排序">法1:分桶排序</span></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">numMatchingSubseq</span><span class="params">(s <span class="type">string</span>, words []<span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="comment">// 以每个首字母为分类的桶</span></span><br><span class="line">d := <span class="built_in">make</span>([][]<span class="type">string</span>,<span class="number">26</span>)</span><br><span class="line"><span class="comment">// 初始分桶</span></span><br><span class="line"><span class="keyword">for</span> _, w := <span class="keyword">range</span> words &#123;</span><br><span class="line">u := w[<span class="number">0</span>] - <span class="string">&#x27;a&#x27;</span></span><br><span class="line">d[u] = <span class="built_in">append</span>(d[u], w)</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//fmt.Println(d)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">进行分桶判断</span></span><br><span class="line"><span class="comment">如果当前桶的长度为1 且包含在s中 则ans++</span></span><br><span class="line"><span class="comment">如果当前包含而不为1 则去掉当前的首字母 按照新的首字母重新分桶</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">ans := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">u := s[i] - <span class="string">&#x27;a&#x27;</span></span><br><span class="line"><span class="keyword">for</span> _, w := <span class="keyword">range</span> d[u] &#123;</span><br><span class="line"><span class="keyword">if</span> w[<span class="number">0</span>] - <span class="string">&#x27;a&#x27;</span> == u &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(w) == <span class="number">1</span> &#123;</span><br><span class="line">ans++</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 去除首字母后 按照新的首字母重新分桶</span></span><br><span class="line">d[w[<span class="number">1</span>]-<span class="string">&#x27;a&#x27;</span>] = <span class="built_in">append</span>(d[w[<span class="number">1</span>]-<span class="string">&#x27;a&#x27;</span>], w[<span class="number">1</span>:])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">            <span class="comment">// 如果第一个字符相等的话 那么经过以上操作后 当前操作的串就要排除了</span></span><br><span class="line">            <span class="comment">// 如果不相等由于是按顺序遍历的 所以相对顺序一定是不等的也直接排除</span></span><br><span class="line">            d[u] = d[u][<span class="number">1</span>:]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="法2-二分">法2: 二分</span></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;sort&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">二分:</span></span><br><span class="line"><span class="comment">哈希存储s 中每个字母出现的下标</span></span><br><span class="line"><span class="comment">遍历中words 每个word w</span></span><br><span class="line"><span class="comment">对于word中的每个字母c</span></span><br><span class="line"><span class="comment">先将指针i指向-1 在d[c]中二分查找第一个大于i的位置j</span></span><br><span class="line"><span class="comment">(因为相对顺序要一样c在s中出现的位置一定要在上一个位置i之后 所以是第一个大于i的位置j)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">numMatchingSubseq</span><span class="params">(s <span class="type">string</span>, words []<span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">d := [<span class="number">26</span>][]<span class="type">int</span>&#123;&#125;</span><br><span class="line"><span class="comment">// 建立hash ch -&gt; i</span></span><br><span class="line"><span class="keyword">for</span> i, ch := <span class="keyword">range</span> s &#123;</span><br><span class="line">        u := ch - <span class="string">&#x27;a&#x27;</span></span><br><span class="line">d[u] = <span class="built_in">append</span>(d[u], i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">check := <span class="function"><span class="keyword">func</span><span class="params">(w <span class="type">string</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line"><span class="comment">// 初始位置为 -1</span></span><br><span class="line">i := <span class="number">-1</span></span><br><span class="line"><span class="keyword">for</span> k := <span class="number">0</span>; k &lt; <span class="built_in">len</span>(w); k++ &#123;</span><br><span class="line">c := w[k] - <span class="string">&#x27;a&#x27;</span></span><br><span class="line"><span class="comment">// 返回的是大于i的第一个位置 所以二分找的是i+1 且go本身二分就是右端点二分</span></span><br><span class="line">j := sort.SearchInts(d[c], i+<span class="number">1</span>)</span><br><span class="line"><span class="comment">// 出界 那么这个点就不存在</span></span><br><span class="line"><span class="keyword">if</span> j == <span class="built_in">len</span>(d[c]) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">i = d[c][j]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">ans := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> _, w := <span class="keyword">range</span> words &#123;</span><br><span class="line"><span class="keyword">if</span> check(w) &#123;</span><br><span class="line">ans++</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 二分 </tag>
            
            <tag> 分桶排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo使用总结</title>
      <link href="/2022/11/17/hexo%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"/>
      <url>/2022/11/17/hexo%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2><span id="hexo-new-命令的使用">hexo new 命令的使用</span></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认在 source/_post 目录下新一篇文章</span></span><br><span class="line">hexo new text</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按照指定模板建立 文章</span></span><br><span class="line"><span class="comment"># 这个模板 layout 可以根据需求以md 的形式创建于scaffolds文件夹</span></span><br><span class="line">hexo new [layout_name] text</span><br><span class="line"><span class="comment"># 例如</span></span><br><span class="line">hexo new algo text</span><br><span class="line"></span><br><span class="line"><span class="comment"># 要指定在某个文件下创建文章</span></span><br><span class="line"><span class="comment"># 如下所示 加上 --path参数 则会在 about/me 文件夹下创建about me.md</span></span><br><span class="line">hexo new page --path about/me <span class="string">&quot;about me&quot;</span></span><br><span class="line"><span class="comment"># 例如 </span></span><br><span class="line"><span class="comment"># 以algo 模板 创建leetcode/leetcode198打家劫舍      文章的标题名为 leetcode198打家劫舍</span></span><br><span class="line">hexo new algo --path leetcode/leetcode198打家劫舍  <span class="string">&quot;leetcode198打家劫舍&quot;</span> </span><br><span class="line">hexo new 面试真题  --path 面试真题/2美团面经汇总  <span class="string">&quot;美团面经汇总&quot;</span>    </span><br><span class="line"></span><br></pre></td></tr></table></figure><h2><span id="hexo-创建分类页面">hexo 创建分类页面</span></h2><ol><li>新建一个页面，命名为 categories :<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page categories</span><br></pre></td></tr></table></figure></li><li>编辑刚新建的页面，将页面的类型设置为 categories ，主题将自动为这个页面显示所有分类。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">title: 分类</span><br><span class="line"><span class="built_in">date</span>: 2023-12-22 13:49:04</span><br><span class="line"><span class="built_in">type</span>: <span class="string">&quot;categories&quot;</span></span><br><span class="line">---</span><br></pre></td></tr></table></figure></li></ol><h2><span id="hexo-插入图片">hexo 插入图片</span></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># src   图像源</span></span><br><span class="line"><span class="comment"># style 图片大小</span></span><br><span class="line">&lt;img src = <span class="string">&quot;/Redis集群化部署/图2-redis-conf配置图.png&quot;</span> style = <span class="string">&quot;zoom:75%&quot;</span> &gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> dev </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法模板-树状数组</title>
      <link href="/2022/11/16/algoSummary/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF-%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
      <url>/2022/11/16/algoSummary/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF-%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2><span id="基本操作">基本操作</span></h2><p>树状数组 主要应用于单点修改和区间查询<br>核心操作就3个 lowbit \ add \ query</p><ol><li><p>lowbit<br>lowbit 返回二进制最后一位的数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lowbit</span><span class="params">(x)</span></span><span class="type">int</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; -x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>add<br>为某一个位置x 加上一个数v (如果是减的话可以减去这个数的负数)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(x,v <span class="type">int</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> i:= x ; i &lt;= n ; i+=lowbit(x)&#123;</span><br><span class="line">        tr[i] += v</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>query<br>查询 1-x区间的数组和</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">query</span><span class="params">(x <span class="type">int</span>)</span></span><span class="type">int</span>&#123;</span><br><span class="line">    res := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i:= x ; i &gt; <span class="number">0</span> ; i-=lowbit(x)&#123;</span><br><span class="line">        res += tri[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2><span id="树状数组例题整理">树状数组例题整理</span></h2><p>只要符合两个条件 就可以重点考虑使用树状数组 单点修改和区间查询<br>当然符合其中一个条件也可以 只是没那个必要 均有更好的替代方法<br><font color="purple"> 难度1: 模板题 (很久没写找找感觉用)</font><br><a href="#%E5%8A%A8%E6%80%81%E6%B1%82%E8%BF%9E%E7%BB%AD%E5%8C%BA%E9%97%B4%E5%92%8C">动态求连续区间和</a></p><h3><span id="动态求连续区间和"></span></h3><p>原题链接:<br>https://www.acwing.com/problem/content/1266/</p><p>acwing上的题用go 会有些问题 尤其是那些输入输出复杂的最好还是用c++ 当然也只可能时创始人比较懒没有做好适配…<br>比如这题… 用go就会有换行问题 最后居然也会超时就比较离谱</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1E5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> q[N],tr[N];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=x ; i&lt;=n; i+=<span class="built_in">lowbit</span>(i))&#123;</span><br><span class="line">        tr[i] += v;       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=x ; i &gt; <span class="number">0</span> ; i -= <span class="built_in">lowbit</span>(i))&#123;</span><br><span class="line">        res += tr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span> ; i &lt;= n ; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;q[i]);</span><br><span class="line">        <span class="built_in">add</span>(i,q[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span> ; i &lt; m ; i++)&#123;</span><br><span class="line">        <span class="type">int</span> k,a,b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;k,&amp;a,&amp;b);</span><br><span class="line">        <span class="keyword">if</span>(!k)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">query</span>(b) - <span class="built_in">query</span>(a - <span class="number">1</span>));</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">add</span>(a,b);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algo </category>
          
          <category> 算法总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树状数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode775全局倒置与局部倒置</title>
      <link href="/2022/11/16/leetcode/leetcode775%E5%85%A8%E5%B1%80%E5%80%92%E7%BD%AE%E4%B8%8E%E5%B1%80%E9%83%A8%E5%80%92%E7%BD%AE/"/>
      <url>/2022/11/16/leetcode/leetcode775%E5%85%A8%E5%B1%80%E5%80%92%E7%BD%AE%E4%B8%8E%E5%B1%80%E9%83%A8%E5%80%92%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>原题链接:<br><a href="https://leetcode.cn/problems/global-and-local-inversions/">https://leetcode.cn/problems/global-and-local-inversions/</a><br>本质是一个判断逆序对的问题</p><h2><span id="法1-推理">法1 推理</span></h2><p>全局倒置 全局内 逆序的数对<br>局部倒置 相邻的逆序对<br>因此<strong>局部倒置 一定是 全局倒置</strong><br>即 全局倒置 &gt;&#x3D; 局部倒置<br>因此全局逆序对的产生方式 必须与局部逆序对相同<br>即 存在所有逆序对必须都是相邻逆序 如果不是相邻逆序 则为false</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line"><span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isIdealPermutation</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">mx := nums[<span class="number">0</span>]</span><br><span class="line">    n := <span class="built_in">len</span>(nums)</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">2</span> ; i &lt; n ; i++&#123;</span><br><span class="line">        mx = max(mx,nums[i<span class="number">-2</span>])</span><br><span class="line">        <span class="keyword">if</span> mx &gt; nums[i]&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="法2-树状数组">法2 树状数组</span></h2>]]></content>
      
      
      <categories>
          
          <category> algo </category>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树状数组 </tag>
            
            <tag> 逆序对 </tag>
            
            <tag> 推理题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis集群化部署</title>
      <link href="/2022/11/15/dev/Redis%E9%9B%86%E7%BE%A4%E5%8C%96%E9%83%A8%E7%BD%B2/"/>
      <url>/2022/11/15/dev/Redis%E9%9B%86%E7%BE%A4%E5%8C%96%E9%83%A8%E7%BD%B2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>毕业设计时 我使用redis与token结合的方式来实现商城用户信息的验证 redis的部署采用了 主从复制 以及哨兵模式 保证了高可用性 最后实现的效果也很不错 现将其总结如下:<br><strong>为什么要采取主从复制+哨兵模式集群部署主要基于以下原因:</strong></p><ol><li>1.由于用户的验证信息存储于redis 只要redis宕机 那么所有用户将不可登录网页<br>2.2.主从模式只能实现信息的备份 也就是说主机redis宕机后虽然从机会存储有主机的信息 但客户端与redis的连接无法自动从主机切换到从机 这是因为在springboot 的yml文件配置 客户端与redis以ip:端口的形式进行 绑定除非手动配置文件</li><li>3.想要实现redis自动主从切换 就要使用到哨兵 每个哨兵监视整个redis集群 只要有一个哨兵就能实现主从切换 但是因为哨兵存在宕机的可能所以哨兵也要集群化部署</li></ol><h2><span id="redis集群部署架构示意图">redis集群部署架构示意图</span></h2><img src="/2022/11/15/dev/Redis%E9%9B%86%E7%BE%A4%E5%8C%96%E9%83%A8%E7%BD%B2/图1-redis集群部署架构示意图.png"><h2><span id="redis集群-linux环境下的配置">redis集群 linux环境下的配置</span></h2><img src="/2022/11/15/dev/Redis%E9%9B%86%E7%BE%A4%E5%8C%96%E9%83%A8%E7%BD%B2/图2-redis-conf配置图.png" style="zoom:75%">如上图所示在conf/ 中创建以下配置文件:3台用做redis服务器redis-6379.conf，redis-6380.conf，redis-6381.conf，3台用做哨兵，它们的配置文件分别为sentienl-26379.conf，sentinel-26380.conf，sentienl-26381.conf。<p>redis-6379.conf 的配置如下:<br><img src="/2022/11/15/dev/Redis%E9%9B%86%E7%BE%A4%E5%8C%96%E9%83%A8%E7%BD%B2/图3-redis6379配置图.png" style="zoom:70%"><br>sentienl-26379.conf 的配置如下:<br><img src="/2022/11/15/dev/Redis%E9%9B%86%E7%BE%A4%E5%8C%96%E9%83%A8%E7%BD%B2/图4-redis26379配置图.png" style="zoom:70%"></p><p>然后分别以redis-server和redis-sentinel命令以加载配置文件的方式的方式对redis服务器和redis哨兵进行启动。效果如下图所示:<br><img src="/2022/11/15/dev/Redis%E9%9B%86%E7%BE%A4%E5%8C%96%E9%83%A8%E7%BD%B2/图5-redis进程启动图.png"><br>可以看到通过ps命令（一种显示进程的命令）集合-ef（一种过滤信息的命令）grep命令（一种搜索相关信息的命令）可以得到redis进程的启动情况。Redis服务器分别启动6379、6380、6381端口，而redis哨兵则分别启动在26379、26380、26381端口。即linux下redis的环境已经顺利的搭建完毕了。</p><h2><span id="redis主从复制模式实现商城数据备份">redis主从复制模式实现商城数据备份</span></h2><p>总的来说主从复制就是多台服务器连接方案，注意主从复制这里还没有用哨兵服务器仅仅是多台redis服务器的连接，在本商城模拟搭建的环境中以一台服务器用作写即作为数据的提供方master，两台服务用于读即数据的接收方slave。本项目的模拟环境中当作master的redis服务器为6379端口所运行的，当作slave的为运行在6380、6381端口的。<br>开启redis服务器后 通过redis-cli可以连接运行在不同端口的服务器，用info指令可以获取它们的属性状态信息。<br><img src="/2022/11/15/dev/Redis%E9%9B%86%E7%BE%A4%E5%8C%96%E9%83%A8%E7%BD%B2/图6-redis-cli-slave图.png" style="zoom:75%"><br>如上图所示为redis-6379的部分状态信息，下面对于几个参数进行说明。Role:master 表示该主机的角色为master即负责写，这与我们的设定是一致的。Connect_slaves:2表示当前主机有两个从机，即两个用作读作为数据备份。Slave0:127.0.0.1,port&#x3D;6381,state&#x3D;online，表示slave0的ip为127.0.0.1端口为6381当前为在线状态。<br>本商城项目连接的redis为主机6379，那么当用户正常登录时其token便会先存入主机redis-6379，然后会在两个从机6380和6381中均进行备份<br>如下图所示为用户登录后使用google浏览获取的网页端存储的token值。这个值会与存储与redis中token值进行验证从而判定用户的登陆状态。<br><img src="/2022/11/15/dev/Redis%E9%9B%86%E7%BE%A4%E5%8C%96%E9%83%A8%E7%BD%B2/图7-网页端token信息图.png"><br>然后查看一下 此时各个redis服务器的存储信息:<br><img src="/2022/11/15/dev/Redis%E9%9B%86%E7%BE%A4%E5%8C%96%E9%83%A8%E7%BD%B2/图8-redis6379存储信息图.png" style="zoom:50%"><br><img src="/2022/11/15/dev/Redis%E9%9B%86%E7%BE%A4%E5%8C%96%E9%83%A8%E7%BD%B2/图9-redis6380存储信息图.png" style="zoom:50%"><br><img src="/2022/11/15/dev/Redis%E9%9B%86%E7%BE%A4%E5%8C%96%E9%83%A8%E7%BD%B2/图10-redis6381存储信息图.png" style="zoom:50%"><br>根据上面几张图可以看到用户的token值已正确存储于redis中且完成了复制备份，那么这样即使redis6379机器出现故障出现丢失，由于redis6380和redis6381中已存储数据，所以数据可正常恢复，且可通过哨兵模式选举新的主机，由于数据是一样的新选举出的主机仍可使得服务器正常运行，从而实现了高可用性。</p><h2><span id="redis哨兵模式实现容灾">redis哨兵模式实现容灾</span></h2><p>Redis哨兵模式是一个分布式系统。本商城项目主要使用哨兵模式对于主从结构中的每台服务器进行监视，防止redis宕机从而导致tokne值丢失，服务端无法对用户信息进行验证从而影响用户正常正常登录系统情况的发生。而当redis出现宕机时，哨兵会通过投票机制选择出新的master并将所有slave连接到新的master，从而保证系统的正常运行，即完成商城的容灾处理。哨兵在运行期间会通过心跳机制不断检查redis服务器的运行状况，当被监控的服务器出现问题时，会向其他哨兵发送通知。当master发生故障时会自动实施故障转移断开master与slave连接选一个slave作为新的master，将其他slave连接到新的master上，并通知客户端新的服务地址。<br>本商城项目的使用的redis集群模式为3个哨兵加上3个redis服务器，其中redis服务器的配置1主2从，即一个redis服务器作为master，另外两个redis服务器作为slave。需要注意的是三个哨兵在配置时都只监控主机的就可以了，因为主机本身拥有两个从服务器的相关信息，所以只要监控了主服务器自然就可以获取从服务器的情况。下面展示哨兵的相关配置信息:<br><img src="/2022/11/15/dev/Redis%E9%9B%86%E7%BE%A4%E5%8C%96%E9%83%A8%E7%BD%B2/图11-sentienl26379配置信息图.png" style="zoom:70%"><br>如上图所示，为其中一台哨兵sentienl-26379的相关配置信息，port 26379表面sentienl将会启动在26379端口，sentienl announce-ip “192.168.118.145”为哨兵配置时的声明ip，这是因为redis部署在linux上，而linux的ip会发生变化所以客户端要从外部访问需声明ip地址，不然访问时会带来一定的问题。Sentienl moitor mymatser 192.168.118.145 6380 2，表明指明主节点信息为ip地址为192.168.118.145，端口为6380的节点，其quorum值为2，表明当其中一个redis下线时此时判定为主观下线，若整个系统中有其他两个哨兵发现已经下线，则将其判定为客观下线，当客观下线后redis集群将会选举出新的主节点。下面从几个情况依次查看节点发生故障后对于商场项目运行产生的相关的影响。另外由于本商城项目的配置为多台redis的集群配置，所以客户端连接时也会有所不同。<br><img src="/2022/11/15/dev/Redis%E9%9B%86%E7%BE%A4%E5%8C%96%E9%83%A8%E7%BD%B2/图12-哨兵模式节点监听图.png" style="zoom:65%"><br>如上图所示为redis集群模式下启动的信息，不同于单机启动，redis以哨兵模式集群启动时所需要连入的节点为哨兵而非服务器本身，这是因为哨兵本身就会监控服务器即哨兵本身就掌握了服务相关的运行信息，所以只要监控了哨兵那么对于服务器的运行情况也就了解，也就可以正确的服务器中配置信息。<br>另外对于客户端从redis中获取的信息的方式做以下配置，该配置是以配置类的形式的生成。<br><img src="/2022/11/15/dev/Redis%E9%9B%86%E7%BE%A4%E5%8C%96%E9%83%A8%E7%BD%B2/图13-redis读写配置类.png" style="zoom:70%"><br>如图所示，在customize函数个性化配置了关于redis读写的相关选项，Read.REPLICA_PREFERRED该配置意味，客户端优先从slave服务器读取相关信息，当slave服务器均下线后再考虑从master中读取相关信息。这是因为在主从模式中master负责写功能，而slave则负责从master中读，这启到读写分离的作用。本商城项目借助xshell连接linux虚拟机，以3哨兵3redis服务器的形式启动，其中由于哨兵会产生相关的日志信息且该信息与本文所研究的故障恢复机制有密切关系，哨兵的启动不采取守护进程的方式。<br><img src="/2022/11/15/dev/Redis%E9%9B%86%E7%BE%A4%E5%8C%96%E9%83%A8%E7%BD%B2/图14-redis集群启动结果图.png" style="zoom:70%"><br>如上图为使用linux，ps命令所获得的当前虚拟机内redis的结果，可以看到三个redis服务器，三个哨兵均以正常启动。可以看到redis当服务器的进程信息显示均有sentinel标志这便是显示为哨兵的标志。<br>下面将redis哨兵的服务器的日志内容用以解释说明此时本商城项目的redis集群中服务器运行结构以及状况。<br><img src="/2022/11/15/dev/Redis%E9%9B%86%E7%BE%A4%E5%8C%96%E9%83%A8%E7%BD%B2/图15-sentinel运行日志图.png" style="zoom:80%"><br>上图为sentienl-26379哨兵的运行情况，由于本项目在启动哨兵时的顺序为sentienl-26379、sentienl-26380、sentienl-26381，所以sentienl-26379哨兵是拥有完整的监控信息以及整个redis集群的构建情况，故以sentienl-26379的运行日志对于本商城项目所使用的哨兵集群构建状况进行说明。<br>可以看到sentinel-26379启动时，会首先生成自身的sentinel id，这是用于之后哨兵集群之间相互通信所使用的。然后会显示当前所监控的主节点信息，+monitor master mymaster 192.168.118.145 6380 quorum 2，这便对应了在配置文件对于监控主节点信息的相关配置。接下来依次将sentienl-26380和sentienl-26381启动可以看到日志中打印+sdown sentienl信息这表明以及新启动的sentinel加入对应的节点，且新加入的这sentienl所监视的节点也为192.168.118.145 6380。<br><img src="/2022/11/15/dev/Redis%E9%9B%86%E7%BE%A4%E5%8C%96%E9%83%A8%E7%BD%B2/图16-项目运行结果图.png" style="zoom:70%"><br>开启项目，进入登录界面后，可以顺利加载出验证码，且控制台没有产生报错信息，由于验证码的相关信息是存储在redis中，可以证明此时以哨兵集群的模式启动redis没有任何问题，项目正常运行。<br>那么接下来检验集群模式下主从模式的运行状态。<br><img src="/2022/11/15/dev/Redis%E9%9B%86%E7%BE%A4%E5%8C%96%E9%83%A8%E7%BD%B2/图17-哨兵模式master情况图.png" style="zoom:70%"><br><img src="/2022/11/15/dev/Redis%E9%9B%86%E7%BE%A4%E5%8C%96%E9%83%A8%E7%BD%B2/图18-哨兵模式slave情况图.png" style="zoom:70%"><br>可以看到正常登录后redis服务器在哨兵集群模式运行情况可以进行正常的主从复制模式，读写完全正常。<br>接下来进行哨兵模式下故障恢复的试验。杀死master服务器的进程后观察哨兵服务器的日志输出情况，以及项目的运行情况。<br><img src="/2022/11/15/dev/Redis%E9%9B%86%E7%BE%A4%E5%8C%96%E9%83%A8%E7%BD%B2/图19-使用kill命令杀死master进程图.png" style="zoom:65%"><br>如上图所示可以看到我们已经成功杀死了redis master服务器的进程，接下来先查看项目信息。<br><img src="/2022/11/15/dev/Redis%E9%9B%86%E7%BE%A4%E5%8C%96%E9%83%A8%E7%BD%B2/图20-杀死进程后的项目信息图.png" style="zoom:65%"><br>可以看到当master发生故障后，客户端检测到了异常开始了重连，首先选择重连的是原master即192.168.118.145:6380但由于该服务器已经被我们强制下线了所以该重连请求被拒绝。接下来重连到192.168.118.145:6381以及192.168.118.145:6379，而这里主要就取决于redis哨兵服务器所进行的投票选举结果选出的是谁，那么哪个主机就可以连接成功。那么现在我们查看一下sentienl日志信息。<br><img src="/2022/11/15/dev/Redis%E9%9B%86%E7%BE%A4%E5%8C%96%E9%83%A8%E7%BD%B2/图21-sentinel26379日志记录图.png" style="zoom:75%"><br>可以看到当master下线后第一时刻sentienl日志信息首先输出的是sdown master，而sdown为主观下线，然后通过各个slave之间的互相通信，输出odown master，观其后的注释可以看到此时quorum已经为2&#x2F;2，即已经达到客观下线的标准，所以进行odown mymaster。然后接下来进行投票选举+vote-for-leader，以及一系列投票，然后最终选出新的master为192.168.118.145 6381。并将相关信息重写入配置文件。而我们通过redis-cli连接6381的redis服务器，并查看其信息可以发现，此时其角色已经转化为master，而只连接了一个slave，因为6379已经被强制下线，所以整个redis服务器集群只有两台服务器，一个master一个从服务器。<br>下图使用info命令查看的 redis-6381的信息<br><img src="/2022/11/15/dev/Redis%E9%9B%86%E7%BE%A4%E5%8C%96%E9%83%A8%E7%BD%B2/图23-redis6381info图.png" style="zoom:70%"><br>再回到项目网页主界面可以看到仍可正常运行，并无任何异常。<br>且仍有存有与之前完全相同的token信息值。<br><img src="/2022/11/15/dev/Redis%E9%9B%86%E7%BE%A4%E5%8C%96%E9%83%A8%E7%BD%B2/图24-token信息图.png" style="zoom:80%"></p>]]></content>
      
      
      <categories>
          
          <category> dev </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
            <tag> dev </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试记录2022-2天翼阅读文化</title>
      <link href="/2022/11/13/interview-%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%952022-2%E5%A4%A9%E7%BF%BC%E9%98%85%E8%AF%BB%E6%96%87%E5%8C%96/"/>
      <url>/2022/11/13/interview-%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%952022-2%E5%A4%A9%E7%BF%BC%E9%98%85%E8%AF%BB%E6%96%87%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>我最开始是在1月份寒假的时候投简历 那时候考研成绩还悬而未决 加上网上又在散播焦虑 觉得自己也不能这样闲着 就在学redis\docker 这些想自己搞一个小项目出来 最好是能整出一个小网站来(当然这个目标在暑假的时候才实现 当时还提前买了服务器和域名)<br>快到2月份时开始在实习僧上投简历 投的都是实习岗 其实这个时候投实习岗已经有些不合适了 因为那时我已经马上要大四下了 自然也吃了比较多的闭门羹 记的刚开始几天实习僧上的回复都是已查看 然后就没了回复 又过了几天出现了几个不合适 可能是因为我简历包装的不错 有几个hr 问了我一下2022应届 还是2023应届 我说是22的 然后就婉拒说抱歉只要23应届的(好像是阿里的一个hr) 这之后就是一直等待 然后一边准备项目学学springboot那套 一边准备复试<br>然后就在一个下午收到了 天翼阅读的面试电话 当是接到电话的时候我都有些蒙 那边的人说我的简历经过了二轮 才到他的手上 不得不说当时真的是运气好 但也是真的卷当时真的是有些没反应过来 匆匆忙忙的自我介绍后 面试官就就开始提问了 可能当时真的蛮紧张有几个基础的问题都答的不是很好 我硬憋了几句话后 也只能加上一句 不好意思 我这些没有注意到 对面那边反而在安慰我说没关系 不得不说这个面试管还温和的 这个人也成我后来实习的技术总监 负责带我 整个面试过程大概就20分钟 我感觉有些短 也觉得没了后续<br>后来几乎是放弃希望了 然后hr加了我的微信 和约了二面的时间 也就是现场面试 当时有些激动 没想到居然能进二面 因为我觉得自己真的没发挥好 二面约在了我返校那天 上午到杭州后到公司旁的一个小旅馆休息了一下(这个旅馆后面实习的时候又)就去面试了 二面真的比一面简单太多了 是主管面 面的也很基础 到一半的时候有人有事找他 然后面试就结束 过了两天收到offer </p><h1><span id="2022-2-14-天翼文化">2022 2 14 天翼文化</span></h1><p>第一次面试没有任何准备电话就打过来了 刚开始很紧张 自我介绍也就只有潦草的几句 问了好几个基础的问题都答的不是很好 甚至回答不上来 等慢慢的找到感觉 人冷静下来以后 面试也差不多结束了 不过面试官还是比较柔和基本在鼓励我 说没关系 有点可惜 没想到第一家面的就是一个国企感觉错过了一个很好的机会 18分钟好像的确太快了一些<br>后续:<br>进二面了 有些意外 二面是主管 感觉比一面水了很多 问的问题也简单很多 聊10多分钟 下面有人有事情找他 他就下去了 然后就直接结束了过了大概3天左右拿到offer<br>总的来说比较顺利 整个面试过程面试官都很温和</p><h1><span id="一面回忆">一面回忆</span></h1><h2><span id="1mysql-主要引擎-innodb-myisam-merge">1.mysql 主要引擎 InnoDB Myisam MERGE</span></h2><p> InnoDB是默认存储引擎  InnoDB是事务性存储引擎 也就是说InnoDB支持事务性存储</p><p><strong>MyISAM和InnoDB区别</strong></p><p>  MyISAM虽然性能极佳 而且提供大量特性包括全文索引 压缩 空间函数等 但MyISAM不支持事务和行级锁，</p><p>而且最大的缺陷是崩溃后无法安全恢复  MySQL5.5版本后默认的存储引擎为InnoDB</p><p>  大多数时候我们使用的是InnoDB存储引擎 但是在某些情况下使用MyISAM也是比较合适的 比如读密集的情况</p><h2><span id="2mysql使用的索引">2.mysql使用的索引</span></h2><p>MySQL索引使用的数据结构主要有BTree索引和哈希索引 </p><p><strong>对于哈希索引来说</strong> 底层的数据结构就是哈希表  因此在绝大多数需求为单挑记录查询时 可以选择哈希索引 查询性能最快</p><p>查询性能最快 其余大部分场景 建议使用BTree索引</p><p>MySQL的BTree索引使用的是B树中的B+Tree 但对于主要的两种存储引擎的实现方式是不同的</p><p><strong>MYISAM(非聚簇索引):</strong> B+Tree叶节点的data域存放的是数据记录的地址。在索引检索的时候 首先按照B+Tree搜索算法搜索索引 </p><p>如果指定的Key存在 则取出其data域的值  然后以data域的值为地址读取相应的数据记录 这被称为”非聚簇索引”</p><p><strong>InnoDB(聚簇索引)</strong>: 其数据文件本身就是索引文件 相比MyISAM 索引文件和数据是<strong>分离</strong>的 其表结构数据文件本身就是按B+Tree组织的</p><p>一个索引结构 树的叶节点data域保存了完整的数据记录 这个索引的key是数据表的主键是数据库的主键 因此InnoDB表数据文件本身就是</p><p>主索引 这被称为聚簇索引 而其余索引都作为辅助索引 辅助索引的data域存储相应的记录主键的值而不是地址</p><p>根据主索引搜索时: 直接找到key所在的节点 即可取出数据 </p><p>根据辅助索引搜索时: 先取出主键的值 再走一遍主索引</p><p>因此设计表的时候 不建议使用过长的字段作为主键 也不建议使用非单调的字段作为主键 这样会造成主索引频繁分裂</p><h2><span id="3操作系统是如何管理内存的">3.操作系统是如何管理内存的</span></h2><p>操作系统内存管理的功能(即操作系统内存管理要做什么):</p><p>1.内存的分配与回收</p><p>内存分配：</p><p>​连续分配(会有碎片):</p><p>​ 单一连续分配 固定分区分配(内部碎片) 动态分配(外部碎片)</p><p>​ 分配算法:首次适应 最佳适应 最坏适应 邻近适应</p><p>​非连续分配(虚拟内存): </p><p>​分页管理: 将主存空间划分为大小相等的块 </p><p>​分段管理: 按照程序自身逻辑划分成若干段 每个段有一个段名 每段从0开始编址</p><p>​段页式</p><p>空闲内存管理:  1.位示图   2.链表: (即动态分配 每一项都可以代表一个空闲区 或者是 进程的起始标志 用分配算法进行管理)</p><p>2.地址转换：将逻辑地址转换为物理地址</p><p>页表: 针对大内存的页表 多级页表 倒排页表</p><p>快表(TLB位于MMU中): 就是一种内存缓存 通常位于CPU和CPU缓存之间 </p><p>3.内存空间的扩充 : 覆盖和交换技术</p><p>4.存储保护</p><h2><span id="4操作系统虚拟内存">4.操作系统虚拟内存</span></h2><p>虚拟地址: 程序生成的地址 通过MMU(内存管理单元)把虚拟地址映射为物理内存地址</p><p>局部性原理: 空间局部性和时间局部性</p><p>基于局部性原理 在程序装入内存的时 只会将程序的一部分装入内存 就可以启动程序 在程序执行过程中如果需要的信息</p><p>不在内存中 可以由操作系统将那一部分数据再调入内存 如果操作系统暂时不需要某些内容 可以将其调到外存上 从而腾出</p><p>空间供别的作业使用</p><p>实现:</p><p>请求分页: </p><p>​页表机制 缺页中断  </p><p>​页面置换算法(OPT最佳置换算法 FIFO先进先出算法 LRU最近最久未使用算法  时钟置换算法)</p><p>​工作集页面置换算法: 目的减少缺页中断的次数</p><p>​根据研究表明 大多数程序并不是均匀的访问地址空间 而访问往往是集中于一小部分页面 一次内存访问可能会取出一条指令</p><p>​也可能会取出数据 或者存储数据 再任一时刻t 都在一个集合 它包含所有最近k次访问所访问过的页面 这个集合就是工作集</p><p>请求分段:</p><h2><span id="5计算机网络-一台计算机将数据传输到另一台计算机所经历的过程">5.计算机网络 一台计算机将数据传输到另一台计算机所经历的过程</span></h2><p>分两种情况</p><p><strong>1.两台计算机在同一个局域网</strong></p><p>PC-A————-PORT1-Switch-PORT2————-PC-B</p><p>1.PC-A产生的报文如下（报文封装）：</p><p>步骤1.PC-A通过应用层（应用程序如qq等）产生应用层数据报文，然后报文传给传输层封装源目端口号(<a href="https://www.zhihu.com/search?q=tcp/udp&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:513257125%7D">tcp&#x2F;udp</a>)，我们把该阶段的报文称为数据段。</p><p>步骤2.传输层处理完成后数据报文交给TCP&#x2F;IP协议中的<a href="https://www.zhihu.com/search?q=%E7%BD%91%E7%BB%9C%E5%B1%82&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:513257125%7D">网络层</a>处理，在网络层处理阶段，网络层主要是给数据段报文添加源目IP地址，在该阶段我们把报文称为<a href="https://www.zhihu.com/search?q=%E6%95%B0%E6%8D%AE%E5%8C%85&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:513257125%7D">数据包</a>。</p><p>步骤3.数据包传递数据链路层处理，数据链路层的主要作用是协商链路间的协议(链路层常见的协议有<a href="https://www.zhihu.com/search?q=%E4%BB%A5%E5%A4%AA%E7%BD%91&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:513257125%7D">以太网</a>，PPP，IPX等)；这里我们以日常生活中常见的以太网举例。</p><p>在以太网中，数据链路层的主要作用是为数据包封装上源（PC-A的MAC）目（PC-B的MAC）MAC地址。我们把该阶段的报文称为数据帧。</p><p>如果PC-Bmac未知，在该阶段PC-A发送ARP广播获取PC-B的MAC地址</p><p>步骤4.数据链路层处理完成后，数据报文交给TCP&#x2F;IP中的物理层（物理层可以理解成PC的物理网卡）来处理，物理层主要作用是通过物理网卡把数据帧通过电信号或光信号传递到网络设备上。</p><p>2.交换机工作过程：</p><p>步骤1.交换机接收到PC-A发送的首个ARP广播报文，首先学习ARP报文Ethernet头部的源MAC地址，交换机芯片将自动记录PC-A的MAC地址、接收该ARP报文的交换机接口号(PORT1)及此接口所属的VLAN(如VLAN10)等信息,并形成一条MAC表项放入<a href="https://www.zhihu.com/search?q=%E4%BA%A4%E6%8D%A2%E6%9C%BAMA&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:513257125%7D">交换机MA</a>C表中，交换机形成PC-A的MAC表项。并且将该报文从除了PORT1外的其它端口转发出去。</p><p>步骤2.PC-B接收到PC-A产生的ARP报文后，解封装发现报文是请求自己的MAC地址的。然后回复ARP 回复报文（ARP报文有两种：request，reply报文）。<a href="https://www.zhihu.com/search?q=%E4%BA%A4%E6%8D%A2%E6%9C%BA%E8%8A%AF%E7%89%87&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:513257125%7D">交换机芯片</a>将自动记录PC-B的MAC地址、接收该ARP报文的交换机接口号(PORT2)及此接口所属的VLAN(如VLAN10)等信息,并形成一条MAC表项放入交换机MAC表中，交换机形成PC-B的MAC表项.</p><p>步骤3.交换机根据步骤2生成的MAC表项条目，将PC-A产生的目的MAC为PC-B的报文从PORT2口转发至PC-B</p><p>**2.不在同一个网段时 **</p><p>网络拓扑如下：</p><p>network1中的主机A（PCA）发送报文给另一局域网（network2）的主机B，中间经过一台路由器（Router），那么这台路由器就是PC-A的网关</p><p>PC-A——network1———-PORT1-Router-PORT2—network2—–PC-B&#x2F;</p><p>1.PC-A产生的报文如下（报文封装）：</p><p>步骤1.PC-A通过应用层（应用程序如qq等）产生应用层数据报文，然后报文传给传输层封装源目端口号(tcp&#x2F;udp)，我们把该阶段的报文称为数据段。</p><p>步骤2.传输层处理完成后数据报文交给TCP&#x2F;IP协议中的网络层处理，在网络层处理阶段，网络层主要是给数据段报文添加源目IP地址，在该阶段我们把报文称为数据包。</p><p>步骤3.数据包传递数据链路层处理，数据链路层的主要作用是协商链路间的协议(链路层常见的协议有以太网，PPP，IPX等)；这里我们以日常生活中常见的以太网举例。</p><p>在以太网中，数据链路层的主要作用是为数据包封装上源（PC-A的MAC）目（PC-B的MAC）MAC地址。我们把该阶段的报文称为数据帧。</p><p>如果PC-Bmac未知，在该阶段PC-A发送ARP广播获取PC-B的MAC地址</p><p>步骤4.数据链路层处理完成后，数据报文交给TCP&#x2F;IP中的物理层（物理层可以理解成PC的物理网卡）来处理，物理层主要作用是通过物理网卡把数据帧通过电信号或光信号传递到网络设备上。</p><p>2.路由器接收到该报文后，报文在路由器中的转发过程：</p><p>步骤1、路由器收到这个报文，先检查报文中的目的MAC，发现其目的MAC为本机Port1端口的，表明需要本机来进行进一步解析（如果目的MAC不是本机，表明直接进行二层转发，不需要再解析帧的其他内容了）；</p><p>步骤2、路由器进一步解析报文，得知帧所承载的协议类型为IPv4（协议类型值&#x3D;0x800），即需要进行IPv4转发；</p><p>步骤3、查IP转发表（FIB表），得知该报文并不是发给自己的，而是需要送往出端口Port2，因此，路由器不再继续分析IP头后面的内容。</p><p>步骤4、路由器将目的MAC更换成PC-B的MAC，将源MAC更换成出接口Port2的MAC，并将报文从Port2发送出去。</p><p>3.PC-B从物理网卡接收到该报文后，PC-B的对报文的处理过程（报文解封装）：</p><p>步骤1.PC-B的物理网卡（物理层）接收到该报文，PC-B先检查该报文目的MAC地址是否为自己网卡的MAC地址（如果是则接收并进行下一步处理，不是就丢弃该报文）；</p><p>步骤2.剥离帧头部，PC-B检查数据包中的目的IP地址字段是否为网卡IP地址，如果是择进行下一步处理</p><p>步骤3.剥离数据包头部，露出数据段报文头部；PC-B检查帧头部传输层端口号（TCP&#x2F;UDP端口号），然后进行下一步处理</p><p>步骤4.PC-B根据端口号把报文交给相应的应用程序处理（如https&#x3D;443，http&#x3D;80）。</p><h2><span id="6jvm的内存管理">6.JVM的内存管理</span></h2><h2><span id="7排序算法-说说你知道的排序算法-并说一下两种算法结合使用的情况">7.排序算法 (说说你知道的排序算法 并说一下两种算法结合使用的情况)</span></h2><p>快速排序 冒泡排序 希尔排序  选择排序 归并排序 堆排序 计数排序 基数排序</p><h2><span id="8java并发框架-juc">8.java并发框架 JUC</span></h2><h2><span id="9linux-搜索字符串命令">9.Linux 搜索字符串命令</span></h2><p>grep</p><h2><span id="10b树和平衡二叉树有什么区别">10.B+树和平衡二叉树有什么区别</span></h2><p>首先要说一下B树<br>B树是多路平衡查找树 是avl的升级 B树每层会有多个节点  B树的分支结点和叶子节点都存储着数据 每个结点存储M&#x2F;2到M个关键字，非叶子结点存储指向关键字范围的子结点；所有关键字在整颗树中出现，且只出现一次，非叶子结点可以命中；<br>然后B+ 又是再B树的基础上为叶子结点增加链表指针，所有关键字都在叶子结点中出现，非叶子结点作为叶子结点的索引；B+树总是到叶子结点才命中；</p><h2><span id="11聊聊红黑树">11.聊聊红黑树</span></h2><p>红黑树本质是对 2-3-4树的一种实现</p><p>2-3-4树是阶数为4的B树 (O(Log(N))</p><h2><span id="12说说你项目中使用redis-bitmap实现的签到功能具体是怎么做的">12.说说你项目中使用redis bitmap实现的签到功能具体是怎么做的</span></h2>]]></content>
      
      
      <categories>
          
          <category> interview </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试记录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode1386安全电影座位-求补集</title>
      <link href="/2022/11/13/leetcode/leetcode1386%E5%AE%89%E5%85%A8%E7%94%B5%E5%BD%B1%E5%BA%A7%E4%BD%8D-%E6%B1%82%E8%A1%A5%E9%9B%86/"/>
      <url>/2022/11/13/leetcode/leetcode1386%E5%AE%89%E5%85%A8%E7%94%B5%E5%BD%B1%E5%BA%A7%E4%BD%8D-%E6%B1%82%E8%A1%A5%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>原题链接:<br><a href="https://leetcode.cn/problems/cinema-seat-allocation/">https://leetcode.cn/problems/cinema-seat-allocation/</a><br>这题首先要注意到的一个信息是 1 &lt;&#x3D; n &lt;&#x3D; 10^9 即n 范围为10^9 也就是说 即使O(n) 也不行<br>但是有注意到 1 &lt;&#x3D; reservedSeats.length &lt;&#x3D; min(10*n, 10^4) 即要占座位的数量只有10^4 是一个比较小的数 因此可以考虑逆向求解 求出最大正确答案数 2 * n(关于正确答案也比较简单 因为根据题意最多每行只能放两个家庭 )<br>然后就是可以进行二进制优化 用一个二进制数代表每行的座位排列 1 表示该位已经被占 0 表示空位 将占座信息记录到hash表中 然后反向排除即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxNumberOfFamilies</span>(<span class="params">self, n: <span class="built_in">int</span>, reservedSeats: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        d = defaultdict(<span class="built_in">int</span>)</span><br><span class="line">        <span class="keyword">for</span> x,y <span class="keyword">in</span> reservedSeats:</span><br><span class="line">            <span class="keyword">if</span> y == <span class="number">1</span> <span class="keyword">or</span> y == <span class="number">10</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="comment"># 将2-9 映射到0-8 方便后续判断 所以要左移y-2</span></span><br><span class="line">            d[x] |= <span class="number">1</span> &lt;&lt; y-<span class="number">2</span></span><br><span class="line"></span><br><span class="line">        ans = <span class="number">2</span> *  n - <span class="number">2</span> * <span class="built_in">len</span>(d)</span><br><span class="line">        left = <span class="number">0b11110000</span></span><br><span class="line">        mid = <span class="number">0b00111100</span></span><br><span class="line">        right = <span class="number">0b00001111</span></span><br><span class="line">        <span class="keyword">for</span> v <span class="keyword">in</span> d.values():</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> (v &amp; left) <span class="keyword">or</span> <span class="keyword">not</span> (v&amp;mid) <span class="keyword">or</span> <span class="keyword">not</span> (v&amp;right):</span><br><span class="line">                ans = ans + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algo </category>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 位运算 </tag>
            
            <tag> 求补集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang常用库函数归纳</title>
      <link href="/2022/11/13/go-%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E5%BD%92%E7%BA%B3/"/>
      <url>/2022/11/13/go-%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E5%BD%92%E7%BA%B3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2><span id="sortsearch-二分">sort.Search (二分)</span></h2><p>sort.Search 需要自己实现接口 也比较简单<br>当然有很多实现方式 以下所展示的方式 是sort.SearchInts() 等中的实现方式</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;sort&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := []<span class="type">int</span>&#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>&#125;</span><br><span class="line"><span class="comment">// 第一个参数为数组长度 第二个实现函数</span></span><br><span class="line">id := sort.Search(<span class="built_in">len</span>(a), <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line"><span class="keyword">return</span> a[i] &gt;= <span class="number">1</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">fmt.Println(id)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然也可以更简单一些直接调用sort.SearchInts()&#x2F; sort.SearchStrings()<br>如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;sort&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := []<span class="type">int</span>&#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>&#125;</span><br><span class="line"><span class="comment">// go 的searchInts 返回右端点 应该是 &gt;= 的二分</span></span><br><span class="line"><span class="comment">// 例如</span></span><br><span class="line">id := sort.SearchInts(a, <span class="number">1</span>)</span><br><span class="line">fmt.Println(id) <span class="comment">// 输出 0</span></span><br><span class="line"></span><br><span class="line">id = sort.SearchInts(a, <span class="number">2</span>)</span><br><span class="line">fmt.Println(id) <span class="comment">// 输出 2</span></span><br><span class="line"></span><br><span class="line">id = sort.SearchInts(a, <span class="number">3</span>)</span><br><span class="line">fmt.Println(id) <span class="comment">// 输出1</span></span><br><span class="line"></span><br><span class="line">id = sort.SearchInts(a, <span class="number">7</span>)</span><br><span class="line">fmt.Println(id) <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">即如果存在这个数 那么就会输出这个数在数组中的位置</span></span><br><span class="line"><span class="comment">如果该数不存在 则返回大于他的一个数的位置</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2><span id="map的相关使用">map的相关使用</span></h2><p>go 的map为内置结构 不需要额外引入但使用起来与其他语言略有差别</p><h3><span id="map的基础使用">map的基础使用</span></h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// map 的定义 这样最简洁</span></span><br><span class="line">m := <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>&#123;&#125;</span><br><span class="line"><span class="comment">// 也可以这样</span></span><br><span class="line">m1 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 赋值</span></span><br><span class="line">m[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断值是否存在</span></span><br><span class="line"><span class="comment">// golang里面目前只能这种方法</span></span><br><span class="line"><span class="comment">// 存在则ok 为true 否则为false</span></span><br><span class="line"><span class="keyword">if</span> v,ok := m[<span class="number">0</span>];ok&#123;</span><br><span class="line">fmt.Println(v)</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;不存在&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历map中的键</span></span><br><span class="line"><span class="keyword">for</span> k := <span class="keyword">range</span> m&#123;</span><br><span class="line">fmt.Println(k)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历map中的键值对</span></span><br><span class="line"><span class="comment">// 目前不存在可以直接遍历值的操作</span></span><br><span class="line"><span class="keyword">for</span> k,v := <span class="keyword">range</span> m&#123;</span><br><span class="line">fmt.Println(k,v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="map-当set使用">map 当set使用</span></h3><p>go基本库函数里面没有set 要外部引入 但可以用map当作set<br>通常是将不同的键均指向一个相同的值即可</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>&#123;&#125;</span><br><span class="line"><span class="comment">// 我个人通常喜欢指向-1</span></span><br><span class="line">s[<span class="number">0</span>] = <span class="number">-1</span></span><br><span class="line">s[<span class="number">1</span>] = <span class="number">-1</span></span><br><span class="line">s[<span class="number">241</span>] = <span class="number">-1</span></span><br><span class="line"><span class="keyword">for</span> v := <span class="keyword">range</span> s&#123;</span><br><span class="line">fmt.Println(v)</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h2><span id="排序sort">排序sort</span></h2><p>go的排序使用sort库函数 和c++有些类似<br>可以使用 <code>sort.Ints() sort.Slice()</code> 等<br>但建议统一使用sort.Slice() 不容易出错  sort.Ints()显然只能匹配int型且只能正序 同理float型也是一个道理只能和相应类型的匹配</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;sort&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">nums := []<span class="type">int</span>&#123;<span class="number">2</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>&#125;</span><br><span class="line"><span class="comment">// 正序</span></span><br><span class="line">sort.Slice(nums, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line"><span class="keyword">return</span> nums[i] &lt; nums[j]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 等价于  </span></span><br><span class="line">sort.Ints(nums)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">排序结果:</span></span><br><span class="line"><span class="comment">[1 2 3 4 5 6]</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 多维数组 自定义排序规则</span></span><br><span class="line">maritx := [][]<span class="type">int</span>&#123;</span><br><span class="line">&#123;<span class="number">3</span>, <span class="number">2</span>&#125;, &#123;<span class="number">4</span>, <span class="number">1</span>&#125;, &#123;<span class="number">9</span>, <span class="number">3</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line">sort.Slice(maritx, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line"><span class="keyword">return</span> maritx[i][<span class="number">1</span>] &lt; maritx[j][<span class="number">1</span>]</span><br><span class="line">&#125;)</span><br><span class="line">fmt.Println(maritx)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">排序结果: [[4 1] [3 2] [9 3]]</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2><span id="数字与字符串之间的相互转换">数字与字符串之间的相互转换</span></h2><p>go 语言不能直接用string 去转 不然会得到一个空值 这个还是蛮坑的 正确的要使用strconv库中的Itoa方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := <span class="number">131</span></span><br><span class="line">s := strconv.Itoa(a)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%s %T \n&quot;</span>, s, s)</span><br><span class="line"></span><br><span class="line">ss := <span class="string">&quot;123&quot;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这里也是一个坑点</span></span><br><span class="line"><span class="comment">Atoi返回的转换完后的b 以及err</span></span><br><span class="line"><span class="comment">由于这里err 并不会再使用所以使用_</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">b, _ := strconv.Atoi(ss)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%v %T \n&quot;</span>, b, b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> dev </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
            <tag> 算法笔记 </tag>
            
            <tag> golang常用库函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode2400恰好移动k步到达某一位置的方法数目</title>
      <link href="/2022/11/13/leetcode/leetcode2400%E6%81%B0%E5%A5%BD%E7%A7%BB%E5%8A%A8k%E6%AD%A5%E5%88%B0%E8%BE%BE%E6%9F%90%E4%B8%80%E4%BD%8D%E7%BD%AE%E7%9A%84%E6%96%B9%E6%B3%95%E6%95%B0%E7%9B%AE/"/>
      <url>/2022/11/13/leetcode/leetcode2400%E6%81%B0%E5%A5%BD%E7%A7%BB%E5%8A%A8k%E6%AD%A5%E5%88%B0%E8%BE%BE%E6%9F%90%E4%B8%80%E4%BD%8D%E7%BD%AE%E7%9A%84%E6%96%B9%E6%B3%95%E6%95%B0%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><font color="red">法1: 记忆化搜索</font><br>简而言之 就是把已经搜索的值记录到一个hash表 如果已经搜索过 那么就不用继续往下搜索了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">MOD = <span class="number">10</span> ** <span class="number">9</span> + <span class="number">7</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">numberOfWays</span>(<span class="params">self, startPos: <span class="built_in">int</span>, endPos: <span class="built_in">int</span>, k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># hash 存储记忆化的中间结果</span></span><br><span class="line">        memo = defaultdict(<span class="built_in">int</span>)</span><br><span class="line">        <span class="comment"># 记忆化搜索</span></span><br><span class="line">        <span class="comment"># 当前距离为cur 已经走了d步 的方案数</span></span><br><span class="line">        <span class="comment"># 写python 记忆化搜索一定要加个@cache 不然就会超时</span></span><br><span class="line"><span class="meta">        @cache</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">cur: <span class="built_in">int</span>, d: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line"><span class="comment"># 剪枝 剩余步数小于 终点起点之间的距离则方案肯定不行</span></span><br><span class="line">            <span class="keyword">if</span> k - d  &lt; <span class="built_in">abs</span>(endPos - cur):</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> d == k:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            <span class="comment"># 这个key的赋值 是整个记忆化里最关键的一步</span></span><br><span class="line">            <span class="comment"># key包含cur 以及 d 两个信息</span></span><br><span class="line">            <span class="comment"># 如果只是从0开始 这两个信息可能会其冲突 比如 你cur = 3 可能只是向右了3步 但也可能是向右6步后折返了3步 即会产生哈希冲突</span></span><br><span class="line">            <span class="comment"># 由于题目条件是最多走1000步 所以只要cur* 比1000大的数 不同的key之间就不会存在冲突了 </span></span><br><span class="line">            key = cur * <span class="number">1005</span> + d</span><br><span class="line">            <span class="comment"># 已经搜索过直接返回</span></span><br><span class="line">            <span class="keyword">if</span> memo.get(key):</span><br><span class="line">                <span class="keyword">return</span> memo[key]</span><br><span class="line">            v = (dfs(cur + <span class="number">1</span>, d + <span class="number">1</span>) + dfs(cur - <span class="number">1</span>, d + <span class="number">1</span>)) % MOD</span><br><span class="line">            memo[key] = v</span><br><span class="line">            <span class="keyword">return</span> v</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dfs(startPos, <span class="number">0</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>个人觉得记忆化写起来并没有dp方便 简洁性和正确性上来看 主要是记忆化需要判断较多的边界条件 能用dp的 还是尽量先考虑dp</p><p><font color="red">法2:动态规划</font></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">MOD = <span class="number">10</span> ** <span class="number">9</span> + <span class="number">7</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">numberOfWays</span>(<span class="params">self, startPos: <span class="built_in">int</span>, endPos: <span class="built_in">int</span>, k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">abs</span>(endPos - startPos) &gt; k:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># dp[i][j] 表示当前在坐标轴位置为i 已经了k步的方案数</span></span><br><span class="line">        <span class="comment"># 状态转移: 走了k步的状态 只能从走了k-1步的状态转移而来 而在数轴上又只可以左右移动</span></span><br><span class="line">        <span class="comment"># 即 dp[i][k] = dp[i-1][k-1] + dp[i+1][k-1]</span></span><br><span class="line">        dp = [[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1010</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3010</span>)]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 题目允许存在负数 所以+1000 避免负数的情况</span></span><br><span class="line">        startPos = startPos + <span class="number">1000</span></span><br><span class="line">        endPos = endPos + <span class="number">1000</span></span><br><span class="line">        dp[startPos][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,k+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(startPos - k,endPos + k+<span class="number">1</span>):</span><br><span class="line">                dp[i][j] = (dp[i-<span class="number">1</span>][j-<span class="number">1</span>] + dp[i+<span class="number">1</span>][j-<span class="number">1</span>]) % MOD</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[endPos][k]</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algo </category>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 记忆化搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode1373二叉树搜索树的最大键值和-dfs判断bst的同时更新答案</title>
      <link href="/2022/11/12/leetcode/leetcode1373%E4%BA%8C%E5%8F%89%E6%A0%91%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E9%94%AE%E5%80%BC%E5%92%8C-dfs%E5%88%A4%E6%96%ADbst%E7%9A%84%E5%90%8C%E6%97%B6%E6%9B%B4%E6%96%B0%E7%AD%94%E6%A1%88/"/>
      <url>/2022/11/12/leetcode/leetcode1373%E4%BA%8C%E5%8F%89%E6%A0%91%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E9%94%AE%E5%80%BC%E5%92%8C-dfs%E5%88%A4%E6%96%ADbst%E7%9A%84%E5%90%8C%E6%97%B6%E6%9B%B4%E6%96%B0%E7%AD%94%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>原题链接:<br><a href="https://leetcode.cn/problems/maximum-sum-bst-in-binary-tree/">https://leetcode.cn/problems/maximum-sum-bst-in-binary-tree/</a><br>蛮综合的一道题<br>尤其是边界情况的条件处理比较巧妙<br>当前bst判断不成立时 <font color="red">将当前子树的最小值设置为inf 最大值设置-inf返回</font><br>则接下来任意 包含该子树的判断 均不会满足 <strong>左子树最大值&lt;node.val&lt;右子树最小值</strong> 这一条件 即不会更新ans</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    先判断 左子树 右子树 是否为 bst</span></span><br><span class="line"><span class="string">    如果左右子树均为bst</span></span><br><span class="line"><span class="string">        看左子树的最大值是否小于 root.val</span></span><br><span class="line"><span class="string">        看右子树的最小值是否大于 root.val</span></span><br><span class="line"><span class="string">    如果成立 则证明当前整棵树 也是一棵bst 更新答案 ans = max(ans,root.val + 左子树的总和 + 右子树总和)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxSumBST</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        inf = <span class="number">10</span> ** <span class="number">8</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">node: TreeNode</span>) -&gt; []:</span><br><span class="line">            <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            返回三个数</span></span><br><span class="line"><span class="string">            当前子树总和 最小值 最大值</span></span><br><span class="line"><span class="string">            &quot;&quot;&quot;</span></span><br><span class="line">            <span class="comment"># 左子树</span></span><br><span class="line">            <span class="comment"># sum: 初始时左子树和为0</span></span><br><span class="line">            <span class="comment"># 最小值: 当子树不存在时 默认返回根节点的值</span></span><br><span class="line">            <span class="comment"># 最大值: 最大值初始化为负无穷</span></span><br><span class="line">            left = [<span class="number">0</span>, node.val, -inf]</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 右子树 同理</span></span><br><span class="line">            right = [<span class="number">0</span>, inf, node.val]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                left = dfs(node.left)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                right = dfs(node.right)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">nonlocal</span> ans</span><br><span class="line">            <span class="comment"># 如果左子树的最大值小于 &lt; 根节点 &lt; 右子树最小值</span></span><br><span class="line">            <span class="comment"># 当前的树为bst 更新结果</span></span><br><span class="line">            <span class="keyword">if</span> left[<span class="number">2</span>] &lt; node.val &lt; right[<span class="number">1</span>]:</span><br><span class="line">                s = node.val + left[<span class="number">0</span>] + right[<span class="number">0</span>]</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, s)</span><br><span class="line">                <span class="comment"># 当前子树的总和 左子树的最小值(即整棵树的最小值)  右子树的最大值(即整棵树的最大值)</span></span><br><span class="line">                <span class="keyword">return</span> [s,left[<span class="number">1</span>],right[<span class="number">2</span>]]</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 当前子树非bst</span></span><br><span class="line">            <span class="comment"># 则将当前和置为-inf 最小值inf 最大值置为-inf</span></span><br><span class="line">            <span class="comment"># 这样的话 在接下来的任何判断中凡是包含该子树的树 都不会成立 即不会对ans进行更新</span></span><br><span class="line">            <span class="keyword">return</span> [-inf,inf,-inf]</span><br><span class="line"></span><br><span class="line">        dfs(root)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algo </category>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉搜索树bst </tag>
            
            <tag> dfs </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode6161从字符串中移除星号-栈</title>
      <link href="/2022/11/12/leetcode/leetcode6161%E4%BB%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%A7%BB%E9%99%A4%E6%98%9F%E5%8F%B7-%E6%A0%88/"/>
      <url>/2022/11/12/leetcode/leetcode6161%E4%BB%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%A7%BB%E9%99%A4%E6%98%9F%E5%8F%B7-%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>原题链接:<br><a href="https://leetcode.cn/problems/removing-stars-from-a-string/">https://leetcode.cn/problems/removing-stars-from-a-string/</a><br>这题虽然披着字符串的外衣 但其实是栈的应用<br>关键在于相邻两个字 然后是消除 如果没有提取好特征直接用遍历去写那这题就十分麻烦了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeStars</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        stk = []</span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="comment"># 题目保证一定给有解所以无需判空</span></span><br><span class="line">            <span class="keyword">if</span> s[i] == <span class="string">&quot;*&quot;</span>:</span><br><span class="line">                stk.pop()</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                stk.append(s[i])</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(stk)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>leetcode 包括很多算法题都是在原题基础上 或者一些经典算法的基础上改编而来 周赛的时候就是没反应过来在那里直接做 花了很多时间…<br>leetcode20 非常靠前的一道题了 应该算是这道题的原题了<br><a href="https://leetcode.cn/problems/valid-parentheses/">https://leetcode.cn/problems/valid-parentheses/</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isValid</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span> :</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        stk = []</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> s[i] == <span class="string">&quot;(&quot;</span> <span class="keyword">or</span> s[i] == <span class="string">&quot;[&quot;</span> <span class="keyword">or</span> s[i] == <span class="string">&quot;&#123;&quot;</span>:</span><br><span class="line">                stk.append(s[i])</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(stk) == <span class="number">0</span> :</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> s[i] == <span class="string">&quot;)&quot;</span> <span class="keyword">and</span> stk[-<span class="number">1</span>] == <span class="string">&quot;(&quot;</span>:</span><br><span class="line">                stk.pop()</span><br><span class="line">            <span class="keyword">elif</span> s[i] == <span class="string">&quot;&#125;&quot;</span> <span class="keyword">and</span> stk[-<span class="number">1</span>] == <span class="string">&quot;&#123;&quot;</span>:</span><br><span class="line">                stk.pop()</span><br><span class="line">            <span class="keyword">elif</span> s[i] == <span class="string">&quot;]&quot;</span> <span class="keyword">and</span> stk[-<span class="number">1</span>] == <span class="string">&quot;[&quot;</span>:</span><br><span class="line">                stk.pop()</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(stk) ==  <span class="number">0</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algo </category>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法模板-区间问题</title>
      <link href="/2022/11/12/algoSummary/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF-%E5%8C%BA%E9%97%B4%E9%97%AE%E9%A2%98/"/>
      <url>/2022/11/12/algoSummary/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF-%E5%8C%BA%E9%97%B4%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1><span id="区间问题">区间问题</span></h1><p>统计一个区间内的数据 如区间 (l,r) 内 的点个数</p><h2><span id="前缀和">前缀和</span></h2><p>当数组不发生改变时 即区间内的点数 不发生变动 只不过查询的时候是换了区间查询 那么简单的方法使用前缀和 不仅代码简单 而且可以使得每次查询都做到O(1) 使用树状数组 和 线段树 也可以但复杂度太高了 尤其是线段树 不到万不得已 不要使用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一维度非常简单 关键是要想到</span></span><br><span class="line">s[i] = a[<span class="number">1</span>] + a[<span class="number">2</span>] + .... a[i]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查询区间 (l,r) 内点的数量 即</span></span><br><span class="line">a[l] + a[l+<span class="number">1</span>] + ... + a[r] = s[r] - s[l-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 二维</span></span><br><span class="line">s[i,j] = 第i行 第j列 左上角所有元素的和</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：</span></span><br><span class="line"><span class="string">S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 记数组元素为c 二维前缀和 的初始化为</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">s[i][j] = s[i-<span class="number">1</span>][j] + s[i][j-<span class="number">1</span>] + c - s[i-<span class="number">1</span>][j-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对于范围 (x1,y1) (x2,y2) 区间内元素的查询操作的值为</span></span><br><span class="line">s[x2][y2] - s[x1-<span class="number">1</span>][y2] - s[x2][y1-<span class="number">1</span>] + s[x1][y1]</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2><span id="差分">差分</span></h2><p>区间改变 进行区间查询<br><font color="purple">这里的区间改变 对应到题目中 大多数 修改一个点后 对于之后一段区间内的结果都会产生影响<br>比如leectcode 1045 <a href="https://leetcode.cn/problems/number-of-students-doing-homework-at-a-given-time/">https://leetcode.cn/problems/number-of-students-doing-homework-at-a-given-time/</a> 题目要求的是一个区间的时间内正在做作业的学生人数 每个学生 在对应a点开始 做作业 b点 完成作业 如果[a,b] 到这个区间内当前做作业的人数有 10个人 但是在b+1 这个点 有一个人完成作业 但是在 c这个点之前都没有任何人完成作业 那么对于整个区间[b+1,c] 来说其中正在做作业的人数都是9个人 即一点修改 影响了整个区间 </font></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一维差分</span></span><br><span class="line"><span class="comment"># 给区间[l, r]中的每个数加上c</span></span><br><span class="line">s[l]+=c</span><br><span class="line">s[r+<span class="number">1</span>]-=c</span><br><span class="line"></span><br><span class="line"><span class="comment"># 一维差分的初始化</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">s[i] = s[i] + c</span><br><span class="line">s[i] = s[i+<span class="number">1</span>] - c</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">差分的查询操作</span></span><br><span class="line"><span class="string">差分问题的查询 需要在完成一系列修改操作后 将差分数组还原为原数组</span></span><br><span class="line"><span class="string">所以其实差分真正优化的是 对于数组的修改实现了O(1)</span></span><br><span class="line"><span class="string">对于最后返回的值则要根据题目的定义 返回</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>)</span><br><span class="line">s[i]+= s[i-<span class="number">1</span>] </span><br></pre></td></tr></table></figure><p>简单应用：<br>leetcode1450 原题链接:<br><a href="https://leetcode.cn/problems/number-of-students-doing-homework-at-a-given-time/">https://leetcode.cn/problems/number-of-students-doing-homework-at-a-given-time/</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">busyStudent</span>(<span class="params">self, startTime: <span class="type">List</span>[<span class="built_in">int</span>], endTime: <span class="type">List</span>[<span class="built_in">int</span>], queryTime: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        s = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">1001</span> + <span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> t1,t2 <span class="keyword">in</span> <span class="built_in">zip</span>(startTime,endTime):</span><br><span class="line">            s[t1]+=<span class="number">1</span></span><br><span class="line">            s[t2+<span class="number">1</span>]-=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">1000</span> + <span class="number">1</span>):</span><br><span class="line">            s[i] += s[i - <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> s[queryTime]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algo </category>
          
          <category> 算法总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区间问题 </tag>
            
            <tag> 前缀和 </tag>
            
            <tag> 拆分 </tag>
            
            <tag> 线段树 </tag>
            
            <tag> 树状数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法模板-最大公约数gcd</title>
      <link href="/2022/11/12/algoSummary/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF-%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0gcd/"/>
      <url>/2022/11/12/algoSummary/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF-%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0gcd/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>主要思路是辗转相除法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b != <span class="number">0</span> ? <span class="built_in">gcd</span>(b, a % b) : a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><font color="purple">一个常考性质 </font></strong><br>一个数可以整除所有数  y1 y2 ..% x<br>等价这个数 可以整除所有数的最大公约数 y1 y2 …(的公约数) % x</p>]]></content>
      
      
      <categories>
          
          <category> algo </category>
          
          <category> 算法总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 最大公约数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法题型归纳-双指针</title>
      <link href="/2022/10/17/algoSummary/%E7%AE%97%E6%B3%95%E9%A2%98%E5%9E%8B%E5%BD%92%E7%BA%B3-%E5%8F%8C%E6%8C%87%E9%92%88/"/>
      <url>/2022/10/17/algoSummary/%E7%AE%97%E6%B3%95%E9%A2%98%E5%9E%8B%E5%BD%92%E7%BA%B3-%E5%8F%8C%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><font color="purple"><strong>难度值:4</strong></font><br><a href="#ex3">统计定界子数组的数目</a></p><h3><span id="滑动窗口">滑动窗口</span></h3><p>其实是属于双指针的一种 但这种题目特征更强<br><font color="purple"><strong>难度值:3</strong></font><br><a href="#ex1">美观的花束</a><br><a href="#ex2">水果成篮</a></p><h2><span id="例1">例1</span></h2><p><a id="ex1"><strong>美观的花束</strong> </a><br>原题链接:<br><a href="https://leetcode.cn/problems/1GxJYY/">https://leetcode.cn/problems/1GxJYY/</a></p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MOD = <span class="number">1e9</span> + <span class="number">7</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">beautifulBouquet</span><span class="params">(flowers []<span class="type">int</span>, cnt <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    h := <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>&#123;&#125;</span><br><span class="line">    left := <span class="number">0</span></span><br><span class="line">    ans := <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> right,x := <span class="keyword">range</span> flowers&#123;</span><br><span class="line">        h[x]++</span><br><span class="line">        <span class="keyword">for</span> h[x] &gt; cnt&#123;</span><br><span class="line">            y := flowers[left]</span><br><span class="line">            h[y]--</span><br><span class="line">            <span class="keyword">if</span> h[y] == <span class="number">0</span>&#123;</span><br><span class="line">                <span class="built_in">delete</span>(h,y)</span><br><span class="line">            &#125;</span><br><span class="line">            left++</span><br><span class="line">        &#125;</span><br><span class="line">        ans = (ans + (right - left + <span class="number">1</span>) ) % MOD</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="例2">例2</span></h2><p><a id="ex2"><strong>水果篮子</strong></a><br>原题链接:<br><a href="https://leetcode.cn/problems/fruit-into-baskets/">https://leetcode.cn/problems/fruit-into-baskets/</a></p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a,b <span class="type">int</span>)</span></span><span class="type">int</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> a &gt; b&#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">totalFruit</span><span class="params">(fruits []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    h := <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>&#123;&#125;</span><br><span class="line">    left := <span class="number">0</span></span><br><span class="line">    ans := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> right,x := <span class="keyword">range</span> fruits&#123;</span><br><span class="line">        h[x]++</span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">len</span>(h) &gt; <span class="number">2</span>&#123;</span><br><span class="line">            y := fruits[left]</span><br><span class="line">            h[y]--</span><br><span class="line">            <span class="keyword">if</span> h[y] == <span class="number">0</span>&#123;</span><br><span class="line">                <span class="built_in">delete</span>(h,y)</span><br><span class="line">            &#125;</span><br><span class="line">            left++</span><br><span class="line">        &#125;</span><br><span class="line">        ans = max(ans,right - left + <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="例3">例3</span></h2><p><a id="ex3"><strong>统计定界子数组的数量</strong></a><br>原题链接:<br><a href="https://leetcode.cn/problems/count-subarrays-with-fixed-bounds/">https://leetcode.cn/problems/count-subarrays-with-fixed-bounds/</a></p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a,b <span class="type">int</span>)</span></span> <span class="type">int</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> a  &gt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(a,b <span class="type">int</span>)</span></span><span class="type">int</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> a &lt; b&#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">countSubarrays</span><span class="params">(nums []<span class="type">int</span>, minK <span class="type">int</span>, maxK <span class="type">int</span>)</span></span> <span class="type">int64</span> &#123;</span><br><span class="line">    i0,left,right := <span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span></span><br><span class="line">    <span class="keyword">var</span> ans <span class="type">int64</span></span><br><span class="line">    <span class="keyword">for</span> i,v := <span class="keyword">range</span> nums&#123;</span><br><span class="line">        <span class="keyword">if</span> v == minK&#123;</span><br><span class="line">            left = i </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> v == maxK&#123;</span><br><span class="line">            right = i</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> v &lt; minK || v &gt; maxK&#123;</span><br><span class="line">            i0 = i</span><br><span class="line">        &#125;</span><br><span class="line">        ans += <span class="type">int64</span>( max(min(left,right) - i0,<span class="number">0</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algo </category>
          
          <category> 算法总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法题型归纳-栈</title>
      <link href="/2022/10/09/algoSummary/%E7%AE%97%E6%B3%95%E9%A2%98%E5%9E%8B%E5%BD%92%E7%BA%B3-%E6%A0%88/"/>
      <url>/2022/10/09/algoSummary/%E7%AE%97%E6%B3%95%E9%A2%98%E5%9E%8B%E5%BD%92%E7%BA%B3-%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2><span id="括号类">括号类</span></h2><p>各种括号题 基本上算是栈的经典应用了</p><p><font color="purple"><strong>难度值1:</strong></font><br><a href="#ex2">删除最外层的括号</a><br><font color="purple"><strong>难度值3:</strong> </font><br><a href="#ex1">括号的分数</a><br><a href="#ex3">移除无效的括号</a></p><h2><span id="例1">例1</span></h2><p><a id="ex1"><strong>括号的分数</strong></a><br>原题链接<br><a href="https://leetcode.cn/problems/score-of-parentheses/">https://leetcode.cn/problems/score-of-parentheses/</a></p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line"><span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">scoreOfParentheses</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">stk := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> _, ch := <span class="keyword">range</span> s &#123;</span><br><span class="line"><span class="keyword">if</span> ch == <span class="string">&#x27;(&#x27;</span> &#123;</span><br><span class="line">stk = <span class="built_in">append</span>(stk, <span class="number">0</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">v := max(<span class="number">1</span>, stk[<span class="built_in">len</span>(stk)<span class="number">-1</span>]*<span class="number">2</span>)</span><br><span class="line">stk = stk[:<span class="built_in">len</span>(stk)<span class="number">-1</span>]</span><br><span class="line">stk[<span class="built_in">len</span>(stk)<span class="number">-1</span>] += v</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> stk[<span class="built_in">len</span>(stk)<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2><span id="例2">例2</span></h2><p><a id="ex2"><strong>删除最外层的括号</strong> </a><br>原题链接:<br><a href="https://leetcode.cn/problems/remove-outermost-parentheses/">https://leetcode.cn/problems/remove-outermost-parentheses/</a></p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;strings&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">其实就是找到所有刚好配对的括号</span></span><br><span class="line"><span class="comment">然后 再将这些刚好匹配的括号的最外层去掉</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeOuterParentheses</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">stk := <span class="number">0</span></span><br><span class="line">ans := <span class="built_in">make</span>([]<span class="type">string</span>, <span class="number">0</span>)</span><br><span class="line">tmp := []<span class="type">rune</span>(<span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> _, ch := <span class="keyword">range</span> s &#123;</span><br><span class="line"><span class="keyword">if</span> ch == <span class="string">&#x27;(&#x27;</span> &#123;</span><br><span class="line">tmp = <span class="built_in">append</span>(tmp, ch)</span><br><span class="line">stk++</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">stk = stk - <span class="number">1</span></span><br><span class="line">tmp = <span class="built_in">append</span>(tmp, ch)</span><br><span class="line"><span class="keyword">if</span> stk == <span class="number">0</span> &#123;</span><br><span class="line">tmp = tmp[<span class="number">1</span> : <span class="built_in">len</span>(tmp)<span class="number">-1</span>]</span><br><span class="line">ans = <span class="built_in">append</span>(ans, <span class="type">string</span>(tmp))</span><br><span class="line">                tmp = tmp[<span class="number">0</span>:<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> strings.Join(ans,<span class="string">&quot;&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2><span id="例3">例3</span></h2><p><a id="ex3"><strong>移除无效括号</strong></a></p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">先遍历一遍 贪心原则维持左右括号相同</span></span><br><span class="line"><span class="comment">最后如果还是左括号太多 则删除多余的左括号即可</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minRemoveToMakeValid</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">tmp := []<span class="type">rune</span>(<span class="string">&quot;&quot;</span>)</span><br><span class="line">stk := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> _, ch := <span class="keyword">range</span> s &#123;</span><br><span class="line"><span class="keyword">if</span> ch == <span class="string">&#x27;(&#x27;</span> &#123;</span><br><span class="line">stk = stk + <span class="number">1</span></span><br><span class="line">tmp = <span class="built_in">append</span>(tmp, ch)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> ch == <span class="string">&#x27;)&#x27;</span> &#123;</span><br><span class="line"><span class="keyword">if</span> stk &lt;= <span class="number">0</span> &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">            tmp = <span class="built_in">append</span>(tmp,ch)</span><br><span class="line">            stk = stk - <span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">tmp = <span class="built_in">append</span>(tmp, ch)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> stk &gt; <span class="number">0</span> &#123;</span><br><span class="line">ans := []<span class="type">rune</span>(<span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="built_in">len</span>(tmp) - <span class="number">1</span>; i &gt;= <span class="number">0</span> ; i--&#123;</span><br><span class="line">            <span class="keyword">if</span> stk &gt; <span class="number">0</span> &amp;&amp; tmp[i] == <span class="string">&#x27;(&#x27;</span>&#123;</span><br><span class="line">               stk = stk - <span class="number">1</span></span><br><span class="line">               <span class="keyword">continue</span> </span><br><span class="line">            &#125;</span><br><span class="line">            ans = <span class="built_in">append</span>(ans,tmp[i])</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i,j := <span class="number">0</span>,<span class="built_in">len</span>(ans) - <span class="number">1</span> ; i &lt; j ; i,j = i + <span class="number">1</span>,j - <span class="number">1</span>&#123;</span><br><span class="line">            ans[i],ans[j] = ans[j],ans[i]</span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">return</span> <span class="type">string</span>(ans)</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="type">string</span>(tmp)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algo </category>
          
          <category> 算法总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>acwing算法笔试面试辅导课刷题记录</title>
      <link href="/2022/10/08/acwing%E7%AE%97%E6%B3%95%E7%AC%94%E8%AF%95%E9%9D%A2%E8%AF%95%E8%BE%85%E5%AF%BC%E8%AF%BE%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
      <url>/2022/10/08/acwing%E7%AE%97%E6%B3%95%E7%AC%94%E8%AF%95%E9%9D%A2%E8%AF%95%E8%BE%85%E5%AF%BC%E8%AF%BE%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>很早之前报名的一个课程 但一直没时间(其实是忘了)去完成<br>现在刚好又开始学了go 也差不多又要到这个阶段 就算是一个flag 这次要把所有题都完成</p><h2><span id="1-蛇形矩阵">1 蛇形矩阵</span></h2><p>原题链接:<br><a href="https://www.acwing.com/problem/content/758/">https://www.acwing.com/problem/content/758/</a><br>模拟 但却是有技巧的模拟<br>主要就是转向条件那里 如果没有做过一次真的在现场很容易被绕进去</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> N, M <span class="type">int</span> = <span class="number">110</span>, <span class="number">110</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    n, m := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    fmt.Scanf(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m)</span><br><span class="line">    <span class="keyword">var</span> g [N][M]<span class="type">int</span></span><br><span class="line">    <span class="comment">// 右 下 左 上</span></span><br><span class="line">    dx := [...]<span class="type">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;</span><br><span class="line">    dy := [...]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;</span><br><span class="line">    d := <span class="number">0</span></span><br><span class="line">    row, col := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> idx := <span class="number">1</span>; idx &lt;= n*m; idx++ &#123;</span><br><span class="line">        g[row][col] = idx</span><br><span class="line">        x := row + dx[d]</span><br><span class="line">        y := col + dy[d]</span><br><span class="line">        <span class="keyword">if</span> x &gt;= <span class="number">0</span> &amp;&amp; x &lt; n &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; m &amp;&amp; g[x][y] == <span class="number">0</span>&#123;</span><br><span class="line">            row = x</span><br><span class="line">            col = y</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            d = (d + <span class="number">1</span>) % <span class="number">4</span></span><br><span class="line">            row = row + dx[d]</span><br><span class="line">            col = col + dy[d]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i :=<span class="number">0</span> ; i &lt; n ; i++&#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span> ; j &lt; m ; j++&#123;</span><br><span class="line">            fmt.Printf(<span class="string">&quot;%d &quot;</span>,g[i][j])</span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Println()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法笔试 </tag>
            
            <tag> acwing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法模板I题型归纳-字符串哈希</title>
      <link href="/2022/10/06/algoSummary/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BFI%E9%A2%98%E5%9E%8B%E5%BD%92%E7%BA%B3-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C/"/>
      <url>/2022/10/06/algoSummary/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BFI%E9%A2%98%E5%9E%8B%E5%BD%92%E7%BA%B3-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>字符串哈希思路非常简单 但具体实现细节比较非常麻烦<br>C++等有unsigned long long 类型的语言实现起来是最容易的 因为不用取模 靠unsigned long long自然溢出 就能得出正确的结果 而其他语言在这个取模上要注意很多<br>当然由于字符串哈希这个算法本身泛用性很好 而且可以简化很多问题 背一背相关细节还是值得的<br>下面就以python为例给出模板 以及正确的模值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这个MOD 值 可以保证最终答案是正确的</span></span><br><span class="line">MOD = <span class="number">10</span>**<span class="number">13</span> + <span class="number">7</span></span><br><span class="line">P = <span class="number">131</span></span><br><span class="line">n = <span class="built_in">len</span>(s)</span><br><span class="line">h = (n + <span class="number">1</span>) * [<span class="number">0</span>]</span><br><span class="line">p = (n + <span class="number">1</span>) * [<span class="number">0</span>]</span><br><span class="line"><span class="comment"># 这里一定要注意 这个初值一定要给 !!!</span></span><br><span class="line">p[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n + <span class="number">1</span>):</span><br><span class="line">    h[i] = (h[i - <span class="number">1</span>] * P % MOD + <span class="built_in">ord</span>(s[i])) % MOD</span><br><span class="line">    p[i] = p[i - <span class="number">1</span>] * P % MOD</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">l,r</span>):</span><br><span class="line">    <span class="keyword">return</span> (h[r] - h[l - <span class="number">1</span>] *  p[r - l + <span class="number">1</span>] % MOD) % MOD</span><br></pre></td></tr></table></figure><p><font color="red"><strong>经典例题总结</strong> </font><br><font color="purple"><strong>难度值4:字符串哈希与其他算法的结合</strong></font><br><a href="#ex1">三等分</a><br><a href="#ex2">对字母串可执行的最大删除数</a></p><h2><span id="例1">例1</span></h2><p><a id="ex1"><strong>三等分</strong></a><br>原题链接:<br><a href="https://leetcode.cn/problems/three-equal-parts/submissions/">https://leetcode.cn/problems/three-equal-parts/submissions/</a></p><p>使用字符串哈希来迅速判断 字符串之间的值是否相等<br>从而将时间复杂度从O(n^3) 降到 O(n^2)<br>但是这样还是不够 题目给出的范围是3x10^4<br>所以在结合 哈希 先将[1,l] 即第一段的范围全部记录在哈希表 然后枚举r 从而将时间复杂度降到O(n)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">threeEqualParts</span>(<span class="params">self, arr: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        c = <span class="built_in">sum</span>(arr)</span><br><span class="line">        <span class="keyword">if</span> c == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> [<span class="number">0</span>,<span class="built_in">len</span>(arr) - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> c % <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> [-<span class="number">1</span>,-<span class="number">1</span>]</span><br><span class="line">        MOD = <span class="number">10</span>**<span class="number">13</span> + <span class="number">7</span></span><br><span class="line">        P = <span class="number">131</span></span><br><span class="line">        n = <span class="built_in">len</span>(arr)</span><br><span class="line">        h = (n+<span class="number">1</span>) * [<span class="number">0</span>]</span><br><span class="line">        p = (n+<span class="number">1</span>) * [<span class="number">0</span>]</span><br><span class="line">        p[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n + <span class="number">1</span>):</span><br><span class="line">            h[i] = (h[i-<span class="number">1</span>] * P % MOD + arr[i - <span class="number">1</span>] ) % MOD</span><br><span class="line">            p[i] = p[i-<span class="number">1</span>] * P % MOD </span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">l,r</span>):</span><br><span class="line">            <span class="comment">#print(l,r)</span></span><br><span class="line">            <span class="keyword">return</span> (h[r] - h[l - <span class="number">1</span>] * p[r - l + <span class="number">1</span>] %MOD) % MOD</span><br><span class="line">        </span><br><span class="line">        d = defaultdict(<span class="built_in">int</span>) </span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 先算O(n) 算出所有 1~l 的值</span></span><br><span class="line">        <span class="comment"># 然后O(n) 枚举 r 比较结果得出答案</span></span><br><span class="line">        <span class="keyword">for</span> l <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">            <span class="comment">#print(&quot;-----&quot;)</span></span><br><span class="line">            d[get(<span class="number">1</span>,l)] = l</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(n,<span class="number">0</span>,-<span class="number">1</span>):</span><br><span class="line">            <span class="comment">#print(&quot;xxxx&quot;)</span></span><br><span class="line">            <span class="keyword">if</span> get(r,n) <span class="keyword">in</span> d:</span><br><span class="line">                l = d[get(r,n)]</span><br><span class="line">                <span class="keyword">if</span> get(l+<span class="number">1</span>,r-<span class="number">1</span>) == get(r,n):</span><br><span class="line">                    <span class="keyword">return</span> [l-<span class="number">1</span>,r-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> [-<span class="number">1</span>,-<span class="number">1</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2><span id="例2">例2</span></h2><p><a id="ex2"><strong>对字母串可执行的最大删除数</strong></a><br>原题链接:<br><a href="https://leetcode.cn/problems/maximum-deletions-on-a-string/">https://leetcode.cn/problems/maximum-deletions-on-a-string/</a><br>通过字符串哈希来判断字符串之间是否相等 将复杂度从O(n^3) 降到O(n^2)<br>然后 动态规划 从后往前 判断当前字符段是否两端相同的情况 然后更新答案<br>另外这题用python写 是过不了的 一个原因是因为python本身性能差 另外这题python定义不了unsigned long long 必须手动取模 也就是使用上面的模板 所以计算量会翻很多 (但也应该是线性的翻… 最后没过就离谱) 所以这里就展示go的代码 看来以后不能老是偷懒写python了</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ULL = <span class="type">uint64</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a <span class="type">int</span>,b <span class="type">int</span>)</span></span><span class="type">int</span>&#123;</span><br><span class="line"><span class="keyword">if</span> a &gt; b&#123;</span><br><span class="line"><span class="keyword">return</span> a </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deleteString</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">n := <span class="built_in">len</span>(s)</span><br><span class="line">p := <span class="built_in">make</span>([]ULL, n+<span class="number">1</span>)</span><br><span class="line">h := <span class="built_in">make</span>([]ULL, n+<span class="number">1</span>)</span><br><span class="line">p[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> P ULL = <span class="number">131</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= n; i++ &#123;</span><br><span class="line">h[i] = h[i<span class="number">-1</span>]*P + ULL(s[i<span class="number">-1</span>])</span><br><span class="line">p[i] = p[i<span class="number">-1</span>] * P</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f := <span class="built_in">make</span>([]<span class="type">int</span>, n+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">get := <span class="function"><span class="keyword">func</span> <span class="params">(l <span class="type">int</span>,r <span class="type">int</span>)</span></span> ULL &#123;</span><br><span class="line"><span class="keyword">return</span> h[r] - h[l<span class="number">-1</span>]*p[r-l+<span class="number">1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := n; i &gt;= <span class="number">1</span>; i-- &#123;</span><br><span class="line">f[i] = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> j := <span class="number">1</span>; j &lt;= (n-i + <span class="number">1</span>)/<span class="number">2</span> ; j++ &#123;</span><br><span class="line"><span class="keyword">if</span> get(i,i+j<span class="number">-1</span>) == get(i+j,i+<span class="number">2</span>*j<span class="number">-1</span>)&#123;</span><br><span class="line">f[i] = max(f[i],f[i+j] + <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> f[<span class="number">1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algo </category>
          
          <category> 算法总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串哈希 </tag>
            
            <tag> 算法题型归纳 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法模板I题型归纳-并查集</title>
      <link href="/2022/10/03/algoSummary/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BFI%E9%A2%98%E5%9E%8B%E5%BD%92%E7%BA%B3-%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
      <url>/2022/10/03/algoSummary/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BFI%E9%A2%98%E5%9E%8B%E5%BD%92%E7%BA%B3-%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1><span id="并查集模板">并查集模板</span></h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 每个点初始化的时候指向自己</span></span><br><span class="line">p = <span class="built_in">list</span>(<span class="built_in">range</span>(n))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">x</span>):</span><br><span class="line"><span class="comment"># 当前值并不指向其根</span></span><br><span class="line"><span class="keyword">if</span> x != p[x]:</span><br><span class="line"><span class="comment"># 不断递归直到找到自己的根</span></span><br><span class="line">p[x] = find(p[x])</span><br><span class="line"><span class="keyword">return</span> p[x]</span><br></pre></td></tr></table></figure><p><font color="red"><strong>经典例题总结</strong></font><br><font color="purple">难度值:1 对于模板的基本应用</font><br><a href="#ex1">合并集合</a><br><a href="#ex2">连通块内点的数量</a><br><a href="#ex8">格子游戏</a> <font color="green">(二维并查集) </font><br><font color="purple">难度值:2 结合一些基本场景</font><br><a href="#ex5">省份数量</a><br><a href="#ex6">冗余链接</a><br><a href="#ex7">连通网络的操作次数</a><br><font color="purple">难度值:3 对实际问题进行解读转换 但还只涉及并查集这一种算法</font><br><a href="#ex9">搭配购买</a> <font color="green">(并查集结合01背包问题)</font><br><a href="#ex3">好的路径数量</a><br><a href="#ex4">删除操作后的最大字段和</a></p><h2><span id="例1">例1</span></h2><p><a id="ex1"><strong>acwing836 合并集合 模板的直接应用</strong></a></p><p>难度值: 1<br>原题链接：<br><a href="https://www.acwing.com/problem/content/description/838/">https://www.acwing.com/problem/content/description/838/</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">n,m = <span class="built_in">map</span>(<span class="built_in">int</span>,<span class="built_in">input</span>().split())</span><br><span class="line">p = <span class="built_in">list</span>(<span class="built_in">range</span>(n + <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">if</span> p[x]!=x:</span><br><span class="line">        p[x] = find(p[x])</span><br><span class="line">    <span class="keyword">return</span> p[x]</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> m:</span><br><span class="line">    m = m - <span class="number">1</span></span><br><span class="line">    arr = <span class="built_in">input</span>().split()</span><br><span class="line">    op,a,b = arr[<span class="number">0</span>],<span class="built_in">int</span>(arr[<span class="number">1</span>]),<span class="built_in">int</span>(arr[<span class="number">2</span>])</span><br><span class="line">    a = find(a)</span><br><span class="line">    b = find(b)</span><br><span class="line">    <span class="keyword">if</span> op == <span class="string">&quot;M&quot;</span>:</span><br><span class="line">        p[a] = b</span><br><span class="line">    <span class="keyword">elif</span> op == <span class="string">&quot;Q&quot;</span>:</span><br><span class="line">        <span class="keyword">if</span> a == b:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Yes&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;No&quot;</span>)</span><br></pre></td></tr></table></figure><h2><span id="例2">例2</span></h2><p><a id="ex2"><strong>连通块内点的数量 acwing837</strong> </a><br>难度值: 1<br>原题链接:<br><a href="https://www.acwing.com/problem/content/839/">https://www.acwing.com/problem/content/839/</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">n,m = <span class="built_in">map</span>(<span class="built_in">int</span>,<span class="built_in">input</span>().split())</span><br><span class="line">p = <span class="built_in">list</span>(<span class="built_in">range</span>(n + <span class="number">1</span>))</span><br><span class="line">cnt = (n + <span class="number">1</span>) * [<span class="number">1</span>]</span><br><span class="line">cnt[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">if</span> x != p[x]:</span><br><span class="line">        p[x] = find(p[x])</span><br><span class="line">    <span class="keyword">return</span> p[x]</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> m:</span><br><span class="line">    m = m - <span class="number">1</span></span><br><span class="line">    arr = <span class="built_in">input</span>().split()</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(arr) ==  <span class="number">3</span>:</span><br><span class="line">        op,a,b = arr[<span class="number">0</span>],<span class="built_in">int</span>(arr[<span class="number">1</span>]),<span class="built_in">int</span>(arr[<span class="number">2</span>])</span><br><span class="line">        a,b = find(a),find(b)</span><br><span class="line">        <span class="keyword">if</span> op == <span class="string">&quot;C&quot;</span>:</span><br><span class="line">            <span class="comment"># 这里要注意下 </span></span><br><span class="line">            <span class="comment"># 算的是点的数量 所以如果合并就不能再次合并了</span></span><br><span class="line">            <span class="comment"># 否则cnt重复计算结果就会出错</span></span><br><span class="line">            <span class="keyword">if</span> a == b:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            p[a] = b</span><br><span class="line">            cnt[b] = cnt[b] + cnt[a]</span><br><span class="line">        <span class="keyword">elif</span> op == <span class="string">&quot;Q1&quot;</span>:</span><br><span class="line">            <span class="keyword">if</span> a == b:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;Yes&quot;</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;No&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        _,a = arr[<span class="number">0</span>],<span class="built_in">int</span>(arr[<span class="number">1</span>])</span><br><span class="line">        a = find(a)</span><br><span class="line">        <span class="built_in">print</span>(cnt[a])</span><br></pre></td></tr></table></figure><h2><span id="例3">例3</span></h2><p><a id="ex3"><strong>好路径的数目</strong> </a><br>难度值: 3<br>原题链接：<br><a href="https://leetcode.cn/problems/number-of-good-paths/">https://leetcode.cn/problems/number-of-good-paths/</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">numberOfGoodPaths</span>(<span class="params">self, vals: <span class="type">List</span>[<span class="built_in">int</span>], edges: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(vals)</span><br><span class="line">        g = [ [] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 建图</span></span><br><span class="line">        <span class="keyword">for</span> x,y <span class="keyword">in</span> edges:</span><br><span class="line">            <span class="comment"># 无向图 </span></span><br><span class="line">            g[x].append(y)</span><br><span class="line">            g[y].append(x)</span><br><span class="line">        p = <span class="built_in">list</span>(<span class="built_in">range</span>(n))</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">x</span>):</span><br><span class="line">            <span class="keyword">if</span> p[x]!=x:</span><br><span class="line">                p[x] = find(p[x])</span><br><span class="line">            <span class="keyword">return</span> p[x]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 记录每个符合条件的路径中点的个数</span></span><br><span class="line">        cnt = [<span class="number">1</span>] * n </span><br><span class="line">        <span class="comment"># 单个点也算一条路径 故ans 初始值为n</span></span><br><span class="line">        ans = n</span><br><span class="line">        <span class="comment"># 排序以后从小到大 遍历 </span></span><br><span class="line">        <span class="comment"># 从而保证当前val_x 就是连通路径中最大的值</span></span><br><span class="line">        <span class="comment"># 故只要节点x 的邻接点 小于val_x 即可进行合并操作</span></span><br><span class="line">        <span class="keyword">for</span> val_x,x <span class="keyword">in</span> <span class="built_in">sorted</span>(<span class="built_in">zip</span>(vals,<span class="built_in">range</span>(n))):</span><br><span class="line">            fx = find(x)</span><br><span class="line">            <span class="keyword">for</span> y <span class="keyword">in</span> g[x]:</span><br><span class="line">                fy = find(y)</span><br><span class="line">                val_y = vals[fy]</span><br><span class="line">                <span class="comment"># 如果已经处于同一集合 则无需合并</span></span><br><span class="line">                <span class="comment"># 或者其邻接点的值 比val_x 大则放到后续再进行合并</span></span><br><span class="line">                <span class="keyword">if</span> fy == fx <span class="keyword">or</span> val_y &gt; val_x:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="comment"># 等于最大值 则可以从两边加入集合 更新新的好路径</span></span><br><span class="line">                <span class="comment"># 故更新答案</span></span><br><span class="line">                <span class="keyword">if</span> val_y == val_x:</span><br><span class="line">                    ans = ans + cnt[fx] * cnt[fy] </span><br><span class="line">                    cnt[fx] = cnt[fx] + cnt[fy]</span><br><span class="line">                <span class="comment"># 否则不等于最大值 不更新新的好路径 但可以并入集合 其新集合的最大值 为原集合的最大值</span></span><br><span class="line">                p[fy] = fx</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans </span><br></pre></td></tr></table></figure><h2><span id="例4">例4</span></h2><p><a id="ex4"><strong>删除操作后的最大字段和</strong> </a><br>难度值: 3<br>原题链接:<br><a href="https://leetcode.cn/problems/maximum-segment-sum-after-removals/">https://leetcode.cn/problems/maximum-segment-sum-after-removals/</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maximumSegmentSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], removeQueries: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        n,p = <span class="built_in">len</span>(nums),<span class="built_in">list</span>(<span class="built_in">range</span>(<span class="built_in">len</span>(nums)))</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">x</span>):</span><br><span class="line">            <span class="keyword">if</span> p[x] != x:</span><br><span class="line">                p[x] = find(p[x])</span><br><span class="line">            <span class="keyword">return</span> p[x]</span><br><span class="line">        </span><br><span class="line">        cnt = n * [<span class="number">0</span>]</span><br><span class="line">        ans = [<span class="number">0</span>]</span><br><span class="line">        <span class="comment"># 维护当前数组最大子段和</span></span><br><span class="line">        m = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 按删除顺序反向操作 在复原过程中获得字段和</span></span><br><span class="line">        <span class="comment"># 用并查集维护连续性信息</span></span><br><span class="line">        <span class="comment"># 加入最后一个点时 全段长度此时默认为起始状态为0 不需考虑</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>,<span class="number">0</span>,-<span class="number">1</span>):</span><br><span class="line">            idx = removeQueries[i]</span><br><span class="line">            <span class="comment"># 先将当前点复原</span></span><br><span class="line">            cnt[idx] = nums[idx]</span><br><span class="line">            m = <span class="built_in">max</span>(m,nums[idx])</span><br><span class="line">            fi = find(idx)</span><br><span class="line">            <span class="comment"># 然后判断该点左右集合是连续</span></span><br><span class="line">            <span class="comment"># 如连续则合并集合</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> (idx - <span class="number">1</span>,idx + <span class="number">1</span>):</span><br><span class="line">                <span class="comment"># 越界 或者该点还没填入元素 则必然无法连续跳过</span></span><br><span class="line">                <span class="keyword">if</span> j &lt; <span class="number">0</span> <span class="keyword">or</span> j == n <span class="keyword">or</span> <span class="keyword">not</span> cnt[j]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                fj = find(j)</span><br><span class="line">                p[fj] = fi</span><br><span class="line">                cnt[fi] = cnt[fi] + cnt[fj]</span><br><span class="line">                m = <span class="built_in">max</span>(cnt[fi],m)</span><br><span class="line">            ans.append(m)</span><br><span class="line"></span><br><span class="line">        ans.reverse()</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h2><span id="例5">例5</span></h2><p><a id="ex5"><strong>省份数量</strong> </a><br>原题链接:<br><a href="https://leetcode.cn/problems/number-of-provinces/">https://leetcode.cn/problems/number-of-provinces/</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    就是计算连通块的数量</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findCircleNum</span>(<span class="params">self, isConnected: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(isConnected)</span><br><span class="line">        p = <span class="built_in">list</span>(<span class="built_in">range</span>(n))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">x</span>):</span><br><span class="line">            <span class="keyword">if</span> x!=p[x]:</span><br><span class="line">                p[x] = find(p[x])</span><br><span class="line">            <span class="keyword">return</span> p[x]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i + <span class="number">1</span>,n):</span><br><span class="line">                <span class="keyword">if</span> isConnected[i][j]:</span><br><span class="line">                    a = find(i)</span><br><span class="line">                    b = find(j)</span><br><span class="line">                    <span class="keyword">if</span> a == b:</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    p[a] = b</span><br><span class="line">                </span><br><span class="line">        s = <span class="built_in">set</span>()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> v <span class="keyword">in</span> p:</span><br><span class="line">            <span class="comment"># 这里一定要注意 并查集判断该点在哪个集合都是find(root)</span></span><br><span class="line">            s.add(find(v))</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(s)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2><span id="例6">例6</span></h2><p><a id="ex6 "><strong>冗余连接</strong> </a><br>原题链接:<br><a href="https://leetcode.cn/problems/redundant-connection/">https://leetcode.cn/problems/redundant-connection/</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findRedundantConnection</span>(<span class="params">self, edges: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        n = <span class="built_in">len</span>(edges)</span><br><span class="line">        p = <span class="built_in">list</span>(<span class="built_in">range</span>(n + <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">x</span>):</span><br><span class="line">            <span class="keyword">if</span> x != p[x]:</span><br><span class="line">                p[x] = find(p[x])</span><br><span class="line">            <span class="keyword">return</span> p[x]</span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">for</span> x,y <span class="keyword">in</span> edges:</span><br><span class="line">            a = find(x)</span><br><span class="line">            b = find(y)</span><br><span class="line">            <span class="keyword">if</span> a == b:</span><br><span class="line">                ans.append([x,y])</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> a!=b:</span><br><span class="line">                p[a] = b</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 最后的加进去的附加边长 就是在edges中最后出现的边</span></span><br><span class="line">        <span class="keyword">return</span> ans[-<span class="number">1</span>]</span><br><span class="line">           </span><br></pre></td></tr></table></figure><h2><span id="例7">例7</span></h2><p><a id="ex7 "><strong>连通网络的操作次数</strong> </a><br>原题链接:<br><a href="https://leetcode.cn/problems/number-of-operations-to-make-network-connected/">https://leetcode.cn/problems/number-of-operations-to-make-network-connected/</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">makeConnected</span>(<span class="params">self, n: <span class="built_in">int</span>, connections: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 线的数量</span></span><br><span class="line">        m = <span class="built_in">len</span>(connections)</span><br><span class="line">        <span class="comment"># n个点连通最少需要n - 1条边</span></span><br><span class="line">        <span class="keyword">if</span> m &lt; n - <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        p = <span class="built_in">list</span>(<span class="built_in">range</span>(n))</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">x</span>):</span><br><span class="line">            <span class="keyword">if</span> p[x]!=x:</span><br><span class="line">                p[x] = find(p[x])</span><br><span class="line">            <span class="keyword">return</span> p[x]</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="comment"># 只有一台计算机 连通分量值就是1</span></span><br><span class="line">        cur = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> x,y <span class="keyword">in</span> connections:</span><br><span class="line">            a = find(x)</span><br><span class="line">            b = find(y)</span><br><span class="line">            <span class="keyword">if</span> a == b:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            p[a] = b</span><br><span class="line">            cur = cur + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 最少只需将剩余连通分量连上即可</span></span><br><span class="line">        <span class="keyword">return</span> n-cur</span><br></pre></td></tr></table></figure><h2><span id="例8">例8</span></h2><p><a id="ex8"><strong>格子游戏</strong></a><br>原题链接:<br><a href="https://www.acwing.com/problem/content/1252/">https://www.acwing.com/problem/content/1252/</a><br>收录这题的主要原因是这题是二维并查集 怎么说呢 倒也不算难 不过之前如果没有经历过一次我觉得就很难做出来</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> N <span class="type">int</span> = <span class="number">210</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="built_in">make</span>([]<span class="type">int</span>, N*N)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">find</span><span class="params">(x <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">if</span> p[x] != x &#123;</span><br><span class="line">p[x] = find(p[x])</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> p[x]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">n, m := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">fmt.Scanf(<span class="string">&quot;%d %d&quot;</span>,&amp;n,&amp;m)</span><br><span class="line"><span class="comment">// 这里已经转换为二维的并查集了 所以要初始化的值为n*n </span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n * n; i++ &#123;</span><br><span class="line">p[i] = i</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">get := <span class="function"><span class="keyword">func</span><span class="params">(x, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">return</span> x*n + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">flag := <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= m; i++ &#123;</span><br><span class="line"><span class="keyword">var</span> x, y <span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> d <span class="type">string</span></span><br><span class="line">fmt.Scanf(<span class="string">&quot;%d %d %s&quot;</span>, &amp;x, &amp;y, &amp;d)</span><br><span class="line"><span class="comment">// 将下标映射到0开始</span></span><br><span class="line">x--</span><br><span class="line">y--</span><br><span class="line"><span class="comment">//fmt.Println(x,y,d)</span></span><br><span class="line"><span class="keyword">if</span> d == <span class="string">&quot;D&quot;</span> &#123;</span><br><span class="line">a := get(x, y)</span><br><span class="line">b := get(x+<span class="number">1</span>, y)</span><br><span class="line"><span class="keyword">if</span> find(a) == find(b) &#123;</span><br><span class="line">fmt.Println(i)</span><br><span class="line">flag = <span class="literal">true</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">p[b] = find(a)</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">a := get(x, y)</span><br><span class="line">b := get(x, y+<span class="number">1</span>)</span><br><span class="line"><span class="keyword">if</span> find(a) == find(b) &#123;</span><br><span class="line">fmt.Println(i)</span><br><span class="line">flag = <span class="literal">true</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">p[b] = find(a)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> flag == <span class="literal">false</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;draw&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="例9">例9</span></h2><p><a id="ex9"><strong>搭配购买</strong> </a><br>原题链接:<br><a href="https://www.acwing.com/problem/content/1254/">https://www.acwing.com/problem/content/1254/</a><br>并查集结合01背包问题</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> N = <span class="number">10010</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f = <span class="built_in">make</span>([]<span class="type">int</span>, N)</span><br><span class="line"><span class="keyword">var</span> w = <span class="built_in">make</span>([]<span class="type">int</span>, N)</span><br><span class="line"><span class="keyword">var</span> v = <span class="built_in">make</span>([]<span class="type">int</span>, N)</span><br><span class="line"><span class="keyword">var</span> p = <span class="built_in">make</span>([]<span class="type">int</span>, N)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">find</span><span class="params">(x <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">if</span> x != p[x] &#123;</span><br><span class="line">p[x] = find(p[x])</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> p[x]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> n, m, money <span class="type">int</span></span><br><span class="line">fmt.Scanf(<span class="string">&quot;%d %d %d&quot;</span>, &amp;n, &amp;m, &amp;money)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= n; i++ &#123;</span><br><span class="line">fmt.Scanf(<span class="string">&quot;%d %d&quot;</span>, &amp;v[i], &amp;w[i])</span><br><span class="line">p[i] = i</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">max := <span class="function"><span class="keyword">func</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line"><span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; m; i++ &#123;</span><br><span class="line"><span class="keyword">var</span> a, b <span class="type">int</span></span><br><span class="line">fmt.Scanf(<span class="string">&quot;%d %d&quot;</span>, &amp;a, &amp;b)</span><br><span class="line">pa := find(a)</span><br><span class="line">pb := find(b)</span><br><span class="line"><span class="keyword">if</span> pa == pb &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">v[pb] += v[pa]</span><br><span class="line">w[pb] += w[pa]</span><br><span class="line">p[pa] = pb</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= n; i++ &#123;</span><br><span class="line"><span class="keyword">if</span> p[i] == i &#123;</span><br><span class="line"><span class="keyword">for</span> j := money; j &gt;= v[i]; j-- &#123;</span><br><span class="line">f[j] = max(f[j], f[j-v[i]]+w[i])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(f[money])</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algo </category>
          
          <category> 算法总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法题型归纳 </tag>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode768最多能完成排序的块-贪心-哈希-单调栈</title>
      <link href="/2022/09/17/leetcode/leetcode768%E6%9C%80%E5%A4%9A%E8%83%BD%E5%AE%8C%E6%88%90%E6%8E%92%E5%BA%8F%E7%9A%84%E5%9D%97-%E8%B4%AA%E5%BF%83-%E5%93%88%E5%B8%8C-%E5%8D%95%E8%B0%83%E6%A0%88/"/>
      <url>/2022/09/17/leetcode/leetcode768%E6%9C%80%E5%A4%9A%E8%83%BD%E5%AE%8C%E6%88%90%E6%8E%92%E5%BA%8F%E7%9A%84%E5%9D%97-%E8%B4%AA%E5%BF%83-%E5%93%88%E5%B8%8C-%E5%8D%95%E8%B0%83%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>原题链接：<br><a href="https://leetcode.cn/problems/max-chunks-to-make-sorted-ii/">https://leetcode.cn/problems/max-chunks-to-make-sorted-ii/</a></p><p>首先明确题目的意思就是排序后的序列 与 将数组分隔后的再将每一个小分组排序后拼接的顺序是一样的<br>也就是分隔的小分组内的数与排序后相应位置所出现的数频率一定要是一样的<br>接下来可以用 <strong>贪心</strong> 来思考<br>如果排序后的数与分割后的小数组的数是全部对应的话 那么数组划分时必然需要先满足左边 因为如果左边的数都对应不上的话 那么整体必然无法对应<br>由此可得</p><h2><span id="法1-哈希">法1: 哈希</span></h2><p>同时遍历当前数组 以及排序后的数组<br>以hash表记录当前区间出现的 元素:出现频率<br>在原数组出现则将频率+1 在排序数组出现则-1<br>当频率恰好为0时 删除这个键值<br>当整个hash表长度为0时 此时的划分应恰好为符合条件的最短序列长度 将 ans + 1</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxChunksToSorted</span>(<span class="params">self, arr: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 元素 -&gt; 出现频次</span></span><br><span class="line">        d = defaultdict(<span class="built_in">int</span>)</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> x,y <span class="keyword">in</span> <span class="built_in">zip</span>(arr,<span class="built_in">sorted</span>(arr)):</span><br><span class="line">            d[x] = d[x] + <span class="number">1</span></span><br><span class="line">            d[y] = d[y] - <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> d[x] ==<span class="number">0</span>:</span><br><span class="line">                <span class="keyword">del</span> d[x]</span><br><span class="line">            <span class="keyword">if</span> d[y] == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">del</span> d[y]</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(d) == <span class="number">0</span>:</span><br><span class="line">                ans = ans + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans </span><br></pre></td></tr></table></figure><p>时间复杂度 O(nlogn) 主要在排序上 后面的遍历是O(n) </p><h2><span id="法2-单调栈">法2: 单调栈</span></h2><p>哈希的核心思想是记录每个区间是否对应 故而存储了每个一个区间的对应的信息<br>但其实我们只需要维护每一个区间的最大值即可 还是根据贪心的思想 正确分组只会出现在左边<br>每次遍历新元素x时 与当前栈顶元素 即上一个符合条件区间的最大值比较 如果小于 则证明x应该处于上一个区间 不断出栈 直到找到一个大于x的元素 或者区间为空 则将x与上一个最大值大于它的区间合并 且将该区间的最大值重新压入栈 即保证栈中所存储的是每一个区间的最大值 且是单调递增的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxChunksToSorted</span>(<span class="params">self, arr: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        stk = []</span><br><span class="line">        <span class="keyword">for</span> v <span class="keyword">in</span> arr:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> stk:</span><br><span class="line">                stk.append(v)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            t = v</span><br><span class="line">            pre = stk[-<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">while</span> stk <span class="keyword">and</span> v &lt; stk[-<span class="number">1</span>]:</span><br><span class="line">                t = pre</span><br><span class="line">                stk.pop()</span><br><span class="line">            stk.append(t)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(stk)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algo </category>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心 </tag>
            
            <tag> 哈希 </tag>
            
            <tag> 单调栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode1387将整数按权重排序-记忆化搜索优化</title>
      <link href="/2022/09/14/leetcode/leetcode1387%E5%B0%86%E6%95%B4%E6%95%B0%E6%8C%89%E6%9D%83%E9%87%8D%E6%8E%92%E5%BA%8F-%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2%E4%BC%98%E5%8C%96/"/>
      <url>/2022/09/14/leetcode/leetcode1387%E5%B0%86%E6%95%B4%E6%95%B0%E6%8C%89%E6%9D%83%E9%87%8D%E6%8E%92%E5%BA%8F-%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>原题链接:<br><a href="https://leetcode.cn/problems/sort-integers-by-the-power-value/">https://leetcode.cn/problems/sort-integers-by-the-power-value/</a></p><h2><span id="法1-暴搜">法1 暴搜</span></h2><p>基础暴搜的方式 就是按照题意模拟的即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getKth</span>(<span class="params">self, lo: <span class="built_in">int</span>, hi: <span class="built_in">int</span>, k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(lo,hi + <span class="number">1</span>):</span><br><span class="line">            w = <span class="number">0</span></span><br><span class="line">            t = x</span><br><span class="line">            <span class="keyword">while</span> x!=<span class="number">1</span>: </span><br><span class="line">                w = w + <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> x%<span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">                    x//=<span class="number">2</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    x = x * <span class="number">3</span> + <span class="number">1</span></span><br><span class="line">            ans.append([w,t])</span><br><span class="line">        </span><br><span class="line">        res = <span class="built_in">sorted</span>(ans,key=<span class="keyword">lambda</span> x:x[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res[k-<span class="number">1</span>][<span class="number">1</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2><span id="法2-记忆化搜索">法2: 记忆化搜索</span></h2><p>注意到每次搜索时其实存在了很多次重复计算<br>每次f(x)的权值可由下列情况推得</p><ol><li>x&#x3D;&#x3D;1 f(x) &#x3D; 0</li><li>x为偶数时 f(x) &#x3D; f(x&#x2F;2) + 1</li><li>x为奇数时 f(x) &#x3D; 3 * f(x) + 1<br>可知 f(x)可以直接上<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getKth</span>(<span class="params">self, lo: <span class="built_in">int</span>, hi: <span class="built_in">int</span>, k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(lo,hi + <span class="number">1</span>):</span><br><span class="line">            w = <span class="number">0</span></span><br><span class="line">            t = x</span><br><span class="line">            <span class="keyword">while</span> x!=<span class="number">1</span>: </span><br><span class="line">                w = w + <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> x%<span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">                    x//=<span class="number">2</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    x = x * <span class="number">3</span> + <span class="number">1</span></span><br><span class="line">            ans.append([w,t])</span><br><span class="line">        </span><br><span class="line">        res = <span class="built_in">sorted</span>(ans,key=<span class="keyword">lambda</span> x:x[<span class="number">0</span>])</span><br><span class="line">        <span class="comment"># 一个f(x/2) 或 3 * f(x) 的状态直接+1 得来不需要再进行重复进行 这种方式即为记忆化搜索</span></span><br><span class="line">        <span class="keyword">return</span> res[k-<span class="number">1</span>][<span class="number">1</span>]</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> algo </category>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 记忆化搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode669-修剪二叉搜索树-dfs</title>
      <link href="/2022/09/10/leetcode/leetcode669-%E4%BF%AE%E5%89%AA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91-dfs/"/>
      <url>/2022/09/10/leetcode/leetcode669-%E4%BF%AE%E5%89%AA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91-dfs/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>原题链接:<br><a href="https://leetcode.cn/problems/trim-a-binary-search-tree/">https://leetcode.cn/problems/trim-a-binary-search-tree/</a><br>比较好的一道递归<br>后序遍历的思路 先处理好下面的结点然后依次返回结果<br>处理方式 按照bst的定义<br>1.如果node为空 直接返回<br>2.如果右子树为空 直接返回左子树<br>1.如果右子树非空 则将左子树接在右子树的最左侧 然后返回右子树</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">trimBST</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], low: <span class="built_in">int</span>, high: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">node</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            node.left = dfs(node.left)</span><br><span class="line">            node.right = dfs(node.right)</span><br><span class="line">            v = node.val</span><br><span class="line">            <span class="comment"># bst 删除节点的套路是相同的</span></span><br><span class="line">            <span class="comment"># 不要往上看 就是将其左子树 接在右子树最左侧即可</span></span><br><span class="line">            <span class="keyword">if</span> v &lt; low <span class="keyword">or</span> v &gt; high:</span><br><span class="line">                cur = node.right</span><br><span class="line">                <span class="comment"># 如果右子树为空 则直接返回左子树</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> cur:</span><br><span class="line">                    <span class="keyword">return</span> node.left</span><br><span class="line">                tmp = cur </span><br><span class="line">                <span class="keyword">while</span> cur.left:</span><br><span class="line">                    cur = cur.left</span><br><span class="line">                cur.left = node.left</span><br><span class="line">                <span class="keyword">return</span> tmp</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> node</span><br><span class="line"></span><br><span class="line">        root = dfs(root)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algo </category>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dfs </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>笔试套卷-腾讯音乐集团2022暑期实习生招聘技术岗编程题</title>
      <link href="/2022/09/09/%E7%AC%94%E8%AF%95%E5%A5%97%E5%8D%B7-%E8%85%BE%E8%AE%AF%E9%9F%B3%E4%B9%90%E9%9B%86%E5%9B%A22022%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0%E7%94%9F%E6%8B%9B%E8%81%98%E6%8A%80%E6%9C%AF%E5%B2%97%E7%BC%96%E7%A8%8B%E9%A2%98/"/>
      <url>/2022/09/09/%E7%AC%94%E8%AF%95%E5%A5%97%E5%8D%B7-%E8%85%BE%E8%AE%AF%E9%9F%B3%E4%B9%90%E9%9B%86%E5%9B%A22022%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0%E7%94%9F%E6%8B%9B%E8%81%98%E6%8A%80%E6%9C%AF%E5%B2%97%E7%BC%96%E7%A8%8B%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>原卷地址:<br><a href="https://www.nowcoder.com/test/39959332/summary">https://www.nowcoder.com/test/39959332/summary</a></p><h2><span id="t1">T1:</span></h2><p>比较基础的一题 只需要知道只有2的幂对应二进制肯定只有一个1即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minCnt</span>(<span class="params">self , s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> s.count(<span class="string">&quot;1&quot;</span>) - <span class="number">1</span></span><br></pre></td></tr></table></figure><h2><span id="t2">T2:</span></h2><p><font color="red">贪心+二分</font><br>先对数组进行排序<br>每次将最后一个数即最大的数减去x 然后再通过二分寻找该数减去x后的合适位置 并将其放入<br>排序是nlogn 二分 klogn<br>总复杂度 (n+k)logn</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"><span class="keyword">from</span> bisect <span class="keyword">import</span> bisect_left</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minMax</span>(<span class="params">self, a: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span>, x: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        a.sort()</span><br><span class="line">        r = <span class="built_in">len</span>(a) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> k:</span><br><span class="line">            k = k - <span class="number">1</span></span><br><span class="line">            a[r] = a[r] - x</span><br><span class="line">            l = bisect_left(a, a[r])</span><br><span class="line">            a.insert(l,a[r])</span><br><span class="line">            a.pop()</span><br><span class="line">        <span class="keyword">return</span> a[r]</span><br></pre></td></tr></table></figure><h2><span id="t3">T3</span></h2><p>这种求连续最大长度的题 可考虑使用dp<br>应该是全场最难的一题</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">MOD = <span class="number">10</span>**<span class="number">6</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    dp[i][j] 表示长度为i 可分为j段的子串个数</span></span><br><span class="line"><span class="string">    对当前加入字符串的字母</span></span><br><span class="line"><span class="string">    如果当前字母与之前的字母可以构成连续串</span></span><br><span class="line"><span class="string">        dp[i][j] = dp[i-1][j]</span></span><br><span class="line"><span class="string">        因为根据定义尾部至少有两个字母相等了 再加上尾部的这个仍然还是相等</span></span><br><span class="line"><span class="string">    如果当前字母不能与之前的字母构成连续串</span></span><br><span class="line"><span class="string">        dp[i][j] = 25 * dp[i-2][j-1]</span></span><br><span class="line"><span class="string">        还是因为定义 连续子串至少要有2个字母构成 不能与尾部的两个字符构成连续串 那就只能与i-2的字母构成 这样的选择除了尾部的字符种类还有25种</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">numsOfStrings</span>(<span class="params">self , n: <span class="built_in">int</span>, k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        dp = [[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k+<span class="number">10</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">10</span>)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,n+<span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 长度为2 以上串 符合连续串的条件</span></span><br><span class="line">            <span class="comment"># 全部组成一段的方案数有26种</span></span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="number">26</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 第1段已经赋了初值</span></span><br><span class="line">        <span class="comment"># 第2段长度4开始 已经2 + 2才可能存在两段</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>,n+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,k+<span class="number">1</span>):</span><br><span class="line">                dp[i][j] = (dp[i-<span class="number">1</span>][j] + <span class="number">25</span> * dp[i-<span class="number">2</span>][j-<span class="number">1</span>])%MOD</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[n][k]</span><br></pre></td></tr></table></figure><h2><span id="t4">T4</span></h2><p>BFS层序遍历的基础上 判断根据上下两层是否需要删除的情况进行操作<br>因为是要根据上下两层进行操作所以对于第0层要进行一个特判 即将0层算入要删除的层 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    1.先将所有需要删除的层加入set中</span></span><br><span class="line"><span class="string">    2.BFS:</span></span><br><span class="line"><span class="string">        如果当前层上一层为要删除层 且当前层不需要删除 则将该节点加入答案</span></span><br><span class="line"><span class="string">        将该节点的左右节点加入队列</span></span><br><span class="line"><span class="string">        若当前节点的下一层需要删除 则断开当前节点与其左右节点的连接</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    特判: 将第0层也加入队列视作要删除层 因为可能第一层也是要删除的</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deleteLevel</span>(<span class="params">self, root: TreeNode, a: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[TreeNode]:</span><br><span class="line">        s = <span class="built_in">set</span>()</span><br><span class="line">        <span class="comment"># 将所有要删除的层 加入set 便于后续的判断</span></span><br><span class="line">        <span class="keyword">for</span> d <span class="keyword">in</span> a:</span><br><span class="line">            s.add(d)</span><br><span class="line">        <span class="comment"># 特判 将0层作为删除层</span></span><br><span class="line">        s.add(<span class="number">0</span>)</span><br><span class="line">        q = deque()</span><br><span class="line">        q.append(root)</span><br><span class="line">        d = <span class="number">0</span></span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            d = d + <span class="number">1</span></span><br><span class="line">            w = <span class="built_in">len</span>(q)</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(w):</span><br><span class="line">                node = q.popleft()</span><br><span class="line">                <span class="comment"># 如果上一层为要删除的 而该层不需要删除 那么该层节点为新的独立子树 加入ans中</span></span><br><span class="line">                <span class="keyword">if</span> d - <span class="number">1</span> <span class="keyword">in</span> s <span class="keyword">and</span> d <span class="keyword">not</span> <span class="keyword">in</span> s:</span><br><span class="line">                    ans.append(node)</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    q.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    q.append(node.right)</span><br><span class="line">                <span class="comment"># 如果下一层是需要删除 则断开当前节点与其左右子节点的联系</span></span><br><span class="line">                <span class="keyword">if</span> d + <span class="number">1</span> <span class="keyword">in</span> s:</span><br><span class="line">                    node.left =<span class="literal">None</span></span><br><span class="line">                    node.right = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2><span id="t5">T5</span></h2><p>这题关键在于明白异或的运算结果与运算顺序无关<br>故可以先求父节点的运算结果然后再通过dfs向其子树进行传递</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 返回值的树节点中val表示节点权值</span></span><br><span class="line"><span class="comment"># @param root TreeNode类 给定的初始树节点中的val表示节点编号</span></span><br><span class="line"><span class="comment"># @param op int整型二维数组 op的组成为[[id,v],[id,v],[id,v],...]</span></span><br><span class="line"><span class="comment"># @return TreeNode类</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    异或运算的先后顺序不影响结果</span></span><br><span class="line"><span class="string">    所以可以对某节点先执行完所有异或操作后 再通过dfs将结果传递给其所有子树</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">xorTree</span>(<span class="params">self, root: TreeNode, op: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; TreeNode:</span><br><span class="line">        h = defaultdict(<span class="built_in">int</span>)</span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">id</span>, v <span class="keyword">in</span> op:</span><br><span class="line">            h[<span class="built_in">id</span>] ^= v</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">node: TreeNode, fa: <span class="built_in">int</span></span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="comment"># 有进行过异或操作则直接赋值 否则默认为0</span></span><br><span class="line">            node.val = h[node.val]</span><br><span class="line">            node.val^=fa</span><br><span class="line"></span><br><span class="line">            dfs(node.left, node.val)</span><br><span class="line">            dfs(node.right, node.val)</span><br><span class="line"></span><br><span class="line">        dfs(root, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><h2><span id="t6">T6#</span></h2><p>非常基础的一题 比第一题还简单不知道为啥放到最后</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">howMany</span>(<span class="params">self , S: <span class="built_in">str</span>, k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">26</span>):</span><br><span class="line">            ch = <span class="built_in">chr</span>(i+<span class="number">97</span>)</span><br><span class="line">            <span class="keyword">if</span> S.count(ch) &gt;= k:</span><br><span class="line">                ans = ans + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line">        <span class="comment"># write code here</span></span><br></pre></td></tr></table></figure><h2><span id="总结">总结</span></h2><p>由于这张卷只写了编程题合集所以我也不知道这些是笔试还是把面试都算进去了<br>但总的来说难度不算大 2345 大概是leetcode mid的程度<br>另外牛客上的提交与力扣有些不一样 defaultdict这些比较常用都需要手动导入 牛客是不会导入collections集合这点要注意一下 不过牛客没有频繁提交次数限制还是蛮不错的</p>]]></content>
      
      
      <categories>
          
          <category> algo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法笔试 </tag>
            
            <tag> 腾讯笔试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode2397-列覆盖的最多行数-枚举的优化思路</title>
      <link href="/2022/09/07/leetcode/leetcode2397-%E5%88%97%E8%A6%86%E7%9B%96%E7%9A%84%E6%9C%80%E5%A4%9A%E8%A1%8C%E6%95%B0-%E6%9E%9A%E4%B8%BE%E7%9A%84%E4%BC%98%E5%8C%96%E6%80%9D%E8%B7%AF/"/>
      <url>/2022/09/07/leetcode/leetcode2397-%E5%88%97%E8%A6%86%E7%9B%96%E7%9A%84%E6%9C%80%E5%A4%9A%E8%A1%8C%E6%95%B0-%E6%9E%9A%E4%B8%BE%E7%9A%84%E4%BC%98%E5%8C%96%E6%80%9D%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>原题链接:<br><a href="https://leetcode.cn/problems/maximum-rows-covered-by-columns/">https://leetcode.cn/problems/maximum-rows-covered-by-columns/</a><br>枚举题 基础做法很简单 枚举出所有可选列的组合 模拟题意操作一遍 然后返回结果即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    先枚举出出所有列==cols的可能组合</span></span><br><span class="line"><span class="string">    然后再按照枚举结果 将所有列覆盖 然后返回结果</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maximumRows</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], numSelect: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line"></span><br><span class="line">        m = <span class="built_in">len</span>(matrix)</span><br><span class="line">        n = <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">        h = []</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 当前所选择的列 所选的列数总和</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">c: <span class="built_in">int</span>, total: <span class="built_in">int</span>, s: <span class="built_in">list</span></span>):</span><br><span class="line">            <span class="keyword">if</span> total == numSelect:</span><br><span class="line">                h.append(<span class="built_in">list</span>(s))</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> c &lt; <span class="number">0</span> <span class="keyword">or</span> c &gt;= n:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="comment"># 不取当前的c 直接下一层dfs</span></span><br><span class="line">            dfs(c + <span class="number">1</span>, total, s)</span><br><span class="line">            s.append(c)</span><br><span class="line">            <span class="comment"># 取当前的c total+1 然后下一层</span></span><br><span class="line">            dfs(c + <span class="number">1</span>, total + <span class="number">1</span>, s)</span><br><span class="line">            s.remove(c)</span><br><span class="line"></span><br><span class="line">        dfs(<span class="number">0</span>, <span class="number">0</span>, [])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 计算被覆盖的行数</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">countAns</span>():</span><br><span class="line">            res = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">                flag = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                    <span class="keyword">if</span> matrix[i][j] == <span class="number">1</span>:</span><br><span class="line">                        flag = <span class="literal">False</span></span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                res = res + flag</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line"><span class="comment"># 这里注意一定要用深拷贝</span></span><br><span class="line"><span class="comment"># python数组都是地址调用 否则后续对martrix的修改会直接影响到back数组 这样对martix进行备份也就没有意义了</span></span><br><span class="line">        back = copy.deepcopy(matrix)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 然后根据所有 枚举出来的列的组合进行模拟</span></span><br><span class="line">        <span class="keyword">for</span> arr <span class="keyword">in</span> h:</span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> arr:</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">                    matrix[i][c] = <span class="number">0</span></span><br><span class="line">            ans = <span class="built_in">max</span>(ans, countAns())</span><br><span class="line"><span class="comment"># 这里用深拷贝的原因与之前相同</span></span><br><span class="line">            matrix = copy.deepcopy(back)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><p><font color="red">优化1:</font><br>上述思路在最后判断答案时使用了深拷贝进行模拟后然后枚举答案<br>在这一步可以优化一下<br>对于任意一种列组合的情况下遍历矩阵时 假设i行j列为1 <font color="blue">那么我们只需要判断 这个当前的第j行 是否处于我们当前所枚举的列组合之中即可 如果存在则证明这个1 是可以被覆盖</font><br>优化代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">      ans = <span class="number">0</span></span><br><span class="line"><span class="comment"># 枚举所有列的组合</span></span><br><span class="line">      <span class="keyword">for</span> arr <span class="keyword">in</span> h:</span><br><span class="line">          tmp = <span class="number">0</span></span><br><span class="line">          <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">              flag = <span class="literal">True</span></span><br><span class="line">              <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line"><span class="comment"># 对每行元素进行判断 如果当前列为1 且当前列并在枚举的列的集合 </span></span><br><span class="line"><span class="comment"># flag置为false 即该行没有被覆盖</span></span><br><span class="line">                  <span class="keyword">if</span> matrix[i][j] == <span class="number">1</span> <span class="keyword">and</span> arr.count(j) == <span class="number">0</span>:</span><br><span class="line">                      flag = <span class="literal">False</span></span><br><span class="line">                      <span class="keyword">break</span></span><br><span class="line">              tmp = tmp + flag</span><br><span class="line">          ans = <span class="built_in">max</span>(ans, tmp)</span><br></pre></td></tr></table></figure><p><font color="red">优化2:</font><br>在上一步的基础我们可以继续进行优化 之前我们采用枚举策略是直接枚举矩阵元素<br>但我们可以考虑用<strong>二进制的方式</strong>代表集合<br><font color="blue">二进制的第i位为1表示i在集合中 为0表示i不在集合中<br>这样可以用二进制枚举集合 同时把mat的每一行也用二进制表示 从而做到O(1)判断行中的所有1是否被覆盖</font><br>优化代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maximumRows</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], numSelect: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        m, n = <span class="built_in">len</span>(matrix), <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">        <span class="comment"># 用于代表原矩阵</span></span><br><span class="line">        <span class="comment"># i行 其中二进制 就代表原矩阵的0 1分布</span></span><br><span class="line">        arr = m * [<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">if</span> matrix[i][j] == <span class="number">1</span>:</span><br><span class="line">                    <span class="comment"># 第i行 第j列为1 则直接mask[i] | 2^j-1 即将mask[i]的第j位置为1</span></span><br><span class="line">                    arr[i] |= <span class="number">1</span> &lt;&lt; j</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 一共n列</span></span><br><span class="line">        h = <span class="number">1</span> &lt;&lt; n</span><br><span class="line"></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 枚举所有列选举的方案</span></span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> <span class="built_in">range</span>(h):</span><br><span class="line">            <span class="comment"># 如果当前枚举的方案中的列数符合题目要求 则进行判断</span></span><br><span class="line">            <span class="keyword">if</span> s.bit_count() == numSelect:</span><br><span class="line">                tmp = <span class="number">0</span></span><br><span class="line">                <span class="keyword">for</span> row <span class="keyword">in</span> arr:</span><br><span class="line">                    <span class="comment"># 如果row为s的子集 即代表row中1 都可以被枚举方案s 中的列覆盖</span></span><br><span class="line">                    <span class="keyword">if</span> row &amp; s == row:</span><br><span class="line">                        tmp = tmp + <span class="number">1</span></span><br><span class="line">                ans = <span class="built_in">max</span>(ans, tmp)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algo </category>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 枚举 </tag>
            
            <tag> 二进制优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法模板-trie树</title>
      <link href="/2022/09/06/algoSummary/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF-trie%E6%A0%91/"/>
      <url>/2022/09/06/algoSummary/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF-trie%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>trie树 又名字典树<br>存储单词的集合 在一些特定的问题里 非常有用 比如寻找相同前缀的单词数量等<br>通常附加上题目中有特别强调字符都是小写字母或者大写字母时 就会用到tire树</p><p>核心数据结构就是一个son[p][u]<br>其中第一维 表示这个当前字母所在的位置</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p = son[p][u] =idx</span><br></pre></td></tr></table></figure><p>第二维 表示这个位置所存储的单词</p><p>核心操作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 插入操作</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">insert</span>(<span class="params">s: <span class="built_in">str</span></span>):</span><br><span class="line">    p = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">        <span class="comment"># 将字母映射成数字</span></span><br><span class="line">        u = <span class="built_in">ord</span>(s[i]) - <span class="built_in">ord</span>(<span class="string">&quot;a&quot;</span>)</span><br><span class="line">        <span class="comment"># 如果当前单词结尾的这个字母不存在</span></span><br><span class="line">        <span class="comment"># 则创建新的枝条</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> son[p][u]:</span><br><span class="line"><span class="comment"># 这里用global 是因为 idx通常会定义成全局的 </span></span><br><span class="line"><span class="comment"># 如果用是在一个class内 比如力扣的那种情况 其实nonlocal也可以</span></span><br><span class="line">            <span class="keyword">global</span> idx</span><br><span class="line">            idx = idx + <span class="number">1</span></span><br><span class="line">            son[p][u] = idx</span><br><span class="line">        <span class="comment"># 走到下一个点</span></span><br><span class="line">        p = son[p][u]</span><br><span class="line">    <span class="comment"># 单词s的存在数量+1</span></span><br><span class="line">    cnt[p] = cnt[p] + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查询操作</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">s: <span class="built_in">str</span></span>):</span><br><span class="line">    p = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">        u = <span class="built_in">ord</span>(s[i]) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> son[p][u]:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        p = son[p][u]</span><br><span class="line">    <span class="comment"># 返回该单词的存在数量</span></span><br><span class="line">    <span class="keyword">return</span> cnt[p]</span><br></pre></td></tr></table></figure><p>基础应用:<br>acwing835<br>原题链接: <a href="https://www.acwing.com/problem/content/description/837/">https://www.acwing.com/problem/content/description/837/</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">N = <span class="number">100010</span></span><br><span class="line">idx = <span class="number">0</span></span><br><span class="line"><span class="comment"># trie树 每条枝代表一个单词 假设出现的字母只有26个小写字母</span></span><br><span class="line">son = [[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">26</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(N)]</span><br><span class="line"><span class="comment"># 记录 编号为idx 的单词 出现的次数</span></span><br><span class="line">cnt = N * [<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">insert</span>(<span class="params">s: <span class="built_in">str</span></span>):</span><br><span class="line">    p = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">        <span class="comment"># 将字母映射成数字</span></span><br><span class="line">        u = <span class="built_in">ord</span>(s[i]) - <span class="built_in">ord</span>(<span class="string">&quot;a&quot;</span>)</span><br><span class="line">        <span class="comment"># 如果当前单词结尾的这个字母不存在</span></span><br><span class="line">        <span class="comment"># 则创建新的枝条</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> son[p][u]:</span><br><span class="line">            <span class="keyword">global</span> idx</span><br><span class="line">            idx = idx + <span class="number">1</span></span><br><span class="line">            son[p][u] = idx</span><br><span class="line">        <span class="comment"># 走到下一个点</span></span><br><span class="line">        p = son[p][u]</span><br><span class="line">    <span class="comment"># 单词s的存在数量+1</span></span><br><span class="line">    cnt[p] = cnt[p] + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">s: <span class="built_in">str</span></span>):</span><br><span class="line">    p = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">        u = <span class="built_in">ord</span>(s[i]) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> son[p][u]:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        p = son[p][u]</span><br><span class="line">    <span class="comment"># 返回该单词的存在数量</span></span><br><span class="line">    <span class="keyword">return</span> cnt[p]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">T = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line"><span class="keyword">while</span> T:</span><br><span class="line">    T = T - <span class="number">1</span></span><br><span class="line">    op,s = <span class="built_in">input</span>().split(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> op == <span class="string">&#x27;I&#x27;</span>:</span><br><span class="line">        insert(s)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(find(s))</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algo </category>
          
          <category> 算法总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> trie树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode2401-最长优雅子数组-位运算的巧妙使用</title>
      <link href="/2022/09/05/leetcode/leetcode2401-%E6%9C%80%E9%95%BF%E4%BC%98%E9%9B%85%E5%AD%90%E6%95%B0%E7%BB%84-%E4%BD%8D%E8%BF%90%E7%AE%97%E7%9A%84%E5%B7%A7%E5%A6%99%E4%BD%BF%E7%94%A8/"/>
      <url>/2022/09/05/leetcode/leetcode2401-%E6%9C%80%E9%95%BF%E4%BC%98%E9%9B%85%E5%AD%90%E6%95%B0%E7%BB%84-%E4%BD%8D%E8%BF%90%E7%AE%97%E7%9A%84%E5%B7%A7%E5%A6%99%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>原题链接：<br><a href="https://leetcode.cn/problems/longest-nice-subarray/">https://leetcode.cn/problems/longest-nice-subarray/</a><br>这题关键在于想到:<br>1.<font color="blue">或运算(|) 可以保存一段连续的数中 互相与运算(&amp;)的结果</font><br>比如 如果要判断 001 与 101 110相与是否为0<br>其实就是看 001 的1的位置 与 101 110中1的位置是否重合<br>就等价于看001中1的位置是否与 111中1的位置是否重合<br>2.<font color="blue">异或运算可以还原或运算的结果</font><br>或运算的过程其实就是保留1的过程 将之前同样的数与当前与结果按顺序异或相当于不断将保留的1 进行还原 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">longestNiceSubarray</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        l, r = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">        w = nums[l]</span><br><span class="line">        ans = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> r &lt; n:</span><br><span class="line">            <span class="keyword">while</span> w &amp; nums[r] != <span class="number">0</span> <span class="keyword">and</span> l &lt; r:</span><br><span class="line">                <span class="comment"># 这里用异或</span></span><br><span class="line">                <span class="comment"># 因为之前是 与运算 0 1 为0 只有 1 1 才会保留 相当于将原先w中的1 消去</span></span><br><span class="line">                <span class="comment"># 使用异或运算 相当于按顺序将原先w 中的1 还原</span></span><br><span class="line">                w ^= nums[l]</span><br><span class="line">                l = l + <span class="number">1</span></span><br><span class="line">            w = w | nums[r]</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, r - l + <span class="number">1</span>)</span><br><span class="line">            r = r + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algo </category>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode652-寻找重复的子树-序列编号</title>
      <link href="/2022/09/05/leetcode/leetcode652-%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E6%A0%91-%E5%BA%8F%E5%88%97%E7%BC%96%E5%8F%B7/"/>
      <url>/2022/09/05/leetcode/leetcode652-%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E6%A0%91-%E5%BA%8F%E5%88%97%E7%BC%96%E5%8F%B7/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>原题链接:<br><a href="https://leetcode.cn/problems/find-duplicate-subtrees/">https://leetcode.cn/problems/find-duplicate-subtrees/</a><br>对于每一种子树以一个三元组进行编号<br>(node.val,l,r) —&gt; (node,idx)<br>node.val为节点的值 l,r 为左右子树的编号<br>node 为节点 idx为该节点的编号<br>这样当我们每发现一种新的子树 那么就给这个子树编号 否则就将该子树 加入结果 与相同的共用一个编号</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findDuplicateSubtrees</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="type">Optional</span>[TreeNode]]:</span><br><span class="line">        <span class="comment"># 用于记录节点的 编号</span></span><br><span class="line">        <span class="comment"># 三元组 -&gt; 节点编号</span></span><br><span class="line">        <span class="comment"># (v,l,r) -&gt; (node,idx)</span></span><br><span class="line">        seen = <span class="built_in">dict</span>()</span><br><span class="line">        <span class="comment"># 记录结果</span></span><br><span class="line">        repeat = <span class="built_in">set</span>()</span><br><span class="line">        </span><br><span class="line">        idx = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">node</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            </span><br><span class="line">            tri = (node.val,dfs(node.left),dfs(node.right)) </span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> tri <span class="keyword">in</span> seen:</span><br><span class="line">                (tree,index) = seen[tri]</span><br><span class="line">                repeat.add(tree)</span><br><span class="line">                <span class="comment"># 重复出现的树 所以共用一个编号 </span></span><br><span class="line">                <span class="keyword">return</span> index</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">nonlocal</span> idx </span><br><span class="line">                idx = idx + <span class="number">1</span></span><br><span class="line">                seen[tri] = (node,idx)</span><br><span class="line">                <span class="comment"># 新出现的树 需要新的编号</span></span><br><span class="line">                <span class="keyword">return</span> idx</span><br><span class="line">            </span><br><span class="line">        dfs(root)</span><br><span class="line"><span class="comment"># 这里返回的时候注意 转换为list</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">list</span>(repeat)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algo </category>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dfs </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode1345-跳跃游戏-bfs优化问题</title>
      <link href="/2022/09/02/leetcode/leetcode1345-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F-bfs%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98/"/>
      <url>/2022/09/02/leetcode/leetcode1345-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F-bfs%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>原题链接:<br><a href="https://leetcode.cn/problems/jump-game-iv/">https://leetcode.cn/problems/jump-game-iv/</a><br>这题基本思路比较BFS 每次扩展 i-1,i+1,值与arr[i]相同的点<br>但这题数据范围为5 * 10^4 如果arr[i]相等的边有m条 那么由于是一个无向图 那么这样的遍历的将会n^2 次 所以这一步是优化的关键<br>优化的思路是 是使用bfs 求最短路的路径 bfs求最短路只有第一次更新时求出的值是最小值 所以当你一次扩展值均为v的点后 直接删除v即可 下一次不必再遍历 即对于相同值得所有点只走一遍</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minJumps</span>(<span class="params">self, arr: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 先记录所有与值相同点的下标</span></span><br><span class="line">        h = defaultdict(<span class="built_in">list</span>)</span><br><span class="line">        <span class="keyword">for</span> i, v <span class="keyword">in</span> <span class="built_in">enumerate</span>(arr):</span><br><span class="line">            h[v].append(i)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 队列存 下标</span></span><br><span class="line">        q = deque()</span><br><span class="line">        q.append(<span class="number">0</span>)</span><br><span class="line">        n = <span class="built_in">len</span>(arr)</span><br><span class="line">        st = n * [inf]</span><br><span class="line">        st[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            t = q.popleft()</span><br><span class="line">            v = arr[t]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> ne <span class="keyword">in</span> t-<span class="number">1</span>,t+<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">if</span> <span class="number">0</span> &lt;= ne &lt; n <span class="keyword">and</span> st[ne] &gt; st[t] + <span class="number">1</span>:            </span><br><span class="line">                    st[ne] = st[t] + <span class="number">1</span></span><br><span class="line">                    q.append(ne)</span><br><span class="line">                <span class="keyword">if</span> ne == n-<span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">return</span> st[ne]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> h[v]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> ne <span class="keyword">in</span> h[v][::-<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">if</span> st[ne] &gt; st[t] + <span class="number">1</span>:</span><br><span class="line">                    st[ne] = st[t] + <span class="number">1</span></span><br><span class="line">                    q.append(ne)</span><br><span class="line">                <span class="keyword">if</span> ne == n-<span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">return</span> st[ne]</span><br><span class="line"><span class="comment"># 整个优化流程 最关键的一步 每这一步就会超时</span></span><br><span class="line">                h[v] = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> st[n-<span class="number">1</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algo </category>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bfs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开发-安全可靠登录流程的实现</title>
      <link href="/2022/09/02/dev/%E5%BC%80%E5%8F%91-%E5%AE%89%E5%85%A8%E5%8F%AF%E9%9D%A0%E7%99%BB%E5%BD%95%E6%B5%81%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
      <url>/2022/09/02/dev/%E5%BC%80%E5%8F%91-%E5%AE%89%E5%85%A8%E5%8F%AF%E9%9D%A0%E7%99%BB%E5%BD%95%E6%B5%81%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>对于一个网站来说 用户登录为第一步 也是最关键的步骤之一  用户登录的过程中会提交自己的用户名以及密码与后台数据库进行核验 </p><p>然而随着现在网络的发展 网络安全问题也日益突出 保证用户登录过程中的信息安全至关重要</p><p>我在我的毕业设计关于这个问题 也思考了许多解决办法 现在将其总结于此</p><h2><span id="用户的登录流程">用户的登录流程</span></h2><p>首先我们分析仪一下用户最基本的登录流程及其可能存在的问题 及相应的解决方案 :</p><ol><li><p>1.用户进入登录页面输入自己的用户名和密码</p></li><li><p><font color="blue">这个过程可能存在的问题的是 恶意的密码尝试 比如有脚本恶意尝试密码 企图登录系统 </font></p></li><li><p><font color="red"> 解决这种问题的方法是采用验证码 同时将验证码存入redis中还可以设置过期时间进一步增强安全性</font></p></li><li><p>2前端获取用户输入将其传到后端 </p><ol><li><font color="blue"> 在前端向后端传递密码过程的过程 通常是将密码信息加在http post请求中发送给后端 而这个post请求是可以抓包 </font></li><li><font color="red">解决这种问题的方法是在将密码传输 如使用前端使用rsa算法用公钥加密后 再将加密后的密码传输至后端用私钥解密</font></li></ol></li><li><p>3后端调用相应service 进行校验 返回结果给前端</p></li><li><p>4网页存储用户的登录状态 从而用户可以自己的身份信息访问网页的相关内容</p><ol><li><font color="blue">存储这个登录信息的方式有很多种比如cookie 或者jwt 但这些存在一个问题 在一些极端场合 比如网吧之类的地方 如果用户不小离开网页过长时间 但网页仍然是登录状态 则很可能被不怀好意之人篡改用户的信息 甚至影响其财产安全</font></li><li><font color="red">解决这种问题的方法是将这种登录状态信息存储redis中  redis中有expire 即可以设置键值的自动失效时间 最经典的应用是redis结合jwt的使用</font></li></ol><p>   下面我会一一介绍这几种问题的解决方法 这些都是我毕业设计期间参考多方资料 不断探索的总结</p></li></ol><h2><span id="验证码功能的实现">验证码功能的实现</span></h2><p>获取验证码的基本流程:</p><!-- <img src="https://img1.imgtp.com/2022/09/01/3La5IPon.png" alt="1662040242634.png" style="zoom:60%;" /> --><img src="/2022/09/02/dev/%E5%BC%80%E5%8F%91-%E5%AE%89%E5%85%A8%E5%8F%AF%E9%9D%A0%E7%99%BB%E5%BD%95%E6%B5%81%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0/图1-获取验证码流程图.png" style="zoom:80%"><p>大体流程为:<br>首先当用户进入登录页面时，前端会自动向后端获取二维码，用户在填写完用户名与密码后还需要填写二维码，将所填写账号密码与二维码一起提交至后端进行验证，均验证通过后才能登录成功。</p><p>具体过程:</p><ol><li>加载用户登录页面时 Login.vue 中钩子函数调用getCode() 方法向后端发送请求 获取验证码:</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">created</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">// 获取验证码</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">getCode</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过getCode中调用getCodeImg 访问相应的接口从后端获取结果将图片的url(需要获取url因是因为二维码以图片的形式存储在后端以url的方式加载展示在页面上) 以及uuid</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="title function_">getCode</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="title function_">getCodeImg</span>().<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">codeUrl</span> = res.<span class="property">img</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">loginForm</span>.<span class="property">uuid</span> = res.<span class="property">uuid</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getCodeimg方法访问auth&#x2F;code 接口</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取二维码</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">getCodeImg</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">request</span>(&#123;</span><br><span class="line">        <span class="attr">url</span>: <span class="string">&#x27;auth/code&#x27;</span>,</span><br><span class="line">        <span class="attr">method</span>: <span class="string">&#x27;get&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>然后会通过api&#x2F;code进行验证码生成的相关操作，这过程中会生成验证码（包括uuid，img和结果值），uuid为唯一标识符，img为前端所需要展示的二维码的图片，结果为二维码所展示的图片的正确运算结果，并将其一并存入redis中，然后会将识别码、图片url返回给前端。</li></ol><p>让我们来看一下具体应该如何实现:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">   <span class="meta">@ApiOperation(&quot;获取验证码&quot;)</span></span><br><span class="line"><span class="comment">// AnonymousGetMapping 为spring sercuity后续会介绍spring sercuity的相关内容</span></span><br><span class="line"><span class="meta">@AnonymousGetMapping(value = &quot;/code&quot;)</span></span><br><span class="line">   <span class="keyword">public</span> ResponseEntity&lt;Object&gt; <span class="title function_">getCode</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="comment">// 获取运算的结果</span></span><br><span class="line">       <span class="type">Captcha</span> <span class="variable">captcha</span> <span class="operator">=</span> loginProperties.getCaptcha();</span><br><span class="line">       <span class="comment">// uuid唯一标识码</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">uuid</span> <span class="operator">=</span> properties.getCodeKey() + IdUtil.simpleUUID();</span><br><span class="line">       <span class="comment">//当验证码类型为 arithmetic时且长度 &gt;= 2 时，captcha.text()的结果有几率为浮点型</span></span><br><span class="line">       <span class="comment">// 根据生成二维码的text 获取二维码的值</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">captchaValue</span> <span class="operator">=</span> captcha.text();</span><br><span class="line">       <span class="comment">// 判断是否为小数如果是小数 则清除</span></span><br><span class="line">       <span class="keyword">if</span> (captcha.getCharType() - <span class="number">1</span> == LoginCodeEnum.ARITHMETIC.ordinal() &amp;&amp; captchaValue.contains(<span class="string">&quot;.&quot;</span>)) &#123;</span><br><span class="line">           captchaValue = captchaValue.split(<span class="string">&quot;\\.&quot;</span>)[<span class="number">0</span>];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 保存 到redis这里redisUtils为一个现成的轮子 想要实现可以直接去网上找一个</span></span><br><span class="line">       redisUtils.set(uuid, captchaValue, loginProperties.getLoginCode().getExpiration(), TimeUnit.MINUTES);</span><br><span class="line">       <span class="comment">// 验证码信息</span></span><br><span class="line">       Map&lt;String, Object&gt; imgResult = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Object&gt;(<span class="number">2</span>) &#123;&#123;</span><br><span class="line">           put(<span class="string">&quot;img&quot;</span>, captcha.toBase64());</span><br><span class="line">           put(<span class="string">&quot;uuid&quot;</span>, uuid);</span><br><span class="line">       &#125;&#125;;</span><br><span class="line">       <span class="keyword">return</span> ResponseEntity.ok(imgResult);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2><span id="rsa加密jwt完善用户登录流程">Rsa加密+JWT完善用户登录流程</span></h2><p>使用rsa加密和用户登录流程示意图:<br><img src="/2022/09/02/dev/%E5%BC%80%E5%8F%91-%E5%AE%89%E5%85%A8%E5%8F%AF%E9%9D%A0%E7%99%BB%E5%BD%95%E6%B5%81%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0/图2-用户登录鉴权流程图.png" style="zoom:70%;"></p><p>大体流程为:</p><p>当前端获取了二维码后系统则进入正式的登录流程。用户根据登录表单中填入用户名、密码、二维码，然后用户点击登录。登录按钮在前端中绑定一个handleLogin()方法，handleLogin()方法会调用encrypt方法使用预设的公钥对数据进行加密（只加密密码），然后会将加密后数据发送给后端，然后后端接口会使用decrypt方法并使用预设的私钥对数据进行解密。然后会从redis中获取二维码值（获取二维码正确的运算结果的值用于与用户所输入的值进行检验），然后一一进行校验判断用户密码以及二维码是否正确。若正确则会生成token并将用户信息返回给前端，否则发送错误状态信息。</p><p>具体过程:</p><h3><span id="rsa密码加密的实现">Rsa密码加密的实现</span></h3><p>注意这个密码加密是在前端加密 因为出问题的环节在前端用post请求发送的密码这个过程 也就是说这个发送的密码应该已经是加密后的密码了 然后再在后端解密</p><p>先在前端写好一个rsa的工具类 </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">JSEncrypt</span> <span class="keyword">from</span> <span class="string">&#x27;jsencrypt/bin/jsencrypt.min&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 密钥对生成 http://web.chacuo.net/netrsakeypair</span></span><br><span class="line"><span class="comment">// 这个密钥是可以自己通过网站随机生成的每个人都可以不一样 但一定要和公钥和私钥相匹配</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> publicKey = <span class="string">&#x27;MFwwDQYJKoZIhvcNAQEBBQADSwAwSAJBANL378k3RiZHWx5AfJqdH9xRNBmD9wGD\n&#x27;</span> +</span><br><span class="line">  <span class="string">&#x27;2iRe41HdTNF8RUhNnHit5NpMNtGL0NPTSSpPjjI1kJfVorRvaQerUgkCAwEAAQ==&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 加密</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">encrypt</span>(<span class="params">txt</span>) &#123;</span><br><span class="line">  <span class="comment">// 最关键的一步rsa加密 直接调库就好啦 </span></span><br><span class="line">  <span class="keyword">const</span> encryptor = <span class="keyword">new</span> <span class="title class_">JSEncrypt</span>()</span><br><span class="line">  encryptor.<span class="title function_">setPublicKey</span>(publicKey) <span class="comment">// 设置公钥</span></span><br><span class="line">  <span class="keyword">return</span> encryptor.<span class="title function_">encrypt</span>(txt) <span class="comment">// 对需要加密的数据进行加密</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后再在login.vue 中上传表单信息时 调用encrypt方法进行加密即可</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">handleLogin</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">$refs</span>.<span class="property">loginForm</span>.<span class="title function_">validate</span>(<span class="function"><span class="params">valid</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> user = &#123;</span><br><span class="line">          <span class="attr">username</span>: <span class="variable language_">this</span>.<span class="property">loginForm</span>.<span class="property">username</span>,</span><br><span class="line">          <span class="attr">password</span>: <span class="variable language_">this</span>.<span class="property">loginForm</span>.<span class="property">password</span>,</span><br><span class="line">          <span class="attr">rememberMe</span>: <span class="variable language_">this</span>.<span class="property">loginForm</span>.<span class="property">rememberMe</span>,</span><br><span class="line">          <span class="attr">code</span>: <span class="variable language_">this</span>.<span class="property">loginForm</span>.<span class="property">code</span>,</span><br><span class="line">          <span class="attr">uuid</span>: <span class="variable language_">this</span>.<span class="property">loginForm</span>.<span class="property">uuid</span></span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">        user.<span class="property">password</span> = <span class="title function_">encrypt</span>(user.<span class="property">password</span>)</span><br><span class="line">        </span><br><span class="line">          <span class="comment">/**</span></span><br><span class="line"><span class="comment">          handleLogin中还有很多操作 要实现这里只展现与密码相关的</span></span><br><span class="line"><span class="comment">          **/</span></span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样在用户输入用户名和和密码后 访问auth&#x2F;login接口进行鉴权<br><img src="/2022/09/02/dev/%E5%BC%80%E5%8F%91-%E5%AE%89%E5%85%A8%E5%8F%AF%E9%9D%A0%E7%99%BB%E5%BD%95%E6%B5%81%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0/图3-用户post请求信息图.png"><br>其post请求中所携带的用户名、用户密码等用户鉴权所需要的信息以及是加过后的了<br>以下为wireshark对用户post请求进行抓包的结果:<br><img src="/2022/09/02/dev/%E5%BC%80%E5%8F%91-%E5%AE%89%E5%85%A8%E5%8F%AF%E9%9D%A0%E7%99%BB%E5%BD%95%E6%B5%81%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0/图3-rsa加密后的抓包显示.jpg"><br>可以看到post请求中上传的密码信息已经是加密过的密码了</p><h3><span id="token生成">token生成</span></h3><p>如果用户输入的用户名、密码以及验证码均正确则鉴权成功 后端返回一个response<br>Response包含两个部分一个是用户相关信息 还有就是生成token<br>如下wireshark抓包结果:<br><img src="/2022/09/02/dev/%E5%BC%80%E5%8F%91-%E5%AE%89%E5%85%A8%E5%8F%AF%E9%9D%A0%E7%99%BB%E5%BD%95%E6%B5%81%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0/图4-浏览器端抓包的token信息图.png"><br><img src="/2022/09/02/dev/%E5%BC%80%E5%8F%91-%E5%AE%89%E5%85%A8%E5%8F%AF%E9%9D%A0%E7%99%BB%E5%BD%95%E6%B5%81%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0/图4-浏览器端抓包的token信息图.png"></p><h2><span id="jwt-鉴权的实现">JWT 鉴权的实现</span></h2><p>稍微先介绍一下token的验证流程:</p><ol><li>​后端签发一个token字符串给前端 </li><li>签发过程中使用密钥进行加密 </li><li>前端每次请求后端的数据必须在http请求中携带的这个token回回后端然后才能访问对应接口里面的数据<br>JWT与Token的区别在于验证客户端发来的token信息时不用查询数据库 而是在服务端直接使用密钥进行解密即可<br>​如下图可以看到，在用户登录系统后，使用google浏览器通过抓包的方式可以发现用户的cookie中均会包含一个JWT的token信息。<img src="/2022/09/02/dev/%E5%BC%80%E5%8F%91-%E5%AE%89%E5%85%A8%E5%8F%AF%E9%9D%A0%E7%99%BB%E5%BD%95%E6%B5%81%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0/图5-浏览器端抓包的token信息图.png"></li></ol><p>具体实现:<br>这里对JWT的使用要用 spring security 框架进行实现会比较方便</p><p>这里先简单说一下Spring Security的使用 虽然这个框架很复杂 但模板化还是比较强的:<br>大概是以下几个步骤<br>1.编写配置类 SecurityConfig<br>2.编写用户详情服务类 UserDetailsServiceImpl 返回认证主体</p><p><font color="blue">(关于这个 UserDetailsServiceImpl 关键是重写loadUserByUsername方法  你在这个方法中返回的是什么那么那么最终认证通过后生成的authentication中的principal 即主体部分就是什么)</font><br>3.编写用户信息类JwtUserDto 作为认证主体</p><p><font color="blue">(关于认证主体 都是实现UserDetails接口 只要实现UserDetails接口 那么SpringSecurity就会将这个类视为认证主体 并在认证链上进行传输)</font></p><p>4.根据前端传来的用户密码进行认证</p><p>Spring Security 认证原理是AOP实现 </p><p>Spring Security 有一个特性 只要你引入了Spring Security框架 那么所有你的所有接口都会被保护起来 都不支持匿名访问 一定要认证通过才能进行访问 </p><p>JwtUserDto:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shenghaoNi</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@descriptin</span> JwtUserDto 说明</span></span><br><span class="line"><span class="comment"> *  认证的主体</span></span><br><span class="line"><span class="comment"> *  实现 UserDetail这个接口 则SpringSecurity将其作为认证的主体</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JwtUserDto</span> <span class="keyword">implements</span> <span class="title class_">UserDetails</span> &#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 用户基本信息的Dto</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UserDto user;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * dataScopes 表示数据层级权限</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Long&gt; dataScopes;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * authorities 角色</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@JSONField(serialize = false)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;GrantedAuthority&gt; authorities;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将authorities通过java8的流转换成一个set</span></span><br><span class="line"><span class="comment">     * set里面有各种权限</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Set&lt;String&gt; <span class="title function_">getRoles</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> authorities.stream().map(GrantedAuthority::getAuthority).collect(Collectors.toSet());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@JSONField(serialize = false)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getPassword</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> user.getPassword();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@JSONField(serialize = false)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUsername</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> user.getUsername();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JSONField(serialize = false)</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAccountNonExpired</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JSONField(serialize = false)</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAccountNonLocked</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JSONField(serialize = false)</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isCredentialsNonExpired</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@JSONField(serialize = false)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEnabled</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> user.getEnabled();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后还需要TokenProvider签发token</p><p>TokenProvider</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TokenProvider</span> <span class="keyword">implements</span> <span class="title class_">InitializingBean</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SecurityProperties properties;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RedisUtils redisUtils;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">AUTHORITIES_KEY</span> <span class="operator">=</span> <span class="string">&quot;user&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> JwtParser jwtParser;</span><br><span class="line">    <span class="keyword">private</span> JwtBuilder jwtBuilder;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TokenProvider</span><span class="params">(SecurityProperties properties, RedisUtils redisUtils)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.properties = properties;</span><br><span class="line">        <span class="built_in">this</span>.redisUtils = redisUtils;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span>:shenghaoNi</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@description</span>:在bean创建后使用</span></span><br><span class="line"><span class="comment">     * JWS 签名后的JWT</span></span><br><span class="line"><span class="comment">     * 1.获取key:    即秘钥 在创建JWT时用于签名 此处用于解密验证</span></span><br><span class="line"><span class="comment">     * 2.验证密钥:    Jwts.parserBuilder</span></span><br><span class="line"><span class="comment">     *              在读取JWS 最重要的时指定用于验证JWS密码签名的密钥 如果签名验证失败则不能完全地新人JWT</span></span><br><span class="line"><span class="comment">     *              需丢弃该JWT</span></span><br><span class="line"><span class="comment">     * 3，解析JWT:   Jwts.builder()</span></span><br><span class="line"><span class="comment">     *              使用JJWT(Java JWT)创建JWS并且使用Java JWT进行解析</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">byte</span>[] keyBytes = Decoders.BASE64.decode(properties.getBase64Secret());</span><br><span class="line">        <span class="type">Key</span> <span class="variable">key</span> <span class="operator">=</span> Keys.hmacShaKeyFor(keyBytes);</span><br><span class="line">        <span class="comment">// 创建 JWS 即一个签名后的JWT</span></span><br><span class="line">        jwtParser = Jwts.parserBuilder()</span><br><span class="line">                .setSigningKey(key)</span><br><span class="line">                .build();</span><br><span class="line">        jwtBuilder = Jwts.builder()</span><br><span class="line">                .signWith(key, SignatureAlgorithm.HS512);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建Token 设置永不过期，</span></span><br><span class="line"><span class="comment">     * Token 的时间有效性转到Redis 维护</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> authentication /</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> /</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">createToken</span><span class="params">(Authentication authentication)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> jwtBuilder</span><br><span class="line">                <span class="comment">// 加入ID确保生成的 Token 都不一致</span></span><br><span class="line">                .setId(IdUtil.simpleUUID())</span><br><span class="line">                .claim(AUTHORITIES_KEY, authentication.getName())</span><br><span class="line">                .setSubject(authentication.getName())</span><br><span class="line">                .compact();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 依据Token 获取鉴权信息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> token /</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> /</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Authentication <span class="title function_">getAuthentication</span><span class="params">(String token)</span> &#123;</span><br><span class="line">        <span class="type">Claims</span> <span class="variable">claims</span> <span class="operator">=</span> getClaims(token);</span><br><span class="line">        <span class="type">User</span> <span class="variable">principal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(claims.getSubject(), <span class="string">&quot;******&quot;</span>, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@author</span>: shenghaoNi</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@description</span>: UsernamePasswordAuthenticationToken方法说明</span></span><br><span class="line"><span class="comment">         * public UsernamePasswordAuthenticationToken(Object principal, Object credentials, Collection&lt;? extends GrantedAuthority&gt; authorities)</span></span><br><span class="line"><span class="comment">         * 当在页面中输入用户名和密码后 UsernamePasswordAuthenticationToken验证</span></span><br><span class="line"><span class="comment">         * 然后生成Authentication会被交由AuthenticationManager进行管理</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UsernamePasswordAuthenticationToken</span>(principal, token, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Claims <span class="title function_">getClaims</span><span class="params">(String token)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> jwtParser</span><br><span class="line">                .parseClaimsJws(token)</span><br><span class="line">                .getBody();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> token 需要检查的token</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">checkRenewal</span><span class="params">(String token)</span> &#123;</span><br><span class="line">        <span class="comment">// 判断是否续期token,计算token的过期时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> redisUtils.getExpire(properties.getOnlineKey() + token) * <span class="number">1000</span>;</span><br><span class="line">        <span class="type">Date</span> <span class="variable">expireDate</span> <span class="operator">=</span> DateUtil.offset(<span class="keyword">new</span> <span class="title class_">Date</span>(), DateField.MILLISECOND, (<span class="type">int</span>) time);</span><br><span class="line">        <span class="comment">// 判断当前时间与过期时间的时间差</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">differ</span> <span class="operator">=</span> expireDate.getTime() - System.currentTimeMillis();</span><br><span class="line">        <span class="comment">// 如果在续期检查的范围内，则续期</span></span><br><span class="line">        <span class="keyword">if</span> (differ &lt;= properties.getDetect()) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">renew</span> <span class="operator">=</span> time + properties.getRenew();</span><br><span class="line">            redisUtils.expire(properties.getOnlineKey() + token, renew, TimeUnit.MILLISECONDS);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getToken</span><span class="params">(HttpServletRequest request)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">requestHeader</span> <span class="operator">=</span> request.getHeader(properties.getHeader());</span><br><span class="line">        <span class="keyword">if</span> (requestHeader != <span class="literal">null</span> &amp;&amp; requestHeader.startsWith(properties.getTokenStartWith())) &#123;</span><br><span class="line">            <span class="keyword">return</span> requestHeader.substring(<span class="number">7</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="登录鉴权代码">登录鉴权代码</span></h2><p>最后结合spring security框架 以及上述中所实现的方法吧 我们来看一下 完整的鉴权代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AnonymousPostMapping(value = &quot;/login&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ResponseEntity&lt;Object&gt; <span class="title function_">login</span><span class="params">(<span class="meta">@Validated</span> <span class="meta">@RequestBody</span> AuthUserDto authUser, HttpServletRequest request)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 密码解密</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> RsaUtils.decryptByPrivateKey(RsaProperties.privateKey, authUser.getPassword());</span><br><span class="line">    <span class="comment">// 查询验证码 从redis中取出验证码</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> (String) redisUtils.get(authUser.getUuid());</span><br><span class="line">    <span class="comment">// 清除验证码 用过一次后就要清除</span></span><br><span class="line">    redisUtils.del(authUser.getUuid());</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isBlank(code)) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;验证码不存在或已过期&quot;</span>);</span><br><span class="line">        Map&lt;String, Object&gt; errorData = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">2</span>);</span><br><span class="line">        errorData.put(<span class="string">&quot;message&quot;</span>, <span class="string">&quot;验证码不存在或已过期&quot;</span>);</span><br><span class="line">        errorData.put(<span class="string">&quot;status&quot;</span>, <span class="number">400</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ResponseEntity</span>&lt;&gt;(errorData, HttpStatus.BAD_REQUEST);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// authUser 从前端传入 比较前端对象所传入的验证码 与 真实验证码值是否匹配</span></span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isBlank(authUser.getCode()) || !authUser.getCode().equalsIgnoreCase(code)) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;验证码错误&quot;</span>);</span><br><span class="line">        Map&lt;String, Object&gt; errorData = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">2</span>);</span><br><span class="line">        errorData.put(<span class="string">&quot;message&quot;</span>, <span class="string">&quot;验证码错误&quot;</span>);</span><br><span class="line">        errorData.put(<span class="string">&quot;status&quot;</span>, <span class="number">400</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ResponseEntity</span>&lt;&gt;(errorData, HttpStatus.BAD_REQUEST);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 认证授权</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1.根据前端传来的用户名和密码创造一个UsernamePasswordAuthenticationToken实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">UsernamePasswordAuthenticationToken</span> <span class="variable">authenticationToken</span> <span class="operator">=</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">UsernamePasswordAuthenticationToken</span>(authUser.getUsername(), password);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 2.认证UsernamePasswordAuthenticationToken实例</span></span><br><span class="line"><span class="comment">     * 认证成功则返回</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">Authentication</span> <span class="variable">authentication</span> <span class="operator">=</span> authenticationManagerBuilder.getObject().authenticate(authenticationToken);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 3.设置当前登录用户</span></span><br><span class="line"><span class="comment">     * 这一步是为了可以让其他类或方法通过SecurityContextHolder.getContext().getAuthentication()拿到当前登录的用户</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    SecurityContextHolder.getContext().setAuthentication(authentication);</span><br><span class="line">    <span class="comment">// 生成令牌与第三方系统获取令牌方式</span></span><br><span class="line">    <span class="comment">// UserDetails userDetails = userDetailsService.loadUserByUsername(userInfo.getUsername());</span></span><br><span class="line">    <span class="comment">// Authentication authentication = new UsernamePasswordAuthenticationToken(userDetails, null, userDetails.getAuthorities());</span></span><br><span class="line">    <span class="comment">// SecurityContextHolder.getContext().setAuthentication(authentication);</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> tokenProvider.createToken(authentication);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 4. 通过已经认证的Authentication返回UserDetails</span></span><br><span class="line"><span class="comment">     * 生成用户认证信息</span></span><br><span class="line"><span class="comment">     * 使用Jwt规范的token</span></span><br><span class="line"><span class="comment">     * JWT token只有一份 会生成一个令牌</span></span><br><span class="line"><span class="comment">     * 服务端不需要存储token</span></span><br><span class="line"><span class="comment">     * getPrincipal 为一个主体 即数据传输对象 可获取登录用户</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">JwtUserDto</span> <span class="variable">jwtUserDto</span> <span class="operator">=</span> (JwtUserDto) authentication.getPrincipal();</span><br><span class="line">    <span class="comment">// 保存在线信息</span></span><br><span class="line">    onlineUserService.save(jwtUserDto, token, request);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 走到这里就代表验证码校验通过了</span></span><br><span class="line"><span class="comment">     * 返回 token 与 用户信息 从而让前端可以拿到用户信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Map&lt;String, Object&gt; authInfo = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Object&gt;(<span class="number">2</span>) &#123;&#123;</span><br><span class="line">        put(<span class="string">&quot;token&quot;</span>, properties.getTokenStartWith() + token);</span><br><span class="line">        put(<span class="string">&quot;user&quot;</span>, jwtUserDto);</span><br><span class="line">    &#125;&#125;;</span><br><span class="line">    <span class="keyword">if</span> (loginProperties.isSingleLogin()) &#123;</span><br><span class="line">        <span class="comment">//踢掉之前已经登录的token</span></span><br><span class="line">        onlineUserService.checkLoginOnUser(authUser.getUsername(), token);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ResponseEntity.ok(authInfo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> dev </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端开发 </tag>
            
            <tag> 前端开发 </tag>
            
            <tag> 网络安全 </tag>
            
            <tag> Rsa的应用 </tag>
            
            <tag> SpringSecurity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode1346检查整数及其两倍数是否存在-一题多解</title>
      <link href="/2022/08/30/leetcode/leetcode1346%E6%A3%80%E6%9F%A5%E6%95%B4%E6%95%B0%E5%8F%8A%E5%85%B6%E4%B8%A4%E5%80%8D%E6%95%B0%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8-%E4%B8%80%E9%A2%98%E5%A4%9A%E8%A7%A3/"/>
      <url>/2022/08/30/leetcode/leetcode1346%E6%A3%80%E6%9F%A5%E6%95%B4%E6%95%B0%E5%8F%8A%E5%85%B6%E4%B8%A4%E5%80%8D%E6%95%B0%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8-%E4%B8%80%E9%A2%98%E5%A4%9A%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>个人认为很好的一道面试题<br>虽然题目简单但如果直接暴搜的话应该就直接回家等通知了<br>有好几种做法面试的时候都可以说一下</p><h2><span id="法1-二分">法1: 二分</span></h2><p>排序后 遍历数组 二分查找是否存在二倍的值<br>复杂度:<br>排序 nlogn  二分 n * logn<br>O(nlogn)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"><span class="keyword">from</span> bisect <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">checkIfExist</span>(<span class="params">self, arr: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        arr.sort()</span><br><span class="line">        n = <span class="built_in">len</span>(arr)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            v = arr[i]</span><br><span class="line">            index = bisect_left(arr,<span class="number">2</span>*v)</span><br><span class="line">            <span class="keyword">if</span> index &gt;= n <span class="keyword">or</span> index == i:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> <span class="number">2</span>*v == arr[index]:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h2><span id="法2-哈希">法2: 哈希</span></h2><p>遍历一遍将所有值都加到hash中<br>再遍历一遍 同时在hash中寻找结果<br>复杂度: 可做到近乎O(n)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def checkIfExist(self, arr: List[int]) -&gt; bool:</span><br><span class="line">        s = set()</span><br><span class="line">        # 判断0的个数 防止只有一个0的情况出现</span><br><span class="line">        zeroCount = 0</span><br><span class="line">        for v in arr:</span><br><span class="line">            if not v:</span><br><span class="line">                zeroCount = zeroCount + 1</span><br><span class="line">            s.add(v)</span><br><span class="line"></span><br><span class="line">        for v in arr:</span><br><span class="line">            # 特判0 的情况</span><br><span class="line">            if not v:</span><br><span class="line">                if zeroCount &gt; 1:</span><br><span class="line">                    return True</span><br><span class="line">            elif 2*v in s:</span><br><span class="line">                return True</span><br><span class="line">        return False</span><br></pre></td></tr></table></figure><h2><span id="法3-排序-双指针">法3 排序 双指针</span></h2><p>这个做法的核心在于单调性的应用<br>以x&gt;0 为例:<br>对于排序后的数组<br>arr[i] * 2 &gt; arr[p]<br>p &#x3D; p + 1<br>即 i-p 之间均是小于arr[i] * 2 的数 因为数组本身单调增的 所以如果 i继续向右至j 那么原本 i-p 之间的数必然小于 arr[j] * 2 即p 只需遍历一次即可</p><p>复杂度:<br>排序 nlogn 遍历 2 * n<br>总的复杂度 O(nlogn)<br>不过这种方法相对来说还是复杂了一些 而且判断需要注意的细节也比较多 还是不建议写 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">checkIfExist</span>(<span class="params">self, arr: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(arr)</span><br><span class="line">        arr.sort()</span><br><span class="line">        p = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 判断x 大于0的情况 </span></span><br><span class="line">        <span class="comment"># 对于排序后的数 arr[i]*2 &gt; arr[p]  p = p + 1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">while</span> p &lt; n <span class="keyword">and</span> arr[i] * <span class="number">2</span> &gt; arr[p]:</span><br><span class="line">                p = p + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> p &lt; n <span class="keyword">and</span> p!=i <span class="keyword">and</span> arr[i] * <span class="number">2</span> == arr[p]:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line">        p = n - <span class="number">1</span></span><br><span class="line">        <span class="comment"># 判断小于0的情况</span></span><br><span class="line">        <span class="comment"># 对于排序后的数 arr[i]*2 &lt; arr[p]  p = p -1</span></span><br><span class="line">        <span class="comment"># 否则无法达成两倍这个条件 因为你负的数越往左才是越小其绝对值才是越大 </span></span><br><span class="line">        <span class="comment"># 同时i 逆着遍历 才能满足单调性一致 即p 不需要回溯</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">while</span> p &gt; -<span class="number">1</span> <span class="keyword">and</span> arr[i]*<span class="number">2</span> &lt; arr[p]:</span><br><span class="line">                p = p -<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> p &gt; -<span class="number">1</span> <span class="keyword">and</span> p!=i <span class="keyword">and</span> arr[i] * <span class="number">2</span> == arr[p]:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algo </category>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分 </tag>
            
            <tag> 双指针 </tag>
            
            <tag> 哈希 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode6163给定条件下构造矩阵-拓扑排序</title>
      <link href="/2022/08/28/leetcode/leetcode6163%E7%BB%99%E5%AE%9A%E6%9D%A1%E4%BB%B6%E4%B8%8B%E6%9E%84%E9%80%A0%E7%9F%A9%E9%98%B5-%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"/>
      <url>/2022/08/28/leetcode/leetcode6163%E7%BB%99%E5%AE%9A%E6%9D%A1%E4%BB%B6%E4%B8%8B%E6%9E%84%E9%80%A0%E7%9F%A9%E9%98%B5-%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>拓扑排序 代码实现思路:<br>            1. 入队所有入度为0 的点<br>            2. bfs 取出队头t 枚举t的所有出边 t-&gt;j<br>            3. 删掉 t-&gt;j  即让 d[j]– (d[j] j的入度)<br>            4. if d[j] &#x3D;&#x3D; 0  -&gt; 说明j之前所有点均以排好序 -&gt; j 入队<br>            5. 如果图中存在环则无法全部入队 反之则都可以入队</p><p>先看一个基础点的题<br>leetcode 210 原题链接:<br><a href="https://leetcode.cn/problems/course-schedule-ii/">https://leetcode.cn/problems/course-schedule-ii/</a><br>算是一道经典题</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findOrder</span>(<span class="params">self, numCourses: <span class="built_in">int</span>, prerequisites: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        n = numCourses</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">topSort</span>(<span class="params">edges</span>):</span><br><span class="line">            <span class="comment"># 建图</span></span><br><span class="line">            g = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">            <span class="comment"># 存入度</span></span><br><span class="line">            d = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">            <span class="keyword">for</span> x, y <span class="keyword">in</span> edges:</span><br><span class="line">                g[y].append(x)</span><br><span class="line">                d[x] = d[x] + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            q = deque([i <span class="keyword">for</span> i, v <span class="keyword">in</span> <span class="built_in">enumerate</span>(d) <span class="keyword">if</span> v == <span class="number">0</span>])</span><br><span class="line">            <span class="comment"># 拓扑序</span></span><br><span class="line">            order = []</span><br><span class="line">            <span class="keyword">while</span> q:</span><br><span class="line">                x = q.popleft()</span><br><span class="line">                order.append(x)</span><br><span class="line">                <span class="keyword">for</span> y <span class="keyword">in</span> g[x]:                </span><br><span class="line">                    d[y] = d[y] - <span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> d[y] == <span class="number">0</span> :</span><br><span class="line">                        q.append(y)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> order <span class="keyword">if</span> <span class="built_in">len</span>(order) == n <span class="keyword">else</span> []</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> topSort(prerequisites)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后再看6163这道题<br>题目链接:<br><a href="https://leetcode.cn/problems/build-a-matrix-with-conditions/">https://leetcode.cn/problems/build-a-matrix-with-conditions/</a><br>主要变形在最后填入矩阵那里 以及给的输入并不是从0开始需要稍作处理</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">buildMatrix</span>(<span class="params">self, k: <span class="built_in">int</span>, rowConditions: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], colConditions: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">topSort</span>(<span class="params">edges</span>):</span><br><span class="line">            <span class="comment"># 题目给的是 1-k 所以对应范围是 1-k+1</span></span><br><span class="line">            <span class="comment"># 链表 存图</span></span><br><span class="line">            g = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(k + <span class="number">1</span>)]</span><br><span class="line">            <span class="comment"># 存入度</span></span><br><span class="line">            d = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k + <span class="number">1</span>)]</span><br><span class="line">            <span class="keyword">for</span> x, y <span class="keyword">in</span> edges:</span><br><span class="line">                g[x].append(y)</span><br><span class="line">                d[y] = d[y] + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            q = deque()</span><br><span class="line">            <span class="comment"># 根据题意 不存在0这个位置</span></span><br><span class="line">            d[<span class="number">0</span>] = -<span class="number">1</span></span><br><span class="line">            <span class="comment"># 将入度为0的先入队</span></span><br><span class="line">            <span class="keyword">for</span> i, v <span class="keyword">in</span> <span class="built_in">enumerate</span>(d):</span><br><span class="line">                <span class="keyword">if</span> v == <span class="number">0</span>:</span><br><span class="line">                    q.append(i)</span><br><span class="line"></span><br><span class="line">            order = []</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> q:</span><br><span class="line">                t = q.popleft()</span><br><span class="line">                order.append(t)</span><br><span class="line">                <span class="keyword">for</span> y <span class="keyword">in</span> g[t]:</span><br><span class="line">                    d[y] = d[y] - <span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> d[y] == <span class="number">0</span>:</span><br><span class="line">                        q.append(y)</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(order) &lt; k:</span><br><span class="line">                <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">list</span>(order)</span><br><span class="line"></span><br><span class="line">        row = topSort(rowConditions)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> row:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        col = topSort(colConditions)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> col:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 建立 列与其出现顺序的映射</span></span><br><span class="line">        pos = &#123;x: i <span class="keyword">for</span> i, x <span class="keyword">in</span> <span class="built_in">enumerate</span>(col)&#125;</span><br><span class="line"></span><br><span class="line">        ans = [[<span class="number">0</span>] * k <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(k)]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 按这个顺序遍历 x 一定是符合行的条件的 </span></span><br><span class="line">        <span class="comment"># 然后通过pos[x] 找到对应列符合条件的位置 填入值即可完成构造</span></span><br><span class="line">        <span class="keyword">for</span> i, x <span class="keyword">in</span> <span class="built_in">enumerate</span>(row):</span><br><span class="line">            ans[i][pos[x]] = x</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algo </category>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 拓扑排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初出茅庐-我的第一次实习经历</title>
      <link href="/2022/08/28/life/%E5%88%9D%E5%87%BA%E8%8C%85%E5%BA%90-%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%AE%9E%E4%B9%A0%E7%BB%8F%E5%8E%86/"/>
      <url>/2022/08/28/life/%E5%88%9D%E5%87%BA%E8%8C%85%E5%BA%90-%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%AE%9E%E4%B9%A0%E7%BB%8F%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1><span id="20222-20224-天翼阅读文化">2022.2 - 2022.4 天翼阅读文化</span></h1><p>动笔时已经是已经快要开学 而我也将马上进入下一个阶段 研究生的学习了 也是时候为之前的实习做一个记录与总结</p><hr><p>拿到offer的过程比较意外 但也比较幸运 记录于 <a href="/2022/11/13/interview-%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%952022-2%E5%A4%A9%E7%BF%BC%E9%98%85%E8%AF%BB%E6%96%87%E5%8C%96/" title="面试记录2022-2天翼阅读文化">面试记录2022-2天翼阅读文化</a><br>公司是在武林广场 杭州市中心的位置 当时三号线还没开 只能靠193 最开始采取的策略是 一开始想到解决办法是 周一早上193路到公司 然后工作日住旁边宾馆的 然后最后一个工作日晚上回学校 住宾馆虽然比较舒服也确实很方便 但感觉花销还是太大了 而且也和一个一直有联系高中同学交流 刚好他也在实习在九堡那里租了一间房子或者说鸽笼比较合适一些 然后就搬到他那边 这在九堡生活的这段经历也算是迷茫与辛苦交织中却也带着一些快乐 毕竟能有一个分享生活的人在一起感觉就会好很多</p><hr><p>住的地方离地铁口大概15分钟左右的路 但是从九堡到武林广场算上出入站的等车的时间大概要花上个40分钟左右甚至更多 我是9.30–5.30当然这是在没有特殊情况不需要加班处理的情况下 看上去8小时工作制蛮不错 但算上上下班的时间 还有早晚饭 以及洗漱的时间 我基本每天早上要7.40左右起来才能比较稳的到公司 早上基本是在公司楼下的十足买个餐包到工位上解决 晚上回到住处也快7点了<br>感觉还是有些辛苦的 虽说在学校准备考研的时候可以从早8 学到 晚10 但在图书馆坐着 和在公司上班的感觉还是不太一样 公司的工位是那种长方形的桌子 坐我对面的就是我的技术总监 主管在我对面靠右大概两三个位置的样子 我这个桌子围着坐都是做后端的人 我背后是做前端的<br>从好的方面讲是有利于交流 我经常看到技术人员跑到我对面和技术总监交流 技术总监也经常跑来跑去 有点电影里华尔街之狼的那种感觉 在此之前我是没想到程序这份工作可以干的这么热闹 不好的就是全程有一种紧绷着的感觉 处理完事后 也不好意思趴下休息啥的 每天都会要求写一份日报(今天做了什么 今日收获 明日计划) 一周还要写一份周报 但好在技术总监这些人都比较温和也比较包容 </p><hr><p>我加入的时候 整个项目正好处于一个新旧交替的阶段 一进来一看代码发现是spring cloud 的项目 当时还是有些吃惊的 毕竟我还是个只玩过springboot的小菜鸡(当然后来知道主要还是用了nacos\gatewayy的一些功能 并没有使用阿里巴巴的那整套架构) 所以每天基本上是在工位上看着源码 然后学习微服务的框架<br>印象最深刻 应该也是整个项目最复杂的一个部分就是那个交换区的设计 用户先在本地将文件上传 然后上传到一个缓冲区 然后本部门负责人审核完毕后 再将其上传到下一个缓冲区由下一个部门的人再审核通过 用了定时任务让机器去读取文件 为了都快一些还是用了多线程 然后用于k8s 所以还需要用redis给定时任务上锁与上传机器想绑定 非常复杂 但也让我对分布式 对象存储产生了兴趣<br>顺带着学了 fastdfs minio这些对象存储 好在当时交给我的主要是一些crud比较基本代码 空余时间比较 算是带薪学习了<br>后来开始数据库上云以及去O 就是不用oracle存储 而改用其他数据库 比如postgresql 好像是为了防止掐脖子的 因为我们这里是做一个政府那边的项目 所以防止这些意外 而我被分配去了做postgresql 与 oralce的适配性的调研任务 刚接到这个任务的时候真的无从下手 后来打算在自己的机子把项目跑起来后 一点点测试改用postgresql后项目模块是否可以正常运行 结果后来和运维交流 才发现我们这个项目还用了k8s 于是又只能去学习k8s 当然到最后这个问题还是由组内的其他成员解决 但对我来说也算一个很好的契机吧 接触了很多新的知识 迈出了新的一步 以前觉得微服务这些东西都太高大上了 就没去接触 但真正去学了后 发现还是可以的 还根据项目的架构画了几张架构图给我的主管看 </p><hr><p>而后 我调剂上岸了 由于要准备毕设答辩 再加上当时杭州疫情管控比较严重 而且我朋友的实习期要到了 也打算退租 于是就停止了为期一个多月的实习<br>总的来说这次实习给我带来最大意义就是迈出了全新的一步 接触很多新的技术 也体验了一次当社畜的感觉 尤其早上乘地铁的时候 全车厢都挤满人 但没有一点声音 所有人都看着手机的那种感觉还是感觉比较压抑的 也有些打消了我之前想要大不了就直接打工的念头<br>当然这对我来说也是一段较为艰苦的时间 白天上完班后 回到房里 还是要准备复试的内容(虽然有些低落 但还是有些不甘心) 然后晚上还拉着朋友准备我的英语自我介绍和英语问答 这里还是非常感激他 最后走的那晚我们去地铁站的商场里吃了顿好的 然后回来还点了份水果<br>虽然有些艰辛 但这也让我第一次觉得可能房子也不是越大 越精致越好 真的够用就行 能够休息能够维持 能进行正常生活就行 对于我而言可能就是一个卧室一个独卫吧 当然幸运的是我们这个鸽笼还有个厨房 不过我们两个回到房间后基本都没有任何做饭的欲望 比较浪漫的是头顶上的墙壁贴着星星的贴纸 晚上关灯后 会有夜光效果 算是这个屋子前主人的一些梦想与追求 整个社区是属于都是一排排的这种鸽笼 堪称打工人聚集地 虽然夜晚光线不是很好 但是比较热闹 小卖部 菜鸟驿站基本都有 周边也都是各种 餐馆 打印店 什么的<br>也许今后我工作还会在这样的地方呆上一段时间 但现在还是先继续向前</p>]]></content>
      
      
      <categories>
          
          <category> life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活随笔 </tag>
            
            <tag> 实习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python语法在竞赛中的巧妙应用</title>
      <link href="/2022/08/26/py-python%E8%AF%AD%E6%B3%95%E5%9C%A8%E7%AB%9E%E8%B5%9B%E4%B8%AD%E7%9A%84%E5%B7%A7%E5%A6%99%E5%BA%94%E7%94%A8/"/>
      <url>/2022/08/26/py-python%E8%AF%AD%E6%B3%95%E5%9C%A8%E7%AB%9E%E8%B5%9B%E4%B8%AD%E7%9A%84%E5%B7%A7%E5%A6%99%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1><span id="python-的语法笔记">python 的语法笔记</span></h1><h2><span id="使用python-实现字典与列表的嵌套">使用python 实现字典与列表的嵌套</span></h2><p>类似于C++中 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;h1;</span><br><span class="line">unordered_map&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;&gt;h2;</span><br></pre></td></tr></table></figure><p>python 虽然不能像C++ 这样实现无限套娃 也基本足够 即可可实现 int:list 即一个整数 或 字符&#x2F;字符串 对应的列表 在建图的时候 会非常方便 但在构造题中还是直接上C++ 的 unordered_map 会舒服一些</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">这个是需要引入的 如果是写一些oj 或者 kickstart 就要注意一下</span></span><br><span class="line"><span class="string">但在leetcode中 整个collections 集合都是 自动帮我们引入好的直接 而且还是这种 from import的形式 所以直接用defaultdict就OK了</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line">h = defaultdict(<span class="built_in">list</span>)</span><br><span class="line">h[<span class="number">0</span>].append(<span class="number">0</span>)</span><br><span class="line">h[<span class="number">1</span>].append(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h2><span id="python-可能是默认为-set-也可能是-dict">python {} 可能是默认为 set 也可能是 dict</span></h2><p>python {} 可能是默认为 set 也可能是 dict 写的时候一定要明确明set 还是dict 尽量不要直接用这种形式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 不要使用</span></span><br><span class="line">t = &#123;&#125;</span><br><span class="line"><span class="comment"># 尽量以下 几种方式初始化</span></span><br><span class="line">s = <span class="built_in">set</span>()</span><br><span class="line">d = <span class="built_in">dict</span>()</span><br></pre></td></tr></table></figure><h2><span id="python的遍历">python的遍历</span></h2><p>python的 遍历 没有C++ 那么自由 但却提供了很多接口 方便了很多</p><h3><span id="enumerate-同时获取下标和值">enumerate 同时获取下标和值</span></h3><p>使用 enumerate 可以同时获取下标和值 否则要用range迭代的方式获取 比较繁琐</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">q = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">遍历enumerate时</span></span><br><span class="line"><span class="string">第一个参数为 下标  第二个参数为 值</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> index,val <span class="keyword">in</span> <span class="built_in">enumerate</span>(q):</span><br><span class="line">    <span class="built_in">print</span>(index,val)</span><br></pre></td></tr></table></figure><h3><span id="zip-同时遍历多个集合">zip 同时遍历多个集合</span></h3><p>zip 相当于把多个集合打包 然后相对的去遍历即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">b = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="keyword">for</span> i,j <span class="keyword">in</span> <span class="built_in">zip</span>(a,b):</span><br><span class="line">    <span class="built_in">print</span>(i,j)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>还可以将 zip 和 enumerate 套娃使用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">b = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i,v),(j,w) <span class="keyword">in</span> <span class="built_in">zip</span>(<span class="built_in">enumerate</span>(a),<span class="built_in">enumerate</span>(b)):</span><br><span class="line">    <span class="built_in">print</span>(i,v,<span class="string">&quot; &quot;</span>,j,w)</span><br></pre></td></tr></table></figure><h2><span id="python-切片">python 切片</span></h2><p>python切片  q[l:r] 这个范围range是一样的 右边取不到的 所以要取 l:r 范围的数 那实际上应该是 q[l:r+1]<br>可以玩的操作很多 比如直接 用sum就可以获取这一段区间的值<br>通常会用作滑动窗口 这样就不用写双指针了 代码正确率大大提升</p><h3><span id="切片旋转">切片旋转</span></h3><p>这个非常使用 再有些题目中 甚至如果逆序的时候不想写reverse 也可以全局切片翻转</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 两元素交换 如果a,b挨着那用切片也可以做</span><br><span class="line">q[a],q[b] = q[b],q[a]</span><br><span class="line"></span><br><span class="line"># 整段元素翻转</span><br><span class="line"># 翻转 a,b 区间的元素</span><br><span class="line">q[a:b+1][::-1]</span><br></pre></td></tr></table></figure><h2><span id="python-的输入输出">python 的输入输出</span></h2><p>在一些oj题中会用到 会以后kickstart做准备<br>没有 C++ 那么 自由 但比java 要好很多</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&quot;&quot;&quot;</span><br><span class="line">输入样例:</span><br><span class="line">2</span><br><span class="line">5 5</span><br><span class="line">...**</span><br><span class="line">*.**.</span><br><span class="line">.....</span><br><span class="line">.....</span><br><span class="line">*....</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">T = int(input())</span><br><span class="line">m,n = map(int,input().split())</span><br><span class="line">print(T,m,n)</span><br><span class="line">g = [[&quot;&quot; for i in range(n)] for j in range(m)]</span><br><span class="line">for i in range(n):</span><br><span class="line">    g[i] = input()</span><br><span class="line">    print(g[i])</span><br></pre></td></tr></table></figure><p>主要需要注意的是 字符间有字符隔开的情况 需要用到map 去做一个对应 另外 二维字符数组的初始化通常也要这样写会比较好<br>总之python 的输入 都是按行 任何对字符的操作按行进行分割对应即可</p><h2><span id="字典的遍历和初始化">字典的遍历和初始化</span></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter, defaultdict</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">想要实现和C++ unordered_map 那样自动插入的效果就一定要用defaultdict()</span></span><br><span class="line"><span class="string">其他如list deque 也建议都用default 这个函数 (collections中基本可以视为基本库 只管用就完事了)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">d = defaultdict(<span class="built_in">int</span>)</span><br><span class="line">d[<span class="number">1</span>]=<span class="number">8</span></span><br><span class="line">d[<span class="number">3</span>] = <span class="number">2</span></span><br><span class="line">d[<span class="number">2</span>] = <span class="number">7</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历每一个键值对</span></span><br><span class="line"><span class="comment"># 这里要注意 python的遍历顺序只会按照你的添加顺序遍历 而并非键值顺序</span></span><br><span class="line"><span class="keyword">for</span> (i,j) <span class="keyword">in</span> d.items():</span><br><span class="line">    <span class="built_in">print</span>(i,j)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历 key</span></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> d.keys():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;k = &#123;&#125;&quot;</span>.<span class="built_in">format</span>(k))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历value</span></span><br><span class="line"><span class="keyword">for</span> v <span class="keyword">in</span> d.values():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;v = &#123;&#125;&quot;</span>.<span class="built_in">format</span>(v))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按键值顺序遍历</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">如果直接sorted(d) 或者 直接 for i in d 那么默认操作和排序的都是键值 这个和C++ 很不一样的</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 排序键值对</span></span><br><span class="line">di = <span class="built_in">sorted</span>(d.items())</span><br><span class="line"><span class="comment"># 排序键值</span></span><br><span class="line">dk = <span class="built_in">sorted</span>(d.keys())</span><br><span class="line"><span class="comment"># 排序值</span></span><br><span class="line">dv = <span class="built_in">sorted</span>(d.values())</span><br></pre></td></tr></table></figure><h2><span id="python-字典自定义排序">python 字典自定义排序</span></h2><p>通过这种自定义排序方法 基本就可以弥补python 没有红黑树的遗憾了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"></span><br><span class="line">d = defaultdict(<span class="built_in">int</span>)</span><br><span class="line">d[<span class="number">0</span>] = <span class="number">3</span></span><br><span class="line">d[<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line">d[<span class="number">2</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 按照 value 的值对字典进行排序 返回是元素为元组的列表</span></span><br><span class="line"><span class="comment"># 这里注意想要对字典整体进行排序 就直接排items() 就可以了 这里定义排序规则时 把items() 理解为一个有二维的list即可</span></span><br><span class="line">ds = <span class="built_in">sorted</span>(d.items(), key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(ds)</span><br></pre></td></tr></table></figure><h2><span id="python-二分库">python 二分库</span></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bisect <span class="keyword">import</span> bisect_left, bisect_right</span><br><span class="line"></span><br><span class="line">a = [<span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">9</span>]</span><br><span class="line">x = <span class="number">3</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">一下讨论均基于 数组a 有序的前提下</span></span><br><span class="line"><span class="string">当要查找的数x 在数组a中不存在相同的多个 两者是没有区别的 </span></span><br><span class="line"><span class="string">都会返回使得插入元素到数组a 后 使得数组有序的 那个下标索引</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="built_in">print</span>(bisect_left(a, x), bisect_right(a, x))</span><br><span class="line"></span><br><span class="line">x = <span class="number">5</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">当要查找的数存在相同多个时 </span></span><br><span class="line"><span class="string">bisect_left 返回相同数 下标中最靠左的那个 </span></span><br><span class="line"><span class="string">bisect_left 返回相同数 下标中最靠右的那个</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="built_in">print</span>(bisect_left(a, x), bisect_right(a, x))</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> dev </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 算法模板 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode172阶乘后的零-分解质因子</title>
      <link href="/2022/08/25/leetcode/leetcode172%E9%98%B6%E4%B9%98%E5%90%8E%E7%9A%84%E9%9B%B6-%E5%88%86%E8%A7%A3%E8%B4%A8%E5%9B%A0%E5%AD%90/"/>
      <url>/2022/08/25/leetcode/leetcode172%E9%98%B6%E4%B9%98%E5%90%8E%E7%9A%84%E9%9B%B6-%E5%88%86%E8%A7%A3%E8%B4%A8%E5%9B%A0%E5%AD%90/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>原题链接:<br><a href="https://leetcode.cn/problems/factorial-trailing-zeroes/">https://leetcode.cn/problems/factorial-trailing-zeroes/</a></p><p>想要一个数的结尾多加一个0 最直观的想法就是 * 10<br>    而10 又可以拆解为 2 * 5 也就是说每多一对 2 * 5 就会多一个10 就会多一个0<br>    所以题目转化求 每一个数中的2和5 的数量 有多少对2 5 则结果在就会尾随多少个0<br>进一步优化-&gt;<br>    由于题目求的是0-n的中数的5 那么有5 就一定会有2 也就是说 只要算出5的个数即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">trailingZeroes</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>,n + <span class="number">1</span>,<span class="number">5</span>):</span><br><span class="line">            <span class="keyword">while</span> i % <span class="number">5</span> == <span class="number">0</span>:</span><br><span class="line">                i//=<span class="number">5</span></span><br><span class="line">                ans = ans + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>进一步优化-&gt;<br>    由于0-n中 可能存在前面的数是后面的数的因子 即可能运算出多个重复的5<br>    可以每次直接除5 便可得到当前因子包含5的数量 而这部分5 同样已经在之前被重复运算过了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">trailingZeroes</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> n:</span><br><span class="line">            ans+= n//<span class="number">5</span></span><br><span class="line">            n//=<span class="number">5</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algo </category>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 推导题(算法) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode2376数位dp</title>
      <link href="/2022/08/18/leetcode/leetcode2376%E6%95%B0%E4%BD%8Ddp/"/>
      <url>/2022/08/18/leetcode/leetcode2376%E6%95%B0%E4%BD%8Ddp/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>原题链接:<br><a href="https://leetcode.cn/problems/count-special-integers/">https://leetcode.cn/problems/count-special-integers/</a></p><p>数位dp 虽然只要是枚举的过程  但需要考虑的情况比较多 且融合非常多的知识点 非常细致<br>主要需要注意以下几个点：</p><ol><li>枚举过的数 不能再枚举 可以用一个vis数组 但为了方便可以用二进制的方法 采用一个mask 进行解决</li><li>每个位置枚举的数 会受到前一个位置的限制 <ol><li>比如说 n&#x3D;123 那么如果 当前已经枚举的情况位 12_  那么最后一位只能枚举1 2  3 否则就会超过123 那么生成的数 就不符合答案标准了</li></ol></li><li>如果前一个数位为0 那么当前位置枚举数可能会存在重复<ol start="2"><li>比如说 9 09 009 则三个数都会出现重复 需要这种特殊情况进行判读那</li></ol></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">countSpecialNumbers</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 先将这个数转换为字符串 便于后续的操作</span></span><br><span class="line">        s = <span class="built_in">str</span>(n)</span><br><span class="line"></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        参数说明:</span></span><br><span class="line"><span class="string">        i 当前枚举的位数</span></span><br><span class="line"><span class="string">        mask 当前所枚举过的数 用二进制集合表示</span></span><br><span class="line"><span class="string">            mask&gt;&gt;d &amp; 1 是否为1  用于判断 d 是否已经枚举过</span></span><br><span class="line"><span class="string">            mask&gt;&gt;d | 1 将枚举过的这位进行标记</span></span><br><span class="line"><span class="string">        is_limit 表示前面所填的数字是否为n对应位上的 如果是 那么当前位所填的数字就要受到数n制约 即最大不能超过n在当前位的数字 否则可以直接枚举0-9  </span></span><br><span class="line"><span class="string">        is_num 表示前面是否填了数字(是否跳过数字0) </span></span><br><span class="line"><span class="string">            如果没有填数字0 则跳过当前位置 或者从1开始计数 </span></span><br><span class="line"><span class="string">            否则(is_num = true) 可以从0开始给</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">        @cache</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">i: <span class="built_in">int</span>, mask: <span class="built_in">int</span>, is_limit: <span class="built_in">bool</span>, is_num: <span class="built_in">bool</span></span>)-&gt;<span class="built_in">int</span>:</span><br><span class="line">            <span class="comment"># 枚举的位数 已经达到了 n 的位数 直接返回</span></span><br><span class="line">            <span class="keyword">if</span> i == <span class="built_in">len</span>(s):</span><br><span class="line">                <span class="comment"># 如果之前已经填过数字 那么即代表已经成功构造出一个有效答案 否则return 0</span></span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">int</span>(is_num)</span><br><span class="line">            res = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 如果is_num 为false 即之前还没有填过数</span></span><br><span class="line">            <span class="comment"># 这里先选择直接跳过 因为这里还没有进入枚举环节</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> is_num:</span><br><span class="line">                <span class="comment"># 比如 009 如果 他之前的值并没有枚举过 那么这种情况 就会和 09 9 两种情况重复了 所以选择跳过</span></span><br><span class="line">                <span class="comment"># is_limit 之前都没有填过数 那么当然也不可能填 n 对应位上的数 所以仍位false</span></span><br><span class="line">                <span class="comment"># is_num 之前没有填数字 这位跳过了 那么这位自然也没有填数组</span></span><br><span class="line">                res = f(i + <span class="number">1</span>, mask, <span class="literal">False</span>, <span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 进行枚举 先判断上界</span></span><br><span class="line">            <span class="comment"># 如果之前填过 n相应位置上的数 那么 当前的上界也就只能是 n当前位置上的数 否则可以是0-9</span></span><br><span class="line">            <span class="comment"># 比如 n = 123  上一个枚举的数位已经填 12_ 那么该位置上最多只能填到3 否则就超过n 不符合条件了 否则就能填到0-9</span></span><br><span class="line">            up = <span class="built_in">int</span>(s[i]) <span class="keyword">if</span> is_limit <span class="keyword">else</span> <span class="number">9</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 枚举当前位的数</span></span><br><span class="line">            <span class="comment"># 如果之前位上有填过数 那么当前位就可以从 0 开始 否则就应该从1 开始</span></span><br><span class="line">            start = <span class="number">1</span> - <span class="built_in">int</span>(is_num)</span><br><span class="line">            <span class="comment"># range算法 右边是小于号 所以是 up+1</span></span><br><span class="line">            <span class="keyword">for</span> d <span class="keyword">in</span> <span class="built_in">range</span>(start, up + <span class="number">1</span>):</span><br><span class="line">                <span class="comment"># 如果 d 并没有被枚举过</span></span><br><span class="line">                <span class="keyword">if</span> mask &gt;&gt; d &amp; <span class="number">1</span> == <span class="number">0</span>:</span><br><span class="line">                    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">                    i + 1 : 枚举下一位</span></span><br><span class="line"><span class="string">                    mask | (1 &lt;&lt; d) : 将d 标记  </span></span><br><span class="line"><span class="string">                                      1&lt;&lt;d :  第d位为1 其他位均为0 或运算即可将mask的相应置成1</span></span><br><span class="line"><span class="string">                    is_limit and d == up: 前面所有位都1取到 n相应位的数 才对当前位有限制 否则当前仍可以去0-9 </span></span><br><span class="line"><span class="string">                    True: 当前位置填过数了 那么当前位自然位1</span></span><br><span class="line"><span class="string">                    &quot;&quot;&quot;</span></span><br><span class="line">                    res += f(i + <span class="number">1</span>, mask | (<span class="number">1</span> &lt;&lt; d), is_limit <span class="keyword">and</span> d == up, <span class="literal">True</span>)</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        <span class="comment"># 初始位 0  mask中一个数都没有用过 也为0</span></span><br><span class="line">        <span class="comment"># is_limit为一个特判 要加以限制置为True     is_Num没有取过数自然为False</span></span><br><span class="line">        <span class="keyword">return</span> f(<span class="number">0</span>, <span class="number">0</span>, <span class="literal">True</span>, <span class="literal">False</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面的写法使用了python 中内置的cache 但由于别的语言没有cache关键字 且正常记忆化搜索 通常会创建一个数据 用作cache 所以这里附上不使用cache 关键字的做法 更具有代表性一些</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">countSpecialNumbers</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        s = <span class="built_in">str</span>(n)</span><br><span class="line"><span class="comment"># 这里关于python 二维数组的初始化定义一定要注意下 一定要写成这样 </span></span><br><span class="line"><span class="comment"># 且第一维决定的是列数 二维决定的是行数 这也为数不多我认为python比较麻烦的地方</span></span><br><span class="line">        dp = [[-<span class="number">1</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">1</span>&lt;&lt;<span class="number">10</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(s))]</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">i: <span class="built_in">int</span>, mask: <span class="built_in">int</span>, is_limit: <span class="built_in">bool</span>, is_num: <span class="built_in">bool</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">            <span class="keyword">if</span> i == <span class="built_in">len</span>(s):</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">int</span>(is_num)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> is_limit <span class="keyword">and</span> is_num <span class="keyword">and</span> dp[i][mask] &gt;= <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> dp[i][mask]</span><br><span class="line">            res = <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> is_num:</span><br><span class="line">                res = f(i + <span class="number">1</span>, mask, <span class="literal">False</span>, <span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">            up = <span class="built_in">int</span>(s[i]) <span class="keyword">if</span> is_limit <span class="keyword">else</span> <span class="number">9</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> d <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span> - <span class="built_in">int</span>(is_num), up + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> mask &gt;&gt; d &amp; <span class="number">1</span> == <span class="number">0</span>:</span><br><span class="line">                    res += f(i + <span class="number">1</span>, mask | (<span class="number">1</span> &lt;&lt; d), is_limit <span class="keyword">and</span> d == up, <span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> is_limit <span class="keyword">and</span> is_num:</span><br><span class="line">                dp[i][mask] = res</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> f(<span class="number">0</span>, <span class="number">0</span>, <span class="literal">True</span>, <span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algo </category>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数位dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法模板-循环双端队列</title>
      <link href="/2022/08/15/algoSummary/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF-%E5%BE%AA%E7%8E%AF%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97/"/>
      <url>/2022/08/15/algoSummary/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF-%E5%BE%AA%E7%8E%AF%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>循环队列概念很早接触了 但在细节方面一直有些迷糊<br>正好今天的每日一题是循环队列 总结了一下<br>关键以下两点:<br>1.对于front 和 rear的定义要明确</p><p>​font指向的是队头有效元素的位置 而rear则指向的是队尾下一个有效元素的位置 这就导致一些差异 </p><p>​最主要的就是进行队尾插入时 要先进行赋值 q[rear] &#x3D; value 而后移动rear 指针 因为根据rear指针的定义之前rear指针所指向的位置 正是此时元素应该插入的有效位置</p><p>​然后根据rear 定义 那么返回队尾元素时 返回应该时rear-1这个位置的元素 而并非rear<br>2.空出一个有效位置作为哨兵 主要是为了区分队空和队满两种状态</p><p>​这和rear指针的定义是紧密关联的 </p><p>​当 (rear + 1 % capacity) &#x3D;&#x3D; front 代表 此时队列已满 可以这样理解 rear 代表下一个元素的有效位置 即下一个元素的有效位置已经是front了那么这样就代表队满了</p><p>​同时根据上述定义 真正队满是 front !&#x3D; rear 所以队空的情况只能是 front &#x3D;&#x3D; rear</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyCircularDeque</span> &#123;</span><br><span class="line">    <span class="comment">// front 指向队列头部第1个有效数据的位置</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> front;</span><br><span class="line">    <span class="comment">// rear指向队列尾部(即最后一个有效数据)的下一个位置</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> rear;</span><br><span class="line">    <span class="comment">// capacity = k + 1 取最后多余的一个位置作为哨兵</span></span><br><span class="line">    <span class="comment">// 当 rear 指向这个位置时 代表队列已满  代入循环队列这个条件则为 : (rear + 1) % capacity == front (即rear当前所指向的位置的下一个位置就是front的位置那么就代表队列已经满了)</span></span><br><span class="line">    <span class="comment">// 当 rear == front时 代表队列为空</span></span><br><span class="line">    <span class="comment">// 队头: 插入  (font - 1 + capacity ) % capacity    删除: (front + 1 + capacity) % capacity</span></span><br><span class="line">    <span class="comment">// 队尾: 插入  (rear + 1 + capacity) % capacity     删除: (rear - 1 + capacity) % capacity</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> [] q;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyCircularDeque</span><span class="params">(<span class="type">int</span> k)</span> &#123;</span><br><span class="line">        capacity = k + <span class="number">1</span>;</span><br><span class="line">        front = <span class="number">0</span>;</span><br><span class="line">        rear = <span class="number">0</span>;</span><br><span class="line">        q = <span class="keyword">new</span> <span class="title class_">int</span>[capacity];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">insertFront</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(isFull() == <span class="literal">true</span> )</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        front = (front - <span class="number">1</span> + capacity) % capacity;</span><br><span class="line">        q[front] = value;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">insertLast</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(isFull() == <span class="literal">true</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 这里要注意要先在队尾插入 始终记住 rear指向的是下一个有效位置</span></span><br><span class="line">        q[rear] = value;</span><br><span class="line">        rear = (rear + <span class="number">1</span> + capacity)%capacity;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">deleteFront</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(isEmpty() == <span class="literal">true</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        front = (front + <span class="number">1</span> + capacity) % capacity;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">deleteLast</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(isEmpty() == <span class="literal">true</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        rear = (rear - <span class="number">1</span> + capacity) % capacity;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getFront</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(isEmpty() == <span class="literal">true</span>)</span><br><span class="line">            <span class="keyword">return</span>  -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> q[front];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getRear</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty() == <span class="literal">true</span>)</span><br><span class="line">            <span class="keyword">return</span>  -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 这里要注意下 因为rear的定义是指向下一个有效位置 </span></span><br><span class="line">        <span class="comment">// 所以应该返回rear的上一个位置 又因为循环队列所以要注意取模</span></span><br><span class="line">        <span class="keyword">return</span> q[(rear - <span class="number">1</span> + capacity) % capacity];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> front == rear;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (rear + <span class="number">1</span>) % capacity  == front;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algo </category>
          
          <category> 算法总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 循环队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode2317-操作后的最大异或和-位运算推导</title>
      <link href="/2022/08/12/leetcode/leetcode2317-%E6%93%8D%E4%BD%9C%E5%90%8E%E7%9A%84%E6%9C%80%E5%A4%A7%E5%BC%82%E6%88%96%E5%92%8C-%E4%BD%8D%E8%BF%90%E7%AE%97%E6%8E%A8%E5%AF%BC/"/>
      <url>/2022/08/12/leetcode/leetcode2317-%E6%93%8D%E4%BD%9C%E5%90%8E%E7%9A%84%E6%9C%80%E5%A4%A7%E5%BC%82%E6%88%96%E5%92%8C-%E4%BD%8D%E8%BF%90%E7%AE%97%E6%8E%A8%E5%AF%BC/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>原题链接<br><a href="https://leetcode.cn/problems/maximum-xor-after-operations/">https://leetcode.cn/problems/maximum-xor-after-operations/</a><br>非常巧妙的一道题 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 首先这个任意的非负x  不需要是在数组内出现的 就是一个任意数</span></span><br><span class="line"><span class="comment"> *  nums[i] and (nums[i] xor x)</span></span><br><span class="line"><span class="comment"> *  则 x 可以选一个 x 的二进制为 1 的位置 而 nums[i] 为0  x的二进制位置为0 nums[i]为0 的数 (即起到保留x所有的1的效果)</span></span><br><span class="line"><span class="comment"> *  则可将 nums[i] xor x 化简为 x</span></span><br><span class="line"><span class="comment"> *  从而得到 原式 =  nums[i] and x = x</span></span><br><span class="line"><span class="comment"> *  最终答案求 MaxSum(nums[0..n]) xor x</span></span><br><span class="line"><span class="comment"> *  最终求的结果中1 越多则其值就越大 即在异或运算的过程中 尽可能多的 留1</span></span><br><span class="line"><span class="comment"> *  即 只要 nums[0..n] 中 一位 有1 不管是奇数还是偶数 都可以 使用x进行调整从而将1 保留 (偶数 则 x 在这位取1 否则取0)</span></span><br><span class="line"><span class="comment"> *  从而演变为 nums[0..n] 的 或运算  (因为或运算只要有1 就会输出1)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maximumXOR</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span> ; i&lt;nums.length ; i++)&#123;</span><br><span class="line">            nums[i] = nums[i] | nums[i-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> nums[nums.length - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algo </category>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 位运算 </tag>
            
            <tag> 推导题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法模板-静态数组存储图</title>
      <link href="/2022/08/12/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF-%E9%9D%99%E6%80%81%E6%95%B0%E7%BB%84%E5%AD%98%E5%82%A8%E5%9B%BE/"/>
      <url>/2022/08/12/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF-%E9%9D%99%E6%80%81%E6%95%B0%E7%BB%84%E5%AD%98%E5%82%A8%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>基本上任何情况都可以使用这种方法存<br><strong>N &#x3D; 1e5 的时候就一定要这么存了</strong><br>N &#x3D; 1e3 左右可以偷懒一下 使用邻接矩阵来存、</p><p>模板:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> h[N];             <span class="comment">//存储表头</span></span><br><span class="line"><span class="type">int</span> e[N], ne[N], idx; <span class="comment">//邻接表的基本参值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//将b插入a后</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx, idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//然后要注意初始化和遍历的问题</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">总的来说就是把 头节点 h[] 全部初始化为-1 用什么方法都行</span></span><br><span class="line"><span class="comment">C++的话 用memset会快一些 其他语言直接遍历一遍就行了</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">遍历</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// u 为初始遍历的点</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=h[u] ; i!=<span class="number">-1</span> ;i = ne[i])&#123;</span><br><span class="line"><span class="comment">// 取出链表中存在的值 通常为节点值</span></span><br><span class="line"><span class="type">int</span> j = e[i];</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">然后这下面根据题意进行相关操作 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法模板 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法模板-组合数</title>
      <link href="/2022/08/07/algoSummary/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF-%E7%BB%84%E5%90%88%E6%95%B0/"/>
      <url>/2022/08/07/algoSummary/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF-%E7%BB%84%E5%90%88%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1><span id="组合数">组合数</span></h1><h2><span id="基础定理">基础定理</span></h2><ol><li>基本公式 : C(n,r) &#x3D; n! &#x2F; r!(n-r)! (从n中选r个的方案)</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">C</span>(<span class="params">n,m</span>):</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">从n个球中 选取m个球的方案数 </span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">res = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">res = res * (n - i)</span><br><span class="line">res = res // (i + <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> res </span><br></pre></td></tr></table></figure><ol start="2"><li>递推公式 : C(m,n) &#x3D;  C(m-1,n) + C(m-1,n-1)<br>如果只在求答案的时候用的话 就用第一条就可以了<br>但如果需要大量计算组合数 则需要对组合数进行预处理 因为求组合数事实上是在求阶乘 还是比较慢<br>这个时候需要用到 递推公式</li></ol><h2><span id="组合数预处理递推法">组合数预处理(递推法)</span></h2><p>这种情况N &#x3D; 1000 左右</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// c[a][b] 表示从a个苹果中选b个的方案数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i ++ )</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= i; j ++ )</span><br><span class="line">        <span class="comment">// 从i 个中 选取0 个的方案数 只有一种</span></span><br><span class="line"><span class="keyword">if</span> (j == <span class="number">0</span>) </span><br><span class="line">c[i][j] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="comment">// 递推公式 通常这种需要预处理的情况 值会比较大需要mod一下</span></span><br><span class="line">c[i][j] = (c[i - <span class="number">1</span>][j] + c[i - <span class="number">1</span>][j - <span class="number">1</span>]) % mod;</span><br></pre></td></tr></table></figure><h3><span id="组合数预处理递推-求逆元">组合数预处理(递推 + 求逆元)</span></h3><p>这种情况 N &#x3D; 100000 左右 即通过普通的递推法处理仍有可能超时</p><ol><li>需要先预处理出所有阶乘fact[N](通常是求取模的余数 因为数会很大)</li><li>同时求出所有阶乘取模的逆元infact[N]</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过快速来求逆元</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qmi</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> k, <span class="type">int</span> p)</span>    </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (k &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (k &amp; <span class="number">1</span> == <span class="number">1</span>) res = (LL)res * a % p;</span><br><span class="line">        a = (LL)a * a % p;</span><br><span class="line">        k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 预处理阶乘的余数和阶乘逆元的余数</span></span><br><span class="line">fact[<span class="number">0</span>] = infact[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; N; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    fact[i] = (LL)fact[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">    infact[i] = (LL)infact[i - <span class="number">1</span>] * <span class="built_in">qmi</span>(i, mod - <span class="number">2</span>, mod) % mod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algo </category>
          
          <category> 算法总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 组合数(算法) </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
